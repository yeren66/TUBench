{
  "commit_hash": "669023ac454642c34181d82b678539f2a020b3a0",
  "parent_hash": "2bf6e53e95cc6094f584fe748847fd847b3eafd2",
  "basic_info": {
    "project": "commons-csv",
    "commit_hash": "669023ac454642c34181d82b678539f2a020b3a0",
    "short_hash": "669023ac",
    "parent_hash": "2bf6e53e95cc6094f584fe748847fd847b3eafd2",
    "parent_short_hash": "2bf6e53e",
    "author": "Sebb",
    "date": "2025-01-18 22:30:57",
    "message": "Normalise EOL",
    "message_subject": "Normalise EOL"
  },
  "file_changes": {
    "source_files": [
      {
        "path": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "change_type": "modified",
        "old_path": null,
        "is_java": true
      },
      {
        "path": "src/main/java/org/apache/commons/csv/Constants.java",
        "change_type": "modified",
        "old_path": null,
        "is_java": true
      }
    ],
    "test_files": [
      {
        "path": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "change_type": "modified",
        "old_path": null,
        "is_java": true
      },
      {
        "path": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "change_type": "modified",
        "old_path": null,
        "is_java": true
      },
      {
        "path": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "change_type": "modified",
        "old_path": null,
        "is_java": true
      },
      {
        "path": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "change_type": "modified",
        "old_path": null,
        "is_java": true
      },
      {
        "path": "src/test/java/org/apache/commons/csv/issues/JiraCsv198Test.java",
        "change_type": "modified",
        "old_path": null,
        "is_java": true
      },
      {
        "path": "src/test/java/org/apache/commons/csv/issues/JiraCsv211Test.java",
        "change_type": "modified",
        "old_path": null,
        "is_java": true
      },
      {
        "path": "src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java",
        "change_type": "modified",
        "old_path": null,
        "is_java": true
      }
    ],
    "other_files": [
      {
        "path": ".gitattributes",
        "change_type": "added",
        "old_path": null,
        "is_java": false
      },
      {
        "path": ".github/workflows/codeql-analysis.yml",
        "change_type": "modified",
        "old_path": null,
        "is_java": false
      },
      {
        "path": ".github/workflows/maven.yml",
        "change_type": "modified",
        "old_path": null,
        "is_java": false
      },
      {
        "path": "src/assembly/bin.xml",
        "change_type": "modified",
        "old_path": null,
        "is_java": false
      },
      {
        "path": "src/assembly/src.xml",
        "change_type": "modified",
        "old_path": null,
        "is_java": false
      },
      {
        "path": "src/changes/changes.xml",
        "change_type": "modified",
        "old_path": null,
        "is_java": false
      }
    ],
    "summary": {
      "total_files": 15,
      "source_count": 2,
      "test_count": 7,
      "other_count": 6
    }
  },
  "method_changes": {
    "source_methods": [
      {
        "class": "CSVPrinter",
        "method": "close",
        "parameters": [],
        "start_line": 126,
        "end_line": 128,
        "file": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "package": "org.apache.commons.csv"
      },
      {
        "class": "CSVPrinter",
        "method": "endOfRecord",
        "parameters": [],
        "start_line": 152,
        "end_line": 155,
        "file": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "package": "org.apache.commons.csv"
      },
      {
        "class": "CSVPrinter",
        "method": "flush",
        "parameters": [],
        "start_line": 164,
        "end_line": 168,
        "file": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "package": "org.apache.commons.csv"
      },
      {
        "class": "CSVPrinter",
        "method": "getOut",
        "parameters": [],
        "start_line": 175,
        "end_line": 177,
        "file": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "package": "org.apache.commons.csv"
      },
      {
        "class": "CSVPrinter",
        "method": "getRecordCount",
        "parameters": [],
        "start_line": 185,
        "end_line": 187,
        "file": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "package": "org.apache.commons.csv"
      },
      {
        "class": "CSVPrinter",
        "method": "print",
        "parameters": [
          "Object"
        ],
        "start_line": 197,
        "end_line": 200,
        "file": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "package": "org.apache.commons.csv"
      },
      {
        "class": "CSVPrinter",
        "method": "printComment",
        "parameters": [
          "String"
        ],
        "start_line": 223,
        "end_line": 251,
        "file": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "package": "org.apache.commons.csv"
      },
      {
        "class": "CSVPrinter",
        "method": "printHeaders",
        "parameters": [
          "ResultSet"
        ],
        "start_line": 261,
        "end_line": 266,
        "file": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "package": "org.apache.commons.csv"
      },
      {
        "class": "CSVPrinter",
        "method": "println",
        "parameters": [],
        "start_line": 274,
        "end_line": 277,
        "file": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "package": "org.apache.commons.csv"
      },
      {
        "class": "CSVPrinter",
        "method": "printRecord",
        "parameters": [
          "Iterable"
        ],
        "start_line": 293,
        "end_line": 296,
        "file": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "package": "org.apache.commons.csv"
      },
      {
        "class": "CSVPrinter",
        "method": "printRecordObject",
        "parameters": [
          "Object"
        ],
        "start_line": 335,
        "end_line": 343,
        "file": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "package": "org.apache.commons.csv"
      },
      {
        "class": "CSVPrinter",
        "method": "printRecords",
        "parameters": [
          "Iterable"
        ],
        "start_line": 384,
        "end_line": 386,
        "file": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "package": "org.apache.commons.csv"
      }
    ],
    "test_methods": [
      {
        "class": "CSVFormatTest",
        "method": "assertNotEquals",
        "parameters": [
          "Object",
          "Object"
        ],
        "start_line": 67,
        "end_line": 70,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "copy",
        "parameters": [
          "CSVFormat"
        ],
        "start_line": 72,
        "end_line": 74,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testBuildVsGet",
        "parameters": [],
        "start_line": 86,
        "end_line": 89,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testDelimiterEmptyStringThrowsException1",
        "parameters": [],
        "start_line": 92,
        "end_line": 94,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testDelimiterSameAsCommentStartThrowsException_Deprecated",
        "parameters": [],
        "start_line": 98,
        "end_line": 100,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testDelimiterSameAsCommentStartThrowsException1",
        "parameters": [],
        "start_line": 103,
        "end_line": 105,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testDelimiterSameAsEscapeThrowsException_Deprecated",
        "parameters": [],
        "start_line": 109,
        "end_line": 111,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testDelimiterSameAsEscapeThrowsException1",
        "parameters": [],
        "start_line": 114,
        "end_line": 116,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testDelimiterSameAsRecordSeparatorThrowsException",
        "parameters": [],
        "start_line": 119,
        "end_line": 121,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testDuplicateHeaderElements",
        "parameters": [],
        "start_line": 124,
        "end_line": 129,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testDuplicateHeaderElements_Deprecated",
        "parameters": [],
        "start_line": 133,
        "end_line": 138,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testDuplicateHeaderElementsFalse",
        "parameters": [],
        "start_line": 141,
        "end_line": 143,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testDuplicateHeaderElementsFalse_Deprecated",
        "parameters": [],
        "start_line": 147,
        "end_line": 149,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testDuplicateHeaderElementsTrue",
        "parameters": [],
        "start_line": 152,
        "end_line": 154,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testDuplicateHeaderElementsTrue_Deprecated",
        "parameters": [],
        "start_line": 158,
        "end_line": 160,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testDuplicateHeaderElementsTrueContainsEmpty1",
        "parameters": [],
        "start_line": 163,
        "end_line": 165,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testDuplicateHeaderElementsTrueContainsEmpty2",
        "parameters": [],
        "start_line": 168,
        "end_line": 170,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testDuplicateHeaderElementsTrueContainsEmpty3",
        "parameters": [],
        "start_line": 173,
        "end_line": 175,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEquals",
        "parameters": [],
        "start_line": 178,
        "end_line": 188,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsCommentStart",
        "parameters": [],
        "start_line": 191,
        "end_line": 196,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsCommentStart_Deprecated",
        "parameters": [],
        "start_line": 200,
        "end_line": 205,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsDelimiter",
        "parameters": [],
        "start_line": 208,
        "end_line": 213,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsEscape",
        "parameters": [],
        "start_line": 216,
        "end_line": 221,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsEscape_Deprecated",
        "parameters": [],
        "start_line": 225,
        "end_line": 230,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsHash",
        "parameters": [],
        "start_line": 233,
        "end_line": 302,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsHeader",
        "parameters": [],
        "start_line": 305,
        "end_line": 311,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsHeader_Deprecated",
        "parameters": [],
        "start_line": 315,
        "end_line": 321,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsIgnoreEmptyLines",
        "parameters": [],
        "start_line": 324,
        "end_line": 330,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsIgnoreEmptyLines_Deprecated",
        "parameters": [],
        "start_line": 334,
        "end_line": 340,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsIgnoreSurroundingSpaces",
        "parameters": [],
        "start_line": 343,
        "end_line": 349,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsIgnoreSurroundingSpaces_Deprecated",
        "parameters": [],
        "start_line": 353,
        "end_line": 359,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsLeftNoQuoteRightQuote",
        "parameters": [],
        "start_line": 362,
        "end_line": 367,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsLeftNoQuoteRightQuote_Deprecated",
        "parameters": [],
        "start_line": 371,
        "end_line": 376,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsNoQuotes",
        "parameters": [],
        "start_line": 379,
        "end_line": 384,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsNoQuotes_Deprecated",
        "parameters": [],
        "start_line": 388,
        "end_line": 393,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsNullString",
        "parameters": [],
        "start_line": 396,
        "end_line": 402,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsNullString_Deprecated",
        "parameters": [],
        "start_line": 406,
        "end_line": 412,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsOne",
        "parameters": [],
        "start_line": 415,
        "end_line": 542,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsQuoteChar",
        "parameters": [],
        "start_line": 545,
        "end_line": 550,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsQuoteChar_Deprecated",
        "parameters": [],
        "start_line": 554,
        "end_line": 559,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsQuotePolicy",
        "parameters": [],
        "start_line": 562,
        "end_line": 567,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsQuotePolicy_Deprecated",
        "parameters": [],
        "start_line": 571,
        "end_line": 576,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsRecordSeparator",
        "parameters": [],
        "start_line": 579,
        "end_line": 585,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsRecordSeparator_Deprecated",
        "parameters": [],
        "start_line": 589,
        "end_line": 595,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsSkipHeaderRecord",
        "parameters": [],
        "start_line": 597,
        "end_line": 603,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsSkipHeaderRecord_Deprecated",
        "parameters": [],
        "start_line": 607,
        "end_line": 613,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEqualsWithNull",
        "parameters": [],
        "start_line": 616,
        "end_line": 676,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEscapeSameAsCommentStartThrowsException",
        "parameters": [],
        "start_line": 679,
        "end_line": 681,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEscapeSameAsCommentStartThrowsException_Deprecated",
        "parameters": [],
        "start_line": 685,
        "end_line": 687,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEscapeSameAsCommentStartThrowsExceptionForWrapperType",
        "parameters": [],
        "start_line": 690,
        "end_line": 694,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testEscapeSameAsCommentStartThrowsExceptionForWrapperType_Deprecated",
        "parameters": [],
        "start_line": 698,
        "end_line": 701,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testFormat",
        "parameters": [],
        "start_line": 704,
        "end_line": 710,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testFormatThrowsNullPointerException",
        "parameters": [],
        "start_line": 713,
        "end_line": 719,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testFormatToString",
        "parameters": [],
        "start_line": 722,
        "end_line": 739,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testGetAllowDuplicateHeaderNames",
        "parameters": [],
        "start_line": 742,
        "end_line": 748,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testGetDuplicateHeaderMode",
        "parameters": [],
        "start_line": 751,
        "end_line": 758,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testGetHeader",
        "parameters": [],
        "start_line": 761,
        "end_line": 771,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testHashCodeAndWithIgnoreHeaderCase",
        "parameters": [],
        "start_line": 774,
        "end_line": 789,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testJiraCsv236",
        "parameters": [],
        "start_line": 792,
        "end_line": 794,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testJiraCsv236__Deprecated",
        "parameters": [],
        "start_line": 798,
        "end_line": 800,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testNewFormat",
        "parameters": [],
        "start_line": 803,
        "end_line": 861,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testNullRecordSeparatorCsv106",
        "parameters": [],
        "start_line": 864,
        "end_line": 869,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testNullRecordSeparatorCsv106__Deprecated",
        "parameters": [],
        "start_line": 873,
        "end_line": 878,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testPrintRecord",
        "parameters": [],
        "start_line": 881,
        "end_line": 886,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testPrintRecordEmpty",
        "parameters": [],
        "start_line": 889,
        "end_line": 894,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testPrintWithEscapesEndWithCRLF",
        "parameters": [],
        "start_line": 897,
        "end_line": 903,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testPrintWithEscapesEndWithoutCRLF",
        "parameters": [],
        "start_line": 906,
        "end_line": 912,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testPrintWithoutQuotes",
        "parameters": [],
        "start_line": 915,
        "end_line": 921,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testPrintWithQuoteModeIsNONE",
        "parameters": [],
        "start_line": 924,
        "end_line": 930,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testPrintWithQuotes",
        "parameters": [],
        "start_line": 933,
        "end_line": 939,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testQuoteCharSameAsCommentStartThrowsException",
        "parameters": [],
        "start_line": 942,
        "end_line": 944,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testQuoteCharSameAsCommentStartThrowsException_Deprecated",
        "parameters": [],
        "start_line": 948,
        "end_line": 950,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType",
        "parameters": [],
        "start_line": 953,
        "end_line": 956,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType_Deprecated",
        "parameters": [],
        "start_line": 960,
        "end_line": 963,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testQuoteCharSameAsDelimiterThrowsException",
        "parameters": [],
        "start_line": 966,
        "end_line": 968,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testQuoteCharSameAsDelimiterThrowsException_Deprecated",
        "parameters": [],
        "start_line": 972,
        "end_line": 974,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testQuoteModeNoneShouldReturnMeaningfulExceptionMessage",
        "parameters": [],
        "start_line": 977,
        "end_line": 989,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testQuotePolicyNoneWithoutEscapeThrowsException",
        "parameters": [],
        "start_line": 992,
        "end_line": 994,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testQuotePolicyNoneWithoutEscapeThrowsException_Deprecated",
        "parameters": [],
        "start_line": 998,
        "end_line": 1000,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testRFC4180",
        "parameters": [],
        "start_line": 1003,
        "end_line": 1011,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testSerialization",
        "parameters": [],
        "start_line": 1015,
        "end_line": 1034,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testToString",
        "parameters": [],
        "start_line": 1037,
        "end_line": 1043,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testToStringAndWithCommentMarkerTakingCharacter",
        "parameters": [],
        "start_line": 1046,
        "end_line": 1204,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testTrim",
        "parameters": [],
        "start_line": 1207,
        "end_line": 1229,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithCommentStart",
        "parameters": [],
        "start_line": 1232,
        "end_line": 1235,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithCommentStartCRThrowsException",
        "parameters": [],
        "start_line": 1238,
        "end_line": 1240,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithDelimiter",
        "parameters": [],
        "start_line": 1243,
        "end_line": 1246,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithDelimiterLFThrowsException",
        "parameters": [],
        "start_line": 1249,
        "end_line": 1251,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithEmptyDuplicates",
        "parameters": [],
        "start_line": 1254,
        "end_line": 1259,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithEmptyEnum",
        "parameters": [],
        "start_line": 1262,
        "end_line": 1265,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithEscape",
        "parameters": [],
        "start_line": 1268,
        "end_line": 1271,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithEscapeCRThrowsExceptions",
        "parameters": [],
        "start_line": 1274,
        "end_line": 1276,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithFirstRecordAsHeader",
        "parameters": [],
        "start_line": 1279,
        "end_line": 1283,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithHeader",
        "parameters": [],
        "start_line": 1286,
        "end_line": 1292,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithHeaderComments",
        "parameters": [],
        "start_line": 1295,
        "end_line": 1453,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithHeaderEnum",
        "parameters": [],
        "start_line": 1456,
        "end_line": 1459,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithHeaderEnumNull",
        "parameters": [],
        "start_line": 1462,
        "end_line": 1466,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithHeaderResultSetNull",
        "parameters": [],
        "start_line": 1469,
        "end_line": 1473,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithIgnoreEmptyLines",
        "parameters": [],
        "start_line": 1476,
        "end_line": 1479,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithIgnoreSurround",
        "parameters": [],
        "start_line": 1482,
        "end_line": 1485,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithNullString",
        "parameters": [],
        "start_line": 1488,
        "end_line": 1491,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithQuoteChar",
        "parameters": [],
        "start_line": 1494,
        "end_line": 1497,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithQuoteLFThrowsException",
        "parameters": [],
        "start_line": 1500,
        "end_line": 1502,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithQuotePolicy",
        "parameters": [],
        "start_line": 1505,
        "end_line": 1508,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithRecordSeparatorCR",
        "parameters": [],
        "start_line": 1511,
        "end_line": 1514,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithRecordSeparatorCRLF",
        "parameters": [],
        "start_line": 1517,
        "end_line": 1520,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithRecordSeparatorLF",
        "parameters": [],
        "start_line": 1523,
        "end_line": 1526,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVFormatTest",
        "method": "testWithSystemRecordSeparator",
        "parameters": [],
        "start_line": 1529,
        "end_line": 1532,
        "file": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "createBOMInputStream",
        "parameters": [
          "String"
        ],
        "start_line": 124,
        "end_line": 126,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "parse",
        "parameters": [
          "CSVParser",
          "int"
        ],
        "start_line": 128,
        "end_line": 134,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "parseFully",
        "parameters": [
          "CSVParser"
        ],
        "start_line": 136,
        "end_line": 138,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testBackslashEscaping",
        "parameters": [],
        "start_line": 141,
        "end_line": 174,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testBackslashEscaping2",
        "parameters": [],
        "start_line": 177,
        "end_line": 197,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testBackslashEscapingOld",
        "parameters": [],
        "start_line": 201,
        "end_line": 221,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testBOM",
        "parameters": [],
        "start_line": 225,
        "end_line": 230,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testBOMInputStreamParserWithInputStream",
        "parameters": [],
        "start_line": 233,
        "end_line": 238,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testBOMInputStreamParserWithReader",
        "parameters": [],
        "start_line": 241,
        "end_line": 249,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testBOMInputStreamParseWithReader",
        "parameters": [],
        "start_line": 252,
        "end_line": 260,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testCarriageReturnEndings",
        "parameters": [],
        "start_line": 263,
        "end_line": 269,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testCarriageReturnLineFeedEndings",
        "parameters": [],
        "start_line": 272,
        "end_line": 278,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testClose",
        "parameters": [],
        "start_line": 281,
        "end_line": 290,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testCSV141CSVFormat_DEFAULT",
        "parameters": [],
        "start_line": 293,
        "end_line": 295,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testCSV141CSVFormat_INFORMIX_UNLOAD",
        "parameters": [],
        "start_line": 298,
        "end_line": 300,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testCSV141CSVFormat_INFORMIX_UNLOAD_CSV",
        "parameters": [],
        "start_line": 303,
        "end_line": 305,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testCSV141CSVFormat_ORACLE",
        "parameters": [],
        "start_line": 308,
        "end_line": 310,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testCSV141CSVFormat_POSTGRESQL_CSV",
        "parameters": [],
        "start_line": 313,
        "end_line": 315,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testCSV141Excel",
        "parameters": [],
        "start_line": 318,
        "end_line": 320,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testCSV141Failure",
        "parameters": [
          "CSVFormat",
          "int"
        ],
        "start_line": 322,
        "end_line": 350,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testCSV141Ok",
        "parameters": [
          "CSVFormat"
        ],
        "start_line": 352,
        "end_line": 385,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testCSV141RFC4180",
        "parameters": [],
        "start_line": 388,
        "end_line": 390,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testCSV235",
        "parameters": [],
        "start_line": 393,
        "end_line": 404,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testCSV57",
        "parameters": [],
        "start_line": 407,
        "end_line": 413,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testDefaultFormat",
        "parameters": [],
        "start_line": 416,
        "end_line": 438,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testDuplicateHeadersAllowedByDefault",
        "parameters": [],
        "start_line": 441,
        "end_line": 445,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testDuplicateHeadersNotAllowed",
        "parameters": [],
        "start_line": 448,
        "end_line": 451,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testEmptyFile",
        "parameters": [],
        "start_line": 454,
        "end_line": 459,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testEmptyFileHeaderParsing",
        "parameters": [],
        "start_line": 462,
        "end_line": 467,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testEmptyLineBehaviorCSV",
        "parameters": [],
        "start_line": 470,
        "end_line": 484,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testEmptyLineBehaviorExcel",
        "parameters": [],
        "start_line": 487,
        "end_line": 501,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testEmptyString",
        "parameters": [],
        "start_line": 504,
        "end_line": 508,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testEndOfFileBehaviorCSV",
        "parameters": [],
        "start_line": 511,
        "end_line": 526,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testEndOfFileBehaviorExcel",
        "parameters": [],
        "start_line": 529,
        "end_line": 545,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testExcelFormat1",
        "parameters": [],
        "start_line": 548,
        "end_line": 560,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testExcelFormat2",
        "parameters": [],
        "start_line": 563,
        "end_line": 574,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testExcelHeaderCountLessThanData",
        "parameters": [],
        "start_line": 580,
        "end_line": 589,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testFirstEndOfLineCr",
        "parameters": [],
        "start_line": 592,
        "end_line": 599,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testFirstEndOfLineCrLf",
        "parameters": [],
        "start_line": 602,
        "end_line": 609,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testFirstEndOfLineLf",
        "parameters": [],
        "start_line": 612,
        "end_line": 619,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testForEach",
        "parameters": [],
        "start_line": 622,
        "end_line": 634,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetHeaderComment_HeaderComment1",
        "parameters": [],
        "start_line": 637,
        "end_line": 644,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetHeaderComment_HeaderComment2",
        "parameters": [],
        "start_line": 647,
        "end_line": 654,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetHeaderComment_HeaderComment3",
        "parameters": [],
        "start_line": 657,
        "end_line": 664,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetHeaderComment_HeaderTrailerComment",
        "parameters": [],
        "start_line": 667,
        "end_line": 674,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetHeaderComment_NoComment1",
        "parameters": [],
        "start_line": 677,
        "end_line": 684,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetHeaderComment_NoComment2",
        "parameters": [],
        "start_line": 687,
        "end_line": 694,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetHeaderComment_NoComment3",
        "parameters": [],
        "start_line": 697,
        "end_line": 704,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetHeaderMap",
        "parameters": [],
        "start_line": 707,
        "end_line": 728,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetHeaderNames",
        "parameters": [],
        "start_line": 731,
        "end_line": 742,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetHeaderNamesReadOnly",
        "parameters": [],
        "start_line": 745,
        "end_line": 751,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetLine",
        "parameters": [],
        "start_line": 754,
        "end_line": 762,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetLineNumberWithCR",
        "parameters": [],
        "start_line": 765,
        "end_line": 767,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetLineNumberWithCRLF",
        "parameters": [],
        "start_line": 770,
        "end_line": 772,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetLineNumberWithLF",
        "parameters": [],
        "start_line": 775,
        "end_line": 777,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetOneLine",
        "parameters": [],
        "start_line": 780,
        "end_line": 785,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetOneLineOneParser",
        "parameters": [],
        "start_line": 793,
        "end_line": 809,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetRecordFourBytesRead",
        "parameters": [],
        "start_line": 812,
        "end_line": 843,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetRecordNumberWithCR",
        "parameters": [],
        "start_line": 846,
        "end_line": 848,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetRecordNumberWithCRLF",
        "parameters": [],
        "start_line": 851,
        "end_line": 853,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetRecordNumberWithLF",
        "parameters": [],
        "start_line": 856,
        "end_line": 858,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetRecordPositionWithCRLF",
        "parameters": [],
        "start_line": 861,
        "end_line": 863,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetRecordPositionWithLF",
        "parameters": [],
        "start_line": 866,
        "end_line": 868,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetRecords",
        "parameters": [],
        "start_line": 871,
        "end_line": 880,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetRecordsFromBrokenInputStream",
        "parameters": [],
        "start_line": 883,
        "end_line": 888,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetRecordThreeBytesRead",
        "parameters": [],
        "start_line": 891,
        "end_line": 924,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetRecordWithMultiLineValues",
        "parameters": [],
        "start_line": 927,
        "end_line": 949,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetTrailerComment_HeaderComment1",
        "parameters": [],
        "start_line": 952,
        "end_line": 958,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetTrailerComment_HeaderComment2",
        "parameters": [],
        "start_line": 961,
        "end_line": 967,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetTrailerComment_HeaderComment3",
        "parameters": [],
        "start_line": 970,
        "end_line": 976,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetTrailerComment_HeaderTrailerComment1",
        "parameters": [],
        "start_line": 979,
        "end_line": 985,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetTrailerComment_HeaderTrailerComment2",
        "parameters": [],
        "start_line": 988,
        "end_line": 994,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetTrailerComment_HeaderTrailerComment3",
        "parameters": [],
        "start_line": 997,
        "end_line": 1003,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testGetTrailerComment_MultilineComment",
        "parameters": [],
        "start_line": 1006,
        "end_line": 1012,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testHeader",
        "parameters": [],
        "start_line": 1015,
        "end_line": 1031,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testHeaderComment",
        "parameters": [],
        "start_line": 1034,
        "end_line": 1047,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testHeaderMissing",
        "parameters": [],
        "start_line": 1050,
        "end_line": 1062,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testHeaderMissingWithNull",
        "parameters": [],
        "start_line": 1065,
        "end_line": 1070,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testHeadersMissing",
        "parameters": [],
        "start_line": 1073,
        "end_line": 1078,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testHeadersMissingException",
        "parameters": [],
        "start_line": 1081,
        "end_line": 1084,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testHeadersMissingOneColumnException",
        "parameters": [],
        "start_line": 1087,
        "end_line": 1090,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testHeadersWithNullColumnName",
        "parameters": [],
        "start_line": 1093,
        "end_line": 1104,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testIgnoreCaseHeaderMapping",
        "parameters": [],
        "start_line": 1107,
        "end_line": 1116,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testIgnoreEmptyLines",
        "parameters": [],
        "start_line": 1119,
        "end_line": 1127,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testInvalidFormat",
        "parameters": [],
        "start_line": 1130,
        "end_line": 1132,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testIterator",
        "parameters": [],
        "start_line": 1135,
        "end_line": 1150,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testIteratorSequenceBreaking",
        "parameters": [],
        "start_line": 1153,
        "end_line": 1205,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testLineFeedEndings",
        "parameters": [],
        "start_line": 1208,
        "end_line": 1214,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testMappedButNotSetAsOutlook2007ContactExport",
        "parameters": [],
        "start_line": 1217,
        "end_line": 1248,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testMongoDbCsv",
        "parameters": [],
        "start_line": 1252,
        "end_line": 1267,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testMultipleIterators",
        "parameters": [],
        "start_line": 1271,
        "end_line": 1285,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testNewCSVParserNullReaderFormat",
        "parameters": [],
        "start_line": 1288,
        "end_line": 1290,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testNewCSVParserReaderNullFormat",
        "parameters": [],
        "start_line": 1293,
        "end_line": 1295,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testNoHeaderMap",
        "parameters": [],
        "start_line": 1298,
        "end_line": 1302,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testNotValueCSV",
        "parameters": [],
        "start_line": 1305,
        "end_line": 1312,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testParse",
        "parameters": [],
        "start_line": 1315,
        "end_line": 1380,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testParseFileNullFormat",
        "parameters": [],
        "start_line": 1383,
        "end_line": 1385,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testParseNullFileFormat",
        "parameters": [],
        "start_line": 1388,
        "end_line": 1390,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testParseNullPathFormat",
        "parameters": [],
        "start_line": 1393,
        "end_line": 1395,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testParseNullStringFormat",
        "parameters": [],
        "start_line": 1398,
        "end_line": 1400,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testParseNullUrlCharsetFormat",
        "parameters": [],
        "start_line": 1403,
        "end_line": 1405,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testParserUrlNullCharsetFormat",
        "parameters": [],
        "start_line": 1408,
        "end_line": 1410,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testParseStringNullFormat",
        "parameters": [],
        "start_line": 1413,
        "end_line": 1415,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testParseUrlCharsetNullFormat",
        "parameters": [],
        "start_line": 1418,
        "end_line": 1420,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testParseWithDelimiterStringWithEscape",
        "parameters": [],
        "start_line": 1423,
        "end_line": 1434,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testParseWithDelimiterStringWithQuote",
        "parameters": [],
        "start_line": 1437,
        "end_line": 1448,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testParseWithDelimiterWithEscape",
        "parameters": [],
        "start_line": 1451,
        "end_line": 1459,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testParseWithDelimiterWithQuote",
        "parameters": [],
        "start_line": 1462,
        "end_line": 1470,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testParseWithQuoteThrowsException",
        "parameters": [],
        "start_line": 1473,
        "end_line": 1478,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testParseWithQuoteWithEscape",
        "parameters": [],
        "start_line": 1481,
        "end_line": 1489,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testParsingPrintedEmptyFirstColumn",
        "parameters": [
          "CSVFormat"
        ],
        "start_line": 1493,
        "end_line": 1508,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testProvidedHeader",
        "parameters": [],
        "start_line": 1511,
        "end_line": 1531,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testProvidedHeaderAuto",
        "parameters": [],
        "start_line": 1534,
        "end_line": 1554,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testRepeatedHeadersAreReturnedInCSVRecordHeaderNames",
        "parameters": [],
        "start_line": 1557,
        "end_line": 1566,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testRoundtrip",
        "parameters": [],
        "start_line": 1569,
        "end_line": 1579,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testSkipAutoHeader",
        "parameters": [],
        "start_line": 1582,
        "end_line": 1591,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testSkipHeaderOverrideDuplicateHeaders",
        "parameters": [],
        "start_line": 1594,
        "end_line": 1603,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testSkipSetAltHeaders",
        "parameters": [],
        "start_line": 1606,
        "end_line": 1615,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testSkipSetHeader",
        "parameters": [],
        "start_line": 1618,
        "end_line": 1627,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testStartWithEmptyLinesThenHeaders",
        "parameters": [],
        "start_line": 1631,
        "end_line": 1645,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testStream",
        "parameters": [],
        "start_line": 1648,
        "end_line": 1657,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testThrowExceptionWithLineAndPosition",
        "parameters": [],
        "start_line": 1660,
        "end_line": 1675,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testTrailingDelimiter",
        "parameters": [],
        "start_line": 1678,
        "end_line": 1688,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "testTrim",
        "parameters": [],
        "start_line": 1691,
        "end_line": 1701,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "validateLineNumbers",
        "parameters": [
          "String"
        ],
        "start_line": 1703,
        "end_line": 1717,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "validateRecordNumbers",
        "parameters": [
          "String"
        ],
        "start_line": 1719,
        "end_line": 1735,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVParserTest",
        "method": "validateRecordPosition",
        "parameters": [
          "String"
        ],
        "start_line": 1737,
        "end_line": 1811,
        "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "printable",
        "parameters": [
          "String"
        ],
        "start_line": 84,
        "end_line": 95,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "assertInitialState",
        "parameters": [
          "CSVPrinter"
        ],
        "start_line": 101,
        "end_line": 103,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "createTempFile",
        "parameters": [],
        "start_line": 105,
        "end_line": 107,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "createTempPath",
        "parameters": [],
        "start_line": 109,
        "end_line": 111,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "doOneRandom",
        "parameters": [
          "CSVFormat"
        ],
        "start_line": 113,
        "end_line": 143,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "doRandom",
        "parameters": [
          "CSVFormat",
          "int"
        ],
        "start_line": 145,
        "end_line": 149,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "expectNulls",
        "parameters": [
          "T",
          "CSVFormat"
        ],
        "start_line": 155,
        "end_line": 163,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "generateLines",
        "parameters": [
          "int",
          "int"
        ],
        "start_line": 165,
        "end_line": 175,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "getH2Connection",
        "parameters": [],
        "start_line": 177,
        "end_line": 180,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "printWithHeaderComments",
        "parameters": [
          "StringWriter",
          "Date",
          "CSVFormat"
        ],
        "start_line": 182,
        "end_line": 198,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "randStr",
        "parameters": [],
        "start_line": 200,
        "end_line": 245,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "setUpTable",
        "parameters": [
          "Connection"
        ],
        "start_line": 247,
        "end_line": 257,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testCloseBackwardCompatibility",
        "parameters": [],
        "start_line": 260,
        "end_line": 269,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testCloseWithCsvFormatAutoFlushOff",
        "parameters": [],
        "start_line": 272,
        "end_line": 281,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testCloseWithCsvFormatAutoFlushOn",
        "parameters": [],
        "start_line": 284,
        "end_line": 294,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testCloseWithFlushOff",
        "parameters": [],
        "start_line": 297,
        "end_line": 308,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testCloseWithFlushOn",
        "parameters": [],
        "start_line": 311,
        "end_line": 320,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testCRComment",
        "parameters": [],
        "start_line": 323,
        "end_line": 335,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testCSV135",
        "parameters": [],
        "start_line": 338,
        "end_line": 358,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testCSV259",
        "parameters": [],
        "start_line": 361,
        "end_line": 369,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testDelimeterQuoted",
        "parameters": [],
        "start_line": 372,
        "end_line": 380,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testDelimeterQuoteNone",
        "parameters": [],
        "start_line": 383,
        "end_line": 392,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testDelimeterStringQuoted",
        "parameters": [],
        "start_line": 395,
        "end_line": 403,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testDelimeterStringQuoteNone",
        "parameters": [],
        "start_line": 406,
        "end_line": 416,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testDelimiterEscaped",
        "parameters": [],
        "start_line": 419,
        "end_line": 427,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testDelimiterPlain",
        "parameters": [],
        "start_line": 430,
        "end_line": 438,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testDelimiterStringEscaped",
        "parameters": [],
        "start_line": 441,
        "end_line": 449,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testDisabledComment",
        "parameters": [],
        "start_line": 452,
        "end_line": 460,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testDontQuoteEuroFirstChar",
        "parameters": [],
        "start_line": 463,
        "end_line": 470,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testEolEscaped",
        "parameters": [],
        "start_line": 473,
        "end_line": 481,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testEolPlain",
        "parameters": [],
        "start_line": 484,
        "end_line": 492,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testEolQuoted",
        "parameters": [],
        "start_line": 495,
        "end_line": 503,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testEquals",
        "parameters": [],
        "start_line": 507,
        "end_line": 512,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testEscapeBackslash1",
        "parameters": [],
        "start_line": 515,
        "end_line": 522,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testEscapeBackslash2",
        "parameters": [],
        "start_line": 525,
        "end_line": 532,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testEscapeBackslash3",
        "parameters": [],
        "start_line": 535,
        "end_line": 542,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testEscapeBackslash4",
        "parameters": [],
        "start_line": 545,
        "end_line": 552,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testEscapeBackslash5",
        "parameters": [],
        "start_line": 555,
        "end_line": 562,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testEscapeNull1",
        "parameters": [],
        "start_line": 565,
        "end_line": 572,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testEscapeNull2",
        "parameters": [],
        "start_line": 575,
        "end_line": 582,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testEscapeNull3",
        "parameters": [],
        "start_line": 585,
        "end_line": 592,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testEscapeNull4",
        "parameters": [],
        "start_line": 595,
        "end_line": 602,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testEscapeNull5",
        "parameters": [],
        "start_line": 605,
        "end_line": 612,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testExcelPrintAllArrayOfArrays",
        "parameters": [],
        "start_line": 615,
        "end_line": 622,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testExcelPrintAllArrayOfArraysWithFirstEmptyValue2",
        "parameters": [],
        "start_line": 625,
        "end_line": 632,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testExcelPrintAllArrayOfArraysWithFirstSpaceValue1",
        "parameters": [],
        "start_line": 635,
        "end_line": 642,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testExcelPrintAllArrayOfArraysWithFirstTabValue1",
        "parameters": [],
        "start_line": 645,
        "end_line": 652,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testExcelPrintAllArrayOfLists",
        "parameters": [],
        "start_line": 655,
        "end_line": 662,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testExcelPrintAllArrayOfListsWithFirstEmptyValue2",
        "parameters": [],
        "start_line": 665,
        "end_line": 672,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testExcelPrintAllIterableOfArrays",
        "parameters": [],
        "start_line": 675,
        "end_line": 682,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testExcelPrintAllIterableOfArraysWithFirstEmptyValue2",
        "parameters": [],
        "start_line": 685,
        "end_line": 692,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testExcelPrintAllIterableOfLists",
        "parameters": [],
        "start_line": 695,
        "end_line": 702,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testExcelPrintAllStreamOfArrays",
        "parameters": [],
        "start_line": 705,
        "end_line": 712,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testExcelPrinter1",
        "parameters": [],
        "start_line": 715,
        "end_line": 722,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testExcelPrinter2",
        "parameters": [],
        "start_line": 725,
        "end_line": 732,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testHeader",
        "parameters": [],
        "start_line": 735,
        "end_line": 743,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testHeaderCommentExcel",
        "parameters": [],
        "start_line": 746,
        "end_line": 753,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testHeaderCommentTdf",
        "parameters": [],
        "start_line": 756,
        "end_line": 763,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testHeaderNotSet",
        "parameters": [],
        "start_line": 766,
        "end_line": 774,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testInvalidFormat",
        "parameters": [],
        "start_line": 777,
        "end_line": 779,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testJdbcPrinter",
        "parameters": [],
        "start_line": 782,
        "end_line": 813,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testJdbcPrinterWithFirstEmptyValue2",
        "parameters": [],
        "start_line": 816,
        "end_line": 826,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testJdbcPrinterWithResultSet",
        "parameters": [],
        "start_line": 829,
        "end_line": 841,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testJdbcPrinterWithResultSetHeader",
        "parameters": [],
        "start_line": 844,
        "end_line": 862,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testJdbcPrinterWithResultSetMetaData",
        "parameters": [],
        "start_line": 865,
        "end_line": 880,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testJira135_part1",
        "parameters": [],
        "start_line": 883,
        "end_line": 895,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testJira135_part2",
        "parameters": [],
        "start_line": 899,
        "end_line": 911,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testJira135_part3",
        "parameters": [],
        "start_line": 914,
        "end_line": 926,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testJira135All",
        "parameters": [],
        "start_line": 930,
        "end_line": 944,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testMongoDbCsvBasic",
        "parameters": [],
        "start_line": 947,
        "end_line": 954,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testMongoDbCsvCommaInValue",
        "parameters": [],
        "start_line": 957,
        "end_line": 964,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testMongoDbCsvDoubleQuoteInValue",
        "parameters": [],
        "start_line": 967,
        "end_line": 974,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testMongoDbCsvTabInValue",
        "parameters": [],
        "start_line": 977,
        "end_line": 984,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testMongoDbTsvBasic",
        "parameters": [],
        "start_line": 987,
        "end_line": 994,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testMongoDbTsvCommaInValue",
        "parameters": [],
        "start_line": 997,
        "end_line": 1004,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testMongoDbTsvTabInValue",
        "parameters": [],
        "start_line": 1007,
        "end_line": 1013,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testMultiLineComment",
        "parameters": [],
        "start_line": 1016,
        "end_line": 1023,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testMySqlNullOutput",
        "parameters": [],
        "start_line": 1026,
        "end_line": 1125,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testMySqlNullStringDefault",
        "parameters": [],
        "start_line": 1128,
        "end_line": 1130,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testNewCsvPrinterAppendableNullFormat",
        "parameters": [],
        "start_line": 1133,
        "end_line": 1135,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testNewCsvPrinterNullAppendableFormat",
        "parameters": [],
        "start_line": 1138,
        "end_line": 1140,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testNotFlushable",
        "parameters": [],
        "start_line": 1143,
        "end_line": 1150,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testParseCustomNullValues",
        "parameters": [],
        "start_line": 1153,
        "end_line": 1169,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPlainEscaped",
        "parameters": [],
        "start_line": 1172,
        "end_line": 1179,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPlainPlain",
        "parameters": [],
        "start_line": 1182,
        "end_line": 1189,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPlainQuoted",
        "parameters": [],
        "start_line": 1192,
        "end_line": 1198,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPostgreSqlCsvNullOutput",
        "parameters": [],
        "start_line": 1202,
        "end_line": 1301,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPostgreSqlCsvTextOutput",
        "parameters": [],
        "start_line": 1305,
        "end_line": 1404,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPostgreSqlNullStringDefaultCsv",
        "parameters": [],
        "start_line": 1407,
        "end_line": 1409,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPostgreSqlNullStringDefaultText",
        "parameters": [],
        "start_line": 1412,
        "end_line": 1414,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrint",
        "parameters": [],
        "start_line": 1417,
        "end_line": 1424,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrintCSVParser",
        "parameters": [],
        "start_line": 1427,
        "end_line": 1447,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrintCSVRecord",
        "parameters": [],
        "start_line": 1450,
        "end_line": 1475,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrintCSVRecords",
        "parameters": [],
        "start_line": 1478,
        "end_line": 1498,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrintCustomNullValues",
        "parameters": [],
        "start_line": 1501,
        "end_line": 1508,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrinter1",
        "parameters": [],
        "start_line": 1511,
        "end_line": 1519,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrinter2",
        "parameters": [],
        "start_line": 1522,
        "end_line": 1529,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrinter3",
        "parameters": [],
        "start_line": 1532,
        "end_line": 1539,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrinter4",
        "parameters": [],
        "start_line": 1542,
        "end_line": 1549,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrinter5",
        "parameters": [],
        "start_line": 1552,
        "end_line": 1559,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrinter6",
        "parameters": [],
        "start_line": 1562,
        "end_line": 1569,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrinter7",
        "parameters": [],
        "start_line": 1572,
        "end_line": 1579,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrintNullValues",
        "parameters": [],
        "start_line": 1582,
        "end_line": 1589,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrintOnePositiveInteger",
        "parameters": [],
        "start_line": 1592,
        "end_line": 1599,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrintReaderWithoutQuoteToAppendable",
        "parameters": [],
        "start_line": 1612,
        "end_line": 1621,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrintReaderWithoutQuoteToWriter",
        "parameters": [],
        "start_line": 1633,
        "end_line": 1641,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrintRecordStream",
        "parameters": [],
        "start_line": 1644,
        "end_line": 1667,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrintRecordsWithCSVRecord",
        "parameters": [],
        "start_line": 1670,
        "end_line": 1684,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrintRecordsWithEmptyVector",
        "parameters": [],
        "start_line": 1687,
        "end_line": 1702,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrintRecordsWithObjectArray",
        "parameters": [],
        "start_line": 1705,
        "end_line": 1716,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrintRecordsWithResultSetOneRow",
        "parameters": [],
        "start_line": 1719,
        "end_line": 1728,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrintToFileWithCharsetUtf16Be",
        "parameters": [],
        "start_line": 1731,
        "end_line": 1737,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrintToFileWithDefaultCharset",
        "parameters": [],
        "start_line": 1740,
        "end_line": 1746,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testPrintToPathWithDefaultCharset",
        "parameters": [],
        "start_line": 1749,
        "end_line": 1755,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testQuoteAll",
        "parameters": [],
        "start_line": 1758,
        "end_line": 1764,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testQuoteCommaFirstChar",
        "parameters": [],
        "start_line": 1767,
        "end_line": 1773,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testQuoteNonNumeric",
        "parameters": [],
        "start_line": 1776,
        "end_line": 1782,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testRandomDefault",
        "parameters": [],
        "start_line": 1785,
        "end_line": 1787,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testRandomExcel",
        "parameters": [],
        "start_line": 1790,
        "end_line": 1792,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testRandomMongoDbCsv",
        "parameters": [],
        "start_line": 1796,
        "end_line": 1798,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testRandomMySql",
        "parameters": [],
        "start_line": 1801,
        "end_line": 1803,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testRandomOracle",
        "parameters": [],
        "start_line": 1807,
        "end_line": 1809,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testRandomPostgreSqlCsv",
        "parameters": [],
        "start_line": 1813,
        "end_line": 1815,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testRandomPostgreSqlText",
        "parameters": [],
        "start_line": 1818,
        "end_line": 1820,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testRandomRfc4180",
        "parameters": [],
        "start_line": 1823,
        "end_line": 1825,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testRandomTdf",
        "parameters": [],
        "start_line": 1828,
        "end_line": 1830,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testSingleLineComment",
        "parameters": [],
        "start_line": 1833,
        "end_line": 1840,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testSingleQuoteQuoted",
        "parameters": [],
        "start_line": 1843,
        "end_line": 1850,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testSkipHeaderRecordFalse",
        "parameters": [],
        "start_line": 1853,
        "end_line": 1861,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testSkipHeaderRecordTrue",
        "parameters": [],
        "start_line": 1864,
        "end_line": 1872,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testTrailingDelimiterOnTwoColumns",
        "parameters": [],
        "start_line": 1875,
        "end_line": 1881,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testTrimOffOneColumn",
        "parameters": [],
        "start_line": 1884,
        "end_line": 1890,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testTrimOnOneColumn",
        "parameters": [],
        "start_line": 1893,
        "end_line": 1899,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "testTrimOnTwoColumns",
        "parameters": [],
        "start_line": 1902,
        "end_line": 1909,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "toFirstRecordValues",
        "parameters": [
          "String",
          "CSVFormat"
        ],
        "start_line": 1911,
        "end_line": 1915,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "CSVPrinterTest",
        "method": "tryFormat",
        "parameters": [
          "List",
          "Character",
          "Character",
          "String"
        ],
        "start_line": 1917,
        "end_line": 1924,
        "file": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "PerformanceTest",
        "method": "createReader",
        "parameters": [],
        "start_line": 92,
        "end_line": 94,
        "file": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "PerformanceTest",
        "method": "createTestCSVLexer",
        "parameters": [
          "String",
          "ExtendedBufferedReader"
        ],
        "start_line": 96,
        "end_line": 99,
        "file": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "PerformanceTest",
        "method": "getLexerCtor",
        "parameters": [
          "String"
        ],
        "start_line": 101,
        "end_line": 105,
        "file": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "PerformanceTest",
        "method": "iterate",
        "parameters": [
          "Iterable"
        ],
        "start_line": 107,
        "end_line": 115,
        "file": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "PerformanceTest",
        "method": "main",
        "parameters": [
          "String"
        ],
        "start_line": 117,
        "end_line": 184,
        "file": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "PerformanceTest",
        "method": "readAll",
        "parameters": [
          "BufferedReader",
          "boolean"
        ],
        "start_line": 186,
        "end_line": 195,
        "file": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "PerformanceTest",
        "method": "show",
        "parameters": [],
        "start_line": 198,
        "end_line": 207,
        "file": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "PerformanceTest",
        "method": "testCSVLexer",
        "parameters": [
          "boolean",
          "String"
        ],
        "start_line": 217,
        "end_line": 263,
        "file": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "PerformanceTest",
        "method": "testExtendedBuffer",
        "parameters": [
          "boolean"
        ],
        "start_line": 265,
        "end_line": 301,
        "file": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "PerformanceTest",
        "method": "testParseCommonsCSV",
        "parameters": [],
        "start_line": 303,
        "end_line": 305,
        "file": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "PerformanceTest",
        "method": "testParsePath",
        "parameters": [],
        "start_line": 307,
        "end_line": 309,
        "file": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "PerformanceTest",
        "method": "testParsePathDoubleBuffering",
        "parameters": [],
        "start_line": 311,
        "end_line": 313,
        "file": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "PerformanceTest",
        "method": "testParser",
        "parameters": [
          "String",
          "CSVParserFactory"
        ],
        "start_line": 315,
        "end_line": 326,
        "file": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "PerformanceTest",
        "method": "testParseURL",
        "parameters": [],
        "start_line": 328,
        "end_line": 330,
        "file": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "PerformanceTest",
        "method": "testReadBigFile",
        "parameters": [
          "boolean"
        ],
        "start_line": 332,
        "end_line": 343,
        "file": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "package": "org.apache.commons.csv",
        "is_test_method": false
      },
      {
        "class": "JiraCsv198Test",
        "method": "test",
        "parameters": [],
        "start_line": 45,
        "end_line": 52,
        "file": "src/test/java/org/apache/commons/csv/issues/JiraCsv198Test.java",
        "package": "org.apache.commons.csv.issues",
        "is_test_method": false
      },
      {
        "class": "JiraCsv211Test",
        "method": "testJiraCsv211Format",
        "parameters": [],
        "start_line": 34,
        "end_line": 53,
        "file": "src/test/java/org/apache/commons/csv/issues/JiraCsv211Test.java",
        "package": "org.apache.commons.csv.issues",
        "is_test_method": false
      },
      {
        "class": "JiraCsv288Test",
        "method": "print",
        "parameters": [
          "CSVRecord",
          "CSVPrinter"
        ],
        "start_line": 36,
        "end_line": 40,
        "file": "src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java",
        "package": "org.apache.commons.csv.issues",
        "is_test_method": false
      },
      {
        "class": "JiraCsv288Test",
        "method": "testParseWithABADelimiter",
        "parameters": [],
        "start_line": 45,
        "end_line": 55,
        "file": "src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java",
        "package": "org.apache.commons.csv.issues",
        "is_test_method": false
      },
      {
        "class": "JiraCsv288Test",
        "method": "testParseWithDoublePipeDelimiter",
        "parameters": [],
        "start_line": 60,
        "end_line": 70,
        "file": "src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java",
        "package": "org.apache.commons.csv.issues",
        "is_test_method": false
      },
      {
        "class": "JiraCsv288Test",
        "method": "testParseWithDoublePipeDelimiterDoubleCharValue",
        "parameters": [],
        "start_line": 75,
        "end_line": 85,
        "file": "src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java",
        "package": "org.apache.commons.csv.issues",
        "is_test_method": false
      },
      {
        "class": "JiraCsv288Test",
        "method": "testParseWithDoublePipeDelimiterEndsWithDelimiter",
        "parameters": [],
        "start_line": 90,
        "end_line": 100,
        "file": "src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java",
        "package": "org.apache.commons.csv.issues",
        "is_test_method": false
      },
      {
        "class": "JiraCsv288Test",
        "method": "testParseWithDoublePipeDelimiterQuoted",
        "parameters": [],
        "start_line": 105,
        "end_line": 115,
        "file": "src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java",
        "package": "org.apache.commons.csv.issues",
        "is_test_method": false
      },
      {
        "class": "JiraCsv288Test",
        "method": "testParseWithSinglePipeDelimiterEndsWithDelimiter",
        "parameters": [],
        "start_line": 119,
        "end_line": 129,
        "file": "src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java",
        "package": "org.apache.commons.csv.issues",
        "is_test_method": false
      },
      {
        "class": "JiraCsv288Test",
        "method": "testParseWithTriplePipeDelimiter",
        "parameters": [],
        "start_line": 134,
        "end_line": 144,
        "file": "src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java",
        "package": "org.apache.commons.csv.issues",
        "is_test_method": false
      },
      {
        "class": "JiraCsv288Test",
        "method": "testParseWithTwoCharDelimiter1",
        "parameters": [],
        "start_line": 148,
        "end_line": 158,
        "file": "src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java",
        "package": "org.apache.commons.csv.issues",
        "is_test_method": false
      },
      {
        "class": "JiraCsv288Test",
        "method": "testParseWithTwoCharDelimiter2",
        "parameters": [],
        "start_line": 162,
        "end_line": 172,
        "file": "src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java",
        "package": "org.apache.commons.csv.issues",
        "is_test_method": false
      },
      {
        "class": "JiraCsv288Test",
        "method": "testParseWithTwoCharDelimiter3",
        "parameters": [],
        "start_line": 176,
        "end_line": 186,
        "file": "src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java",
        "package": "org.apache.commons.csv.issues",
        "is_test_method": false
      },
      {
        "class": "JiraCsv288Test",
        "method": "testParseWithTwoCharDelimiter4",
        "parameters": [],
        "start_line": 190,
        "end_line": 200,
        "file": "src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java",
        "package": "org.apache.commons.csv.issues",
        "is_test_method": false
      },
      {
        "class": "JiraCsv288Test",
        "method": "testParseWithTwoCharDelimiterEndsWithDelimiter",
        "parameters": [],
        "start_line": 205,
        "end_line": 215,
        "file": "src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java",
        "package": "org.apache.commons.csv.issues",
        "is_test_method": false
      }
    ],
    "summary": {
      "source_methods_count": 12,
      "test_methods_count": 401
    }
  },
  "diff_info": {
    "full_diff": "diff --git a/.gitattributes b/.gitattributes\nnew file mode 100644\nindex 00000000..bec231c1\n--- /dev/null\n+++ b/.gitattributes\n@@ -0,0 +1,16 @@\n+#   Licensed to the Apache Software Foundation (ASF) under one or more\n+#   contributor license agreements.  See the NOTICE file distributed with\n+#   this work for additional information regarding copyright ownership.\n+#   The ASF licenses this file to You under the Apache License, Version 2.0\n+#   (the \"License\"); you may not use this file except in compliance with\n+#   the License.  You may obtain a copy of the License at\n+#\n+#       http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#   Unless required by applicable law or agreed to in writing, software\n+#   distributed under the License is distributed on an \"AS IS\" BASIS,\n+#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#   See the License for the specific language governing permissions and\n+#   limitations under the License.\n+\n+* text=auto\ndiff --git a/.github/workflows/codeql-analysis.yml b/.github/workflows/codeql-analysis.yml\nindex d6f2c05d..1f42db3b 100644\n--- a/.github/workflows/codeql-analysis.yml\n+++ b/.github/workflows/codeql-analysis.yml\n@@ -1,85 +1,85 @@\n-# Licensed to the Apache Software Foundation (ASF) under one or more\r\n-# contributor license agreements.  See the NOTICE file distributed with\r\n-# this work for additional information regarding copyright ownership.\r\n-# The ASF licenses this file to You under the Apache License, Version 2.0\r\n-# (the \"License\"); you may not use this file except in compliance with\r\n-# the License.  You may obtain a copy of the License at\r\n-#\r\n-#      http://www.apache.org/licenses/LICENSE-2.0\r\n-#\r\n-# Unless required by applicable law or agreed to in writing, software\r\n-# distributed under the License is distributed on an \"AS IS\" BASIS,\r\n-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n-# See the License for the specific language governing permissions and\r\n-# limitations under the License.\r\n-\r\n-name: \"CodeQL\"\r\n-\r\n-on:\r\n-  push:\r\n-    branches: [ master ]\r\n-  pull_request:\r\n-    # The branches below must be a subset of the branches above\r\n-    branches: [ master ]\r\n-  schedule:\r\n-    - cron: '33 9 * * 4'\r\n-\r\n-permissions:\r\n-  contents: read\r\n-\r\n-jobs:\r\n-  analyze:\r\n-    name: Analyze\r\n-    runs-on: ubuntu-latest\r\n-    permissions:\r\n-      actions: read\r\n-      contents: read\r\n-      security-events: write\r\n-\r\n-    strategy:\r\n-      fail-fast: false\r\n-      matrix:\r\n-        language: [ 'java' ]\r\n-        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\r\n-        # Learn more about CodeQL language support at https://git.io/codeql-language-support\r\n-\r\n-    steps:\r\n-    - name: Checkout repository\r\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+name: \"CodeQL\"\n+\n+on:\n+  push:\n+    branches: [ master ]\n+  pull_request:\n+    # The branches below must be a subset of the branches above\n+    branches: [ master ]\n+  schedule:\n+    - cron: '33 9 * * 4'\n+\n+permissions:\n+  contents: read\n+\n+jobs:\n+  analyze:\n+    name: Analyze\n+    runs-on: ubuntu-latest\n+    permissions:\n+      actions: read\n+      contents: read\n+      security-events: write\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        language: [ 'java' ]\n+        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n+        # Learn more about CodeQL language support at https://git.io/codeql-language-support\n+\n+    steps:\n+    - name: Checkout repository\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # 4.2.2\n-      with:\r\n-        persist-credentials: false\r\n+      with:\n+        persist-credentials: false\n     - uses: actions/cache@1bd1e32a3bdc45362d1e726936510720a7c30a57 # v4.2.0\n-      with:\r\n-        path: ~/.m2/repository\r\n-        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}\r\n-        restore-keys: |\r\n-          ${{ runner.os }}-maven-\r\n-\r\n-    # Initializes the CodeQL tools for scanning.\r\n-    - name: Initialize CodeQL\r\n+      with:\n+        path: ~/.m2/repository\n+        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}\n+        restore-keys: |\n+          ${{ runner.os }}-maven-\n+\n+    # Initializes the CodeQL tools for scanning.\n+    - name: Initialize CodeQL\n       uses: github/codeql-action/init@b6a472f63d85b9c78a3ac5e89422239fc15e9b3c    # 3.28.1\n-      with:\r\n-        languages: ${{ matrix.language }}\r\n-        # If you wish to specify custom queries, you can do so here or in a config file.\r\n-        # By default, queries listed here will override any specified in a config file.\r\n-        # Prefix the list here with \"+\" to use these queries and those in the config file.\r\n-        # queries: ./path/to/local/query, your-org/your-repo/queries@main\r\n-\r\n-    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\r\n-    # If this step fails, then you should remove it and run the build manually (see below)\r\n-    - name: Autobuild\r\n+      with:\n+        languages: ${{ matrix.language }}\n+        # If you wish to specify custom queries, you can do so here or in a config file.\n+        # By default, queries listed here will override any specified in a config file.\n+        # Prefix the list here with \"+\" to use these queries and those in the config file.\n+        # queries: ./path/to/local/query, your-org/your-repo/queries@main\n+\n+    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n+    # If this step fails, then you should remove it and run the build manually (see below)\n+    - name: Autobuild\n       uses: github/codeql-action/autobuild@b6a472f63d85b9c78a3ac5e89422239fc15e9b3c    # 3.28.1\n-\r\n-    #  Command-line programs to run using the OS shell.\r\n-    #  https://git.io/JvXDl\r\n-\r\n-    #  If the Autobuild fails above, remove it and uncomment the following three lines\r\n-    #    and modify them (or add more) to build your code if your project\r\n-    #    uses a compiled language\r\n-\r\n-    #- run: |\r\n-    #   make bootstrap\r\n-    #   make release\r\n-\r\n-    - name: Perform CodeQL Analysis\r\n+\n+    #  Command-line programs to run using the OS shell.\n+    #  https://git.io/JvXDl\n+\n+    #  If the Autobuild fails above, remove it and uncomment the following three lines\n+    #    and modify them (or add more) to build your code if your project\n+    #    uses a compiled language\n+\n+    #- run: |\n+    #   make bootstrap\n+    #   make release\n+\n+    - name: Perform CodeQL Analysis\n       uses: github/codeql-action/analyze@b6a472f63d85b9c78a3ac5e89422239fc15e9b3c    # 3.28.1\ndiff --git a/.github/workflows/maven.yml b/.github/workflows/maven.yml\nindex 9aec002d..71887b86 100644\n--- a/.github/workflows/maven.yml\n+++ b/.github/workflows/maven.yml\n@@ -1,52 +1,52 @@\n-# Licensed to the Apache Software Foundation (ASF) under one or more\r\n-# contributor license agreements.  See the NOTICE file distributed with\r\n-# this work for additional information regarding copyright ownership.\r\n-# The ASF licenses this file to You under the Apache License, Version 2.0\r\n-# (the \"License\"); you may not use this file except in compliance with\r\n-# the License.  You may obtain a copy of the License at\r\n-#\r\n-#      http://www.apache.org/licenses/LICENSE-2.0\r\n-#\r\n-# Unless required by applicable law or agreed to in writing, software\r\n-# distributed under the License is distributed on an \"AS IS\" BASIS,\r\n-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n-# See the License for the specific language governing permissions and\r\n-# limitations under the License.\r\n-\r\n-name: Java CI\r\n-\r\n-on: [push, pull_request]\r\n-\r\n-permissions:\r\n-  contents: read\r\n-\r\n-jobs:\r\n-  build:\r\n-\r\n-    runs-on: ubuntu-latest\r\n-    continue-on-error: ${{ matrix.experimental }}\r\n-    strategy:\r\n-      matrix:\r\n-        java: [ 8, 11, 17, 21, 23 ]\r\n-        experimental: [false]\r\n-        include:\r\n-            - java: 24-ea\r\n-              experimental: true\r\n-        \r\n-    steps:\r\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+name: Java CI\n+\n+on: [push, pull_request]\n+\n+permissions:\n+  contents: read\n+\n+jobs:\n+  build:\n+\n+    runs-on: ubuntu-latest\n+    continue-on-error: ${{ matrix.experimental }}\n+    strategy:\n+      matrix:\n+        java: [ 8, 11, 17, 21, 23 ]\n+        experimental: [false]\n+        include:\n+            - java: 24-ea\n+              experimental: true\n+        \n+    steps:\n     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # 4.2.2\n-      with:\r\n-        persist-credentials: false\r\n+      with:\n+        persist-credentials: false\n     - uses: actions/cache@1bd1e32a3bdc45362d1e726936510720a7c30a57 # v4.2.0\n-      with:\r\n-        path: ~/.m2/repository\r\n-        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}\r\n-        restore-keys: |\r\n-          ${{ runner.os }}-maven-\r\n-    - name: Set up JDK ${{ matrix.java }}\r\n+      with:\n+        path: ~/.m2/repository\n+        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}\n+        restore-keys: |\n+          ${{ runner.os }}-maven-\n+    - name: Set up JDK ${{ matrix.java }}\n       uses: actions/setup-java@7a6d8a8234af8eb26422e24e3006232cccaa061b # v4.6.0\n-      with:\r\n-        distribution: 'temurin'\r\n-        java-version: ${{ matrix.java }}\r\n-    - name: Build with Maven\r\n-      run: mvn -Ddoclint=all --show-version --batch-mode --no-transfer-progress\r\n+      with:\n+        distribution: 'temurin'\n+        java-version: ${{ matrix.java }}\n+    - name: Build with Maven\n+      run: mvn -Ddoclint=all --show-version --batch-mode --no-transfer-progress\ndiff --git a/src/assembly/bin.xml b/src/assembly/bin.xml\nindex 82301463..f73d62f6 100644\n--- a/src/assembly/bin.xml\n+++ b/src/assembly/bin.xml\n@@ -1,56 +1,56 @@\n-<!--\r\n-Licensed to the Apache Software Foundation (ASF) under one or more\r\n- contributor license agreements.  See the NOTICE file distributed with\r\n- this work for additional information regarding copyright ownership.\r\n- The ASF licenses this file to You under the Apache License, Version 2.0\r\n- (the \"License\"); you may not use this file except in compliance with\r\n- the License.  You may obtain a copy of the License at\r\n-\r\n-      http://www.apache.org/licenses/LICENSE-2.0\r\n-\r\n- Unless required by applicable law or agreed to in writing, software\r\n- distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- See the License for the specific language governing permissions and\r\n- limitations under the License.\r\n--->\r\n+<!--\n+Licensed to the Apache Software Foundation (ASF) under one or more\n+ contributor license agreements.  See the NOTICE file distributed with\n+ this work for additional information regarding copyright ownership.\n+ The ASF licenses this file to You under the Apache License, Version 2.0\n+ (the \"License\"); you may not use this file except in compliance with\n+ the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+-->\n <assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.2.0\"\n     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-    xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.2.0 https://maven.apache.org/xsd/assembly-2.2.0.xsd\">\r\n-    <id>bin</id>\r\n-    <formats>\r\n-        <format>tar.gz</format>\r\n-        <format>zip</format>\r\n-    </formats>\r\n-    <fileSets>\r\n-        <fileSet>\r\n-            <includes>\r\n-                <include>LICENSE.txt</include>\r\n-                <include>NOTICE.txt</include>\r\n-                <include>RELEASE-NOTES.txt</include>\r\n-            </includes>\r\n-        </fileSet>\r\n-        <fileSet>\r\n-            <directory>target</directory>\r\n-            <outputDirectory></outputDirectory>\r\n-            <includes>\r\n-                <include>${artifactId}-${version}.jar</include>\r\n-            </includes>\r\n-        </fileSet>\r\n-        <fileSet>\r\n-            <directory>target/site/apidocs</directory>\r\n-            <outputDirectory>apidocs</outputDirectory>\r\n-            <includes>\r\n-                <include>**/*</include>\r\n-            </includes>\r\n-        </fileSet>\r\n-        <!-- Include sources jar for IDEs -->\r\n-        <fileSet>\r\n-            <directory>target</directory>\r\n-            <outputDirectory></outputDirectory>\r\n-            <includes>\r\n-                <include>${artifactId}-${version}-sources.jar</include>\r\n-            </includes>\r\n-        </fileSet>\r\n-    </fileSets>\r\n-</assembly>\r\n+    xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.2.0 https://maven.apache.org/xsd/assembly-2.2.0.xsd\">\n+    <id>bin</id>\n+    <formats>\n+        <format>tar.gz</format>\n+        <format>zip</format>\n+    </formats>\n+    <fileSets>\n+        <fileSet>\n+            <includes>\n+                <include>LICENSE.txt</include>\n+                <include>NOTICE.txt</include>\n+                <include>RELEASE-NOTES.txt</include>\n+            </includes>\n+        </fileSet>\n+        <fileSet>\n+            <directory>target</directory>\n+            <outputDirectory></outputDirectory>\n+            <includes>\n+                <include>${artifactId}-${version}.jar</include>\n+            </includes>\n+        </fileSet>\n+        <fileSet>\n+            <directory>target/site/apidocs</directory>\n+            <outputDirectory>apidocs</outputDirectory>\n+            <includes>\n+                <include>**/*</include>\n+            </includes>\n+        </fileSet>\n+        <!-- Include sources jar for IDEs -->\n+        <fileSet>\n+            <directory>target</directory>\n+            <outputDirectory></outputDirectory>\n+            <includes>\n+                <include>${artifactId}-${version}-sources.jar</include>\n+            </includes>\n+        </fileSet>\n+    </fileSets>\n+</assembly>\ndiff --git a/src/assembly/src.xml b/src/assembly/src.xml\nindex 81955342..9f33f58f 100644\n--- a/src/assembly/src.xml\n+++ b/src/assembly/src.xml\n@@ -1,45 +1,45 @@\n-<!--\r\n-Licensed to the Apache Software Foundation (ASF) under one or more\r\n- contributor license agreements.  See the NOTICE file distributed with\r\n- this work for additional information regarding copyright ownership.\r\n- The ASF licenses this file to You under the Apache License, Version 2.0\r\n- (the \"License\"); you may not use this file except in compliance with\r\n- the License.  You may obtain a copy of the License at\r\n-\r\n-      http://www.apache.org/licenses/LICENSE-2.0\r\n-\r\n- Unless required by applicable law or agreed to in writing, software\r\n- distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- See the License for the specific language governing permissions and\r\n- limitations under the License.\r\n--->\r\n+<!--\n+Licensed to the Apache Software Foundation (ASF) under one or more\n+ contributor license agreements.  See the NOTICE file distributed with\n+ this work for additional information regarding copyright ownership.\n+ The ASF licenses this file to You under the Apache License, Version 2.0\n+ (the \"License\"); you may not use this file except in compliance with\n+ the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+-->\n <assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.2.0\"\n     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-    xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.2.0 https://maven.apache.org/xsd/assembly-2.2.0.xsd\">\r\n-  <id>src</id>\r\n-  <formats>\r\n-    <format>tar.gz</format>\r\n-    <format>zip</format>\r\n-  </formats>\r\n-  <baseDirectory>${artifactId}-${version}-src</baseDirectory>\r\n-  <fileSets>\r\n-    <fileSet>\r\n-      <includes>\r\n-        <include>LICENSE*</include>\r\n-        <include>NOTICE*</include>\r\n-        <include>RELEASE-NOTES.txt</include>\r\n-        <include>pom.xml</include>\r\n-        <include>findbugs-exclude-filter.xml</include>\r\n-        <include>checkstyle*.xml</include>\r\n-      </includes>\r\n-    </fileSet>\r\n-    <fileSet>\r\n-      <directory>src</directory>\r\n-      <excludes>\r\n-        <exclude>**/*Benchmark.java</exclude>\r\n-      </excludes>\r\n-    </fileSet>\r\n-  </fileSets>\r\n-</assembly>\r\n-\r\n+    xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.2.0 https://maven.apache.org/xsd/assembly-2.2.0.xsd\">\n+  <id>src</id>\n+  <formats>\n+    <format>tar.gz</format>\n+    <format>zip</format>\n+  </formats>\n+  <baseDirectory>${artifactId}-${version}-src</baseDirectory>\n+  <fileSets>\n+    <fileSet>\n+      <includes>\n+        <include>LICENSE*</include>\n+        <include>NOTICE*</include>\n+        <include>RELEASE-NOTES.txt</include>\n+        <include>pom.xml</include>\n+        <include>findbugs-exclude-filter.xml</include>\n+        <include>checkstyle*.xml</include>\n+      </includes>\n+    </fileSet>\n+    <fileSet>\n+      <directory>src</directory>\n+      <excludes>\n+        <exclude>**/*Benchmark.java</exclude>\n+      </excludes>\n+    </fileSet>\n+  </fileSets>\n+</assembly>\n+\ndiff --git a/src/changes/changes.xml b/src/changes/changes.xml\nindex b5359533..a05e5d52 100644\n--- a/src/changes/changes.xml\n+++ b/src/changes/changes.xml\n@@ -1,386 +1,386 @@\n-<?xml version=\"1.0\"?>\r\n-<!--\r\n-  Licensed to the Apache Software Foundation (ASF) under one or more\r\n-  contributor license agreements. See the NOTICE file distributed with\r\n-  this work for additional information regarding copyright ownership.\r\n-  The ASF licenses this file to You under the Apache License, Version 2.0\r\n-  (the \"License\"); you may not use this file except in compliance with\r\n-  the License. You may obtain a copy of the License at\r\n-\r\n-  http://www.apache.org/licenses/LICENSE-2.0\r\n-\r\n-  Unless required by applicable law or agreed to in writing, software\r\n-  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n-  See the License for the specific language governing permissions and\r\n-  limitations under the License.\r\n--->\r\n-\r\n-<!--\r\n-  This file is used by the maven-changes-plugin to generate the release notes.\r\n-  Useful ways of finding items to add to this file are:\r\n-\r\n-  1. Add items when you fix a bug or add a feature (this makes the\r\n-  release process easy :-).\r\n-\r\n-  2. Do a JIRA search for tickets closed since the previous release.\r\n-\r\n-  3. Use the report generated by the maven-changelog-plugin to see all\r\n-  SVN commits. Set the project.properties' maven.changelog.range\r\n-  property to the number of days since the last release.\r\n-\r\n-\r\n-  The <action> type attribute can be add,update,fix,remove.\r\n--->\r\n-\r\n-<document xmlns=\"http://maven.apache.org/changes/2.0.0\"\r\n-    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \r\n-    xsi:schemaLocation=\"http://maven.apache.org/changes/2.0.0 https://maven.apache.org/xsd/changes-2.0.0.xsd\">\r\n-  <properties>\r\n-    <title>Apache Commons CSV Release Notes</title>\r\n-  </properties>\r\n-  <body>\r\n-    <release version=\"1.13.1\" date=\"YYYY-MM-DD\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\r\n-      <!-- FIX -->\r\n-      <action type=\"fix\" issue=\"CSV-317\" dev=\"ggregory\" due-to=\"Filipe Roque\">Release history link changed from changes-report.html to changes.html #516.</action>\r\n-      <!-- ADD -->\r\n-      <!-- UPDATE -->\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump com.opencsv:opencsv from 5.9 to 5.10.</action>\r\n-    </release>\r\n-    <release version=\"1.13.0\" date=\"2025-01-08\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\r\n-      <!-- FIX -->\r\n-      <action type=\"fix\" issue=\"CSV-314\" dev=\"ggregory\" due-to=\"Gary Gregory\">Required OSGi Import-Package version numbers in MANIFEST.MF #504.</action>\r\n-      <action type=\"fix\" issue=\"CSV-314\" dev=\"ggregory\" due-to=\"Gary Gregory\">CSVParser.nextRecord() should throw CSVException (an IOException subclass) instead of IOException and IllegalStateException, no method signature changes needed.</action>\r\n-      <!-- ADD -->\r\n-      <action type=\"add\" issue=\"CSV-313\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add CSVPrinter.getRecordCount().</action>\r\n-      <action type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add and use CSVParser.Builder and builder() and deprecate CSVParser constructors.</action>\r\n-      <action type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">CSVFormat.Builder implements Supplier&lt;CSVFormat&gt;.</action>\r\n-      <action type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Deprecate CSVFormat.Builder.build() for get().</action>\r\n-      <action type=\"add\" issue=\"CSV-196\" dev=\"ggregory\" due-to=\"Yuzhan Jiang, Gary Gregory\">Track byte position #502.</action>\r\n-      <!-- UPDATE -->\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump org.apache.commons:commons-parent from 76 to 78 #486, #495.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump org.codehaus.mojo:taglist-maven-plugin from 3.1.0 to 3.2.1 #493.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump commons-io:commons-io from 2.17.0 to 2.18.0 #505.</action> \r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump commons-codec:commons-codec from 1.17.1 to 1.17.2.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.apache.commons:commons-parent from 78 to 79.</action>\r\n-    </release>\r\n-    <release version=\"1.12.0\" date=\"2024-09-21\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\r\n-      <!-- ADD -->\r\n-      <action type=\"add\" issue=\"CSV-270\" dev=\"ggregory\" due-to=\"Thomas Kamps, Gary Gregory\">Add CSVException that extends IOException thrown on invalid input instead of IOException.</action>\r\n-      <!-- FIX -->\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Fix PMD issues for port to PMD 7.1.0.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Dvid Szigecsn, Gary Gregory\">Fix some Javadoc links #442.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Dvid Szigecsn\">Extract duplicated code into a method #444.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Dvid Szigecsn\">Migrate CSVFormat#print(File, Charset) to NIO #445.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Dvid Szigecsn\">Fix documentation for CSVFormat private constructor #466.</action>\r\n-      <action type=\"fix\" issue=\"CSV-294\" dev=\"ggregory\" due-to=\"Joern Huxhorn, Gary Gregory\">CSVFormat does not support explicit \" as escape char.</action>\r\n-      <action type=\"fix\" issue=\"CSV-150\" dev=\"ggregory\" due-to=\"dota17, Gary Gregory, Jrn Huxhorn\">Escaping is not disableable.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Fix Javadoc warnings on Java 23.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Improve parser performance by up to 20%, YMMV.</action>\r\n-      <!-- UPDATE -->\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump commons-codec:commons-codec from 1.16.1 to 1.17.1 #422, #449.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.apache.commons:commons-parent from 69 to 76 #435, #452, #465, #468, #475, #482.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.codehaus.mojo:taglist-maven-plugin from 3.0.0 to 3.1.0 #441.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.apache.commons:commons-lang3 from 3.14.0 to 3.17.0 #450, #459, #470.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.hamcrest:hamcrest from 2.2 to 3.0 #455.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump commons-io:commons-io from 2.16.1 to 2.17.0 #476.</action>\r\n-    </release>\r\n-    <release version=\"1.11.0\" date=\"2024-04-28\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\r\n-      <!-- ADD -->\r\n-      <action issue=\"CSV-308\" type=\"add\" dev=\"ggregory\" due-to=\"Buddhi De Silva, Gary Gregory\">[Javadoc] Add example to CSVFormat#setHeaderComments() #344.</action>\r\n-      <action type=\"add\" dev=\"ggregory\" due-to=\"DamjanJovanovic, Gary Gregory\">Add and use CSVFormat#setTrailingData(boolean) in CSVFormat.EXCEL for Excel compatibility #303.</action>\r\n-      <action type=\"add\" dev=\"ggregory\" due-to=\"DamjanJovanovic, Gary Gregory\">Add and use CSVFormat#setLenientEof(boolean) in CSVFormat.EXCEL for Excel compatibility #303.</action>\r\n-      <!-- FIX -->\r\n-      <action type=\"fix\" issue=\"CSV-306\" dev=\"ggregory\" due-to=\"Sam Ng, Bruno P. Kinoshita\">Replace deprecated method in user guide, update external link #324, #325.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Seth Falco, Bruno P. Kinoshita\">Document duplicate header behavior #309.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"jkbkupczyk\">Add missing docs #328.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"step-security-bot\">[StepSecurity] CI: Harden GitHub Actions #329, #330.</action>\r\n-      <action type=\"fix\" issue=\"CSV-147\" dev=\"ggregory\" due-to=\"Steven Peterson, Benedikt Ritter, Gary Gregory, Joerg Schaible, Buddhi De Silva, Elliotte Rusty Harold\">Better error message during faulty CSV record read #347.</action>\r\n-      <action type=\"fix\" issue=\"CSV-310\" dev=\"ggregory\" due-to=\"Buddhi De Silva\">Misleading error message when QuoteMode set to None #352.</action>\r\n-      <action type=\"fix\" issue=\"CSV-311\" dev=\"ggregory\" due-to=\"Christian Feuersaenger, Gary Gregory\">OutOfMemory for very long rows despite using column value of type Reader.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Use try-with-resources to manage JDBC CLOB in CSVPrinter.printRecords(ResultSet).</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">JDBC Blob columns are now output as Base64 instead of Object#toString(), which usually is InputStream#toString().</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"DamjanJovanovic, Gary Gregory\">Support unusual Excel use cases: Add support for trailing data after the closing quote, and EOF without a final closing quote #303.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Igor Kamyshnikov, Gary Gregory\">MongoDB CSV empty first column parsing fix #412.</action>\r\n-      <!-- UPDATE -->\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump commons-io:commons-io: from 2.11.0 to 2.16.1 #408, #413.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump commons-parent from 57 to 69 #410.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump h2 from 2.1.214 to 2.2.224 #333, #349, #359.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump commons-lang3 from 3.12.0 to 3.14.0.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Buddhi De Silva, Michael Osipov, Gary Gregory\">Update exception message in CSVRecord#getNextRecord() #348.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump tests using com.opencsv:opencsv from 5.8 to 5.9 #373.</action>\r\n-    </release>\r\n-    <release version=\"1.10.0\" date=\"2023-01-28\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\r\n-      <!-- FIX -->\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Minor changes #172.</action>\r\n-      <action issue=\"CSV-292\" type=\"fix\" dev=\"kinow\" due-to=\"Rob Vesse\">No Automatic-Module-Name prevents usage in JPMS projects without repacking the JAR.</action>\r\n-      <action issue=\"CSV-288\" type=\"fix\" dev=\"ggregory\" due-to=\"Santhsoh, Angus\">Fix for multi-char delimiter not working as expected #218.</action>\r\n-      <action issue=\"CSV-269\" type=\"fix\" dev=\"ggregory\" due-to=\"Auke te Winkel, Gary Gregory\">CSVRecord.get(Enum) should use Enum.name() instead of Enum.toString().</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Allow org.apache.commons.csv.IOUtils.copy(Reader, Appendable, CharBuffer) to compile on Java 11 and run on Java 8.</action>\r\n-      <action issue=\"CSV-300\" type=\"fix\" dev=\"ggregory\" due-to=\"Markus Spann, Gary Gregory\">CSVRecord.toList() does not give write access to the new List.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">CSVParser.getRecords() now throws UncheckedIOException instead of IOException.</action>\r\n-      <action issue=\"CSV-274\" type=\"fix\" dev=\"ggregory\" due-to=\"Peter Hull, Bruno P. Kinoshita, Gary Gregory\">Add comments to iterator() and stream() #270.</action>\r\n-      <action issue=\"CSV-290\" type=\"fix\" dev=\"ggregory\" due-to=\"angusdev, Gary Gregory\">Fix wrong assumptions in PostgreSQL formats #265.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Mykola Faryma\">Validate input to setDelimiter(String) for empty string #266.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Dependabot\">Bump CSVFormat#serialVersionUID from 1 to 2.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert\">CSVParser: Identify duplicates in null, empty and blank header names #279.</action>\r\n-      <!-- REMOVE -->\r\n-      <action                 type=\"remove\" dev=\"ggregory\">Serialization in CSVFormat is not supported from one version to the next.</action>\r\n-      <!-- ADD -->\r\n-      <action issue=\"CSV-291\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Make CSVRecord#values() public.</action>\r\n-      <action issue=\"CSV-264\" type=\"add\" dev=\"ggregory\" due-to=\"Sagar Tiwari, Seth Falco, Alex Herbert, Gary Gregory\">Add DuplicateHeaderMode for flexibility with header strictness. #114.</action>\r\n-      <action issue=\"CSV-295\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Support for parallelism in CSVPrinter.</action>\r\n-      <action issue=\"CSV-295\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add CSVPrinter.printRecord[s](Stream).</action>\r\n-      <action issue=\"CSV-304\" type=\"add\" dev=\"ggregory\" due-to=\"Peter Hull, Bruno P. Kinoshita, Gary Gregory\">Add accessors for header/trailer comments #257.</action>\r\n-      <action type=\"add\" dev=\"ggregory\">Add github/codeql-action.</action>\r\n-      <!-- UPDATE -->\r\n-      <action                 type=\"update\" dev=\"kinow\" due-to=\"Dependabot, Gary Gregory\">Bump actions/cache from 2.1.6 to 3.0.10 #196, #233, #243, #267, #271.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump actions/checkout from 2.3.4 to 3.1.0 #188, #195, #220, #272.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump actions/setup-java from 2 to 3.5.1.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump actions/upload-artifact from 3.1.0 to 3.1.1 #280.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump commons-parent from 52 to 57 #264, #288, #298, #323.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump checkstyle from 8.44 to 9.2.1 #180, #190, #194, #202, #207.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump junit-jupiter from 5.8.0-M1 to 5.9.1 #179, #186, #201, #244, #263.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump jmh-core from 1.32 to 1.36 #176, #208, #229, #285.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump jmh-generator-annprocess from 1.32 to 1.36 #175, #206, #226, #283.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump mockito-core from 3.11.2 to 4.11.0 #187, #197, #204, #212, #230, #237, #251, #259, #284, #292, #297.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump maven-pmd-plugin from 3.14.0 to 3.19.0 #184, #219, #238, #254, #258.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump pmd from 6.36.0 to 6.52.0 #173, #189, #193, #199, #227, #233, #214, #236, #240, #247, #255, #273.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump opencsv from 5.5.1 to 5.7.1 #182, #221, #260, #281.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump spotbugs-maven-plugin from 4.3.0 to 4.7.3.0 #192, #198, #203, #211, #225, #234, #242, #245, #261, #275, #282.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump com.github.spotbugs:spotbugs from 4.5.3 to 4.7.2.</action>\r\n-      <action                 type=\"update\" dev=\"kinow\" due-to=\"Dependabot\">Bump h2 from 1.4.200 to 2.1.214 #200, #205, #213, #239.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump maven-javadoc-plugin from 3.3.0 to 3.4.1.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump biz.aQute.bnd:biz.aQute.bndlib from 5.3.0 to 6.3.1.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump jacoco-maven-plugin from 0.8.7 to 0.8.8.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump japicmp-maven-plugin from 0.15.3 to 0.16.0.</action>\r\n-      <action                 type=\"update\" dev=\"kinow\" due-to=\"Dependabot\">Bump maven-checkstyle-plugin from 3.1.2 to 3.2.0 #253.</action>\r\n-    </release>\r\n-    <release version=\"1.9.0\" date=\"2021-07-24\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\r\n-      <!-- FIX -->\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Amey Jadiye\">Replace FindBugs with SpotBugs #56.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Javadoc typo in CSVFormat let's -> lets #57.</action>\r\n-      <action issue=\"CSV-259\" type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">CSVFormat.printWithEscapes throws StringIndexOutOfBoundsException when value is Reader #61.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Improve CSVFormat test coverage #63.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Fix CSVFileParserTest.java to allow for a null return value from record.getComment() #62.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Improve test coverage in CSVFormatTest #65.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Removed invalid Javadoc markup for CSVFormat EXCEL #64.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Improve CSVRecord and CSVPrinter code coverage #66.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Improve lexer and token coverage #67.</action>\r\n-      <action issue=\"CSV-211\" type=\"fix\" dev=\"ggregory\" due-to=\"Alpesh Kulkarni, Chen\">CSVFormat.format trims last delimiter if the delimiter is a white space #71.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Replace org.apache.commons.csv.Assertions.notNull() with Objects.requireNonNull().</action>\r\n-      <action issue=\"CSV-149\" type=\"fix\" dev=\"ggregory\" due-to=\"Kranthi, Gary Gregory, Brent Worden, dota17\">Line number is not proper at EOF.</action>\r\n-      <action issue=\"CSV-195\" type=\"fix\" dev=\"ggregory\" due-to=\"Rodolfo Duldulao, Rodolfo Duldulao, Michael Vitz, dota17\">Parser iterates over the last CSV Record twice.</action>\r\n-      <action issue=\"CSV-267\" type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Minor improvements #126, #127, #130.</action>\r\n-      <action issue=\"CSV-123\" type=\"fix\" dev=\"ggregory\" due-to=\"Emmanuel Bourg, Benedikt Ritter, shivakrishnaah, Gary Gregory\">Add possibility to use ResultSet header meta data as CSV header #11.</action>\r\n-      <action issue=\"CSV-148\" type=\"fix\" dev=\"ggregory\" due-to=\"dota17\">Add test cases for withIgnoreSurroundingSpaces() and withTrim() #70.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update CSVParser.parse(File, Charset, CSVFormat) from IO to NIO.</action>\r\n-      <action issue=\"CSV-271\" type=\"fix\" dev=\"ggregory\" due-to=\"Amar Prakash Pandey\">Missing separator with print(object) followed by printRecord(Object[]) #157.</action>\r\n-      <action issue=\"CSV-158\" type=\"fix\" dev=\"ggregory\" due-to=\"Alexander Bondarev, Benedikt Ritter, Gary Gregory, Chen\">Fix EOL checking for read array in ExtendedBufferedReader #5.</action>\r\n-      <action issue=\"CSV-263\" type=\"fix\" dev=\"ggregory\" due-to=\"Jason A. Guild, Gary Gregory\">Print from Reader with embedded quotes generates incorrect output #78.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Replace JUnit assert by simpler but equivalent calls. #159.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Seth Falco\">Update gitignore to ignore idea and vscode #160.</action>\r\n-      <action issue=\"CSV-281\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Update CSVBenchmark #165.</action>\r\n-      <action issue=\"CSV-283\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Remove Whitespace Check Determines Delimiter Twice #167.</action>\r\n-      <action issue=\"CSV-283\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Document and Automate CSV Benchmark Harness #166.</action>\r\n-      <action issue=\"CSV-279\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Optimize Lexer Delimiter Check for One Character Delimiter #163.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: org.apache.commons.csv.CSVParser.getHeaderNames() may expose internal representation by returning CSVParser.headerNames [org.apache.commons.csv.CSVParser] At CSVParser.java:[line 599] EI_EXPOSE_REP.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: new org.apache.commons.csv.CSVParser(Reader, CSVFormat, long, long) may expose internal representation by storing an externally mutable object into CSVParser.format [org.apache.commons.csv.CSVParser] At CSVParser.java:[line 433] EI_EXPOSE_REP2.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: new org.apache.commons.csv.CSVParser(Reader, CSVFormat, long, long) may expose internal representation by storing an externally mutable object into CSVParser.headerMap [org.apache.commons.csv.CSVParser] At CSVParser.java:[line 437] EI_EXPOSE_REP2.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: new org.apache.commons.csv.CSVParser(Reader, CSVFormat, long, long) may expose internal representation by storing an externally mutable object into CSVParser.headerNames [org.apache.commons.csv.CSVParser] At CSVParser.java:[line 438] EI_EXPOSE_REP2.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: new org.apache.commons.csv.CSVPrinter(Appendable, CSVFormat) may expose internal representation by storing an externally mutable object into CSVPrinter.format [org.apache.commons.csv.CSVPrinter] At CSVPrinter.java:[line 100] EI_EXPOSE_REP2.</action>\r\n-      <action issue=\"CSV-284\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Formalize PerformanceTest #168.</action>\r\n-      <action issue=\"CSV-278\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Reuse Buffers in Lexer for Delimiter Detection #162.</action>\r\n-      <action issue=\"CSV-286\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Cleanup and Document Performance Test Harness #170.</action>\r\n-      <action issue=\"CSV-265\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Update buffer position when reading line comment #120.</action>\r\n-      <!-- ADD -->\r\n-      <action issue=\"CSV-275\" type=\"add\" dev=\"ggregory\" due-to=\"Michael Wyraz, Gary Gregory\">Make CSVRecord#toList() public.</action>\r\n-      <action                 type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add CSVRecord#stream().</action>\r\n-      <action                 type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add CSVParser#stream().</action>\r\n-      <action issue=\"CSV-184\" type=\"add\" dev=\"ggregory\" due-to=\"Gaurav Agarwal, M. Steiger, Gary Gregory\">Make the method CSVRecord.putIn(Map) public.</action>\r\n-      <action                 type=\"add\" dev=\"ggregory\" due-to=\"dota17\">Add test cases for CSVRecord with get(Enum) and toString. #54.</action>\r\n-      <action                 type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, dota17\">Add and use CSVFormat.Builder, deprecated CSVFormat#with methods, based on #73.</action>\r\n-      <action issue=\"CSV-206\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, dota17\">Add support for String delimiters #76.</action>\r\n-      <!-- UPDATE -->\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update org.junit.jupiter:junit-jupiter from 5.6.0 to 5.7.0, #84 #109</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from Apache Commons Lang 3.9 to 3.12.0.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from commons-io:commons-io 2.6 to 2.11.0, #108.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump actions/checkout from v1 to v2.3.4, #79, #92, #121.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump commons-parent from 50 to 51 #80.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump tests from opencsv from 3.1 to 5.5.1 #81, #137, #158.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from super-csv from 2.2.1 to 2.4.0 #86.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump build actions/setup-java from v1.4.0 to v2, #101, #113.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump maven-pmd-plugin from 3.13.0 to 3.14.0 #122.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump tests from org.mockito:mockito-core 3.2.4 -> 3.11.2; #88, #107, #110, #123, #128, #129, #156.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump actions/cache from v2 to v2.1.6 #132, #153.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump maven-checkstyle-plugin from 3.0.0 to 3.1.2 #131.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump checkstyle from 8.29 to 8.44.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump junit-jupiter from 5.7.0 to 5.8.0-M1 #133, #149.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump commons.jacoco.version from 0.8.5 to 0.8.7 (Java 16).</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump commons.spotbugs.version from 4.0.4 to 4.3.0 (Java 16).</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump maven-javadoc-plugin from 3.2.0 to 3.3.0.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump jmh-generator-annprocess from 1.5.2 to 1.32 #151.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump PMD core from 6.29.0 to 6.36.0.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump biz.aQute.bnd:biz.aQute.bndlib from 5.1.2 to 5.3.0.</action>\r\n-    </release>\r\n-    <release version=\"1.8\" date=\"2020-02-01\" description=\"This is a feature and maintenance release. Java 8 or later is required.\r\n-\r\n-This release fixes serialization compatibility of CSVRecord with versions 1.0 to 1.6.\r\n-New fields added since 1.7 are not serialized. Support for Serializable is scheduled to be\r\n-removed in version 2.0.\r\n-\">\r\n-      <action issue=\"CSV-255\" type=\"add\" dev=\"ggregory\" due-to=\"0x100\">Add CSVRecord.isSet(int) method #52.</action>\r\n-      <action issue=\"CSV-135\" type=\"fix\" dev=\"sebb\" due-to=\"Mateusz Zakarczemny\">Char escape doesn't work properly with quoting.</action>\r\n-      <action issue=\"CSV-244\" type=\"fix\" dev=\"sebb\">Test case failures following CSVFormat#equals() update.</action>\r\n-      <action issue=\"CSV-243\" type=\"fix\" dev=\"sebb\">CSVFormat withTrim() and withIgnoreSurroundingSpaces() need better docs.</action>\r\n-      <action issue=\"CSV-242\" type=\"fix\" dev=\"sebb\">CSVFormat equals() and hashCode() don't use all fields.</action>\r\n-      <action issue=\"CSV-241\" type=\"fix\" dev=\"ggregory\" due-to=\"LuckyIlam, Gary Gregory\">CSVFormat#validate() does not account for allowDuplicateHeaderNames #43.</action>\r\n-      <action issue=\"CSV-245\" type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert\">Post 1.7 release fixes.</action>\r\n-      <action issue=\"CSV-252\" type=\"fix\" dev=\"ggregory\" due-to= \"Alex Herbert\">Upgrade test framework to JUnit 5 Jupiter #49, #50.</action>\r\n-      <action issue=\"CSV-247\" type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert, Gary Gregory\">A single empty header is allowed when not allowing empty column headers. #47.</action>\r\n-      <action issue=\"CSV-248\" type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert\">CSVRecord is not Serializable.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert\">Use test scope for supercsv #48.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from H2 1.4.199 to 1.4.200.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from Hamcrest 2.1 to 2.2.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from Mockito 3.1.0 to 3.2.4.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Chen\">Fix typos in site and test #53.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Chen\">Fix typo performance test #55.</action>\r\n-    </release>\r\n-    <release version=\"1.7\" date=\"2019-06-01\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\r\n-      <action issue=\"CSV-233\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add predefined CSVFormats for printing MongoDB CSV and TSV.</action>\r\n-      <action issue=\"CSV-208\" type=\"fix\" dev=\"ggregory\" due-to=\"Jurrie Overgoor\">Fix escape character for POSTGRESQL_TEXT and POSTGRESQL_CSV formats.</action>\r\n-      <action issue=\"CSV-232\" type=\"fix\" dev=\"ggregory\" due-to=\"Jurrie Overgoor, Gary Gregory\">Site link \"Source Repository\" does not work.</action>\r\n-      <action issue=\"CSV-234\" type=\"add\" dev=\"ggregory\" due-to=\"Roberto Benedetti, Gary Gregory\">Add support for java.sql.Clob.</action>\r\n-      <action issue=\"CSV-237\" type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update to Java 8.</action>\r\n-      <action issue=\"CSV-238\" type=\"fix\" dev=\"ggregory\" due-to=\"Stephen Olander-Waters\">Escape quotes in CLOBs #39.</action>\r\n-      <action issue=\"CSV-239\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, Dave Moten\">Cannot get headers in column order from CSVRecord.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from H2 1.4.198 to 1.4.199.</action>\r\n-    </release>\r\n-    <release version=\"1.6\" date=\"2018-09-22\" description=\"Feature and bug fix release (Java 7 or above)\">\r\n-      <action issue=\"CSV-231\" type=\"update\" dev=\"britter\">Add more documentation to CSVPrinter.</action>\r\n-      <action issue=\"CSV-217\" type=\"add\" dev=\"ggregory\" due-to=\"Korolyov Alexei\">Add autoFlush option for CsvPrinter. PR #24.</action>\r\n-      <action issue=\"CSV-219\" type=\"fix\" dev=\"ggregory\" due-to=\"Zhang Hongda\">The behavior of quote char using is not similar as Excel does when the first string contains CJK char(s).</action>\r\n-      <action issue=\"CSV-172\" type=\"fix\" dev=\"ggregory\" due-to=\"Andrew Pennebaker\">Don't quote cells just because they have UTF-8 encoded characters.</action>\r\n-      <action issue=\"CSV-220\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add API org.apache.commons.csv.CSVFormat.withSystemRecordSeparator().</action>\r\n-      <action issue=\"CSV-223\" type=\"fix\" dev=\"ggregory\" due-to=\"Samuel Martin\">Inconsistency between Javadoc of CSVFormat DEFAULT EXCEL.</action>\r\n-      <action issue=\"CSV-209\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Create CSVFormat.ORACLE preset.</action>\r\n-      <action issue=\"CSV-224\" type=\"fix\" dev=\"ggregory\" due-to=\"David Warshaw\">Some multi-iterator parsing peek sequences incorrectly consume elements.</action>\r\n-      <action issue=\"CSV-225\" type=\"fix\" dev=\"ggregory\" due-to=\"Anson Schwabecher\">Parse method should avoid creating a redundant BufferedReader.</action>\r\n-      <action issue=\"CSV-233\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add predefined CSVFormats for printing MongoDB CSV and TSV.</action>\r\n-    </release>\r\n-    <release version=\"1.5\" date=\"2017-09-03\" description=\"Feature and bug fix release (Java 7 or above)\">\r\n-      <action issue=\"CSV-203\" type=\"fix\" dev=\"ggregory\" due-to=\"Richard Wheeldon, Kai Paroth\">withNullString value is printed without quotes when QuoteMode.ALL is specified; add QuoteMode.ALL_NON_NULL. PR #17.</action>\r\n-      <action issue=\"CSV-194\" type=\"fix\" dev=\"ggregory\" due-to=\"Marc Prud'hommeaux\">Fix outdated comments about FileReader in CSVParser #13</action>\r\n-      <action issue=\"CSV-193\" type=\"fix\" dev=\"ggregory\" due-to=\"Matthias Wiehl\">Fix incorrect method name 'withFirstRowAsHeader' in user guide.</action>\r\n-      <action issue=\"CSV-171\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, Michael Graessle, Adrian Bridgett\">Negative numeric values in the first column are always quoted in minimal mode.</action>\r\n-      <action issue=\"CSV-187\" type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update platform requirement from Java 6 to 7.</action>\r\n-      <action issue=\"CSV-201\" type=\"update\" dev=\"ggregory\" due-to=\"Benedikt Ritter, Gary Gregory\">Do not use RuntimeException in CSVParser.iterator().new Iterator() {...}.getNextRecord()</action>\r\n-      <action issue=\"CSV-189\" type=\"add\" dev=\"ggregory\" due-to=\"Peter Holzwarth, Gary Gregory\">CSVParser: Add factory method accepting InputStream.</action>\r\n-      <action issue=\"CSV-190\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add convenience API CSVFormat.print(File, Charset)</action>\r\n-      <action issue=\"CSV-191\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add convenience API CSVFormat.print(Path, Charset)</action>\r\n-      <action issue=\"CSV-192\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add convenience API CSVParser.parse(Path, Charset, CSVFormat)</action>\r\n-      <action issue=\"CSV-205\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add convenience API CSVFormat#printer() to print to System.out</action>\r\n-      <action issue=\"CSV-207\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Provide a CSV Format for printing PostgreSQL CSV and Text formats.</action>\r\n-      <action issue=\"CSV-214\" type=\"add\" dev=\"ggregory\" due-to=\"Nitin Mahendru, Gary Gregory\">Adding a placeholder in the Lexer and CSV parser to store the end-of-line string.</action>\r\n-    </release>\r\n-    <release version=\"1.4\" date=\"2016-05-28\" description=\"Feature and bug fix release (Java 6 or above)\">\r\n-      <action issue=\"CSV-181\" type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Make CSVPrinter.print(Object) GC-free.</action>\r\n-      <action issue=\"CSV-182\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Allow some printing operations directly from CSVFormat.</action>\r\n-      <action issue=\"CSV-183\" type=\"update\" dev=\"ggregory\">Drop ferc.gov tests.</action>\r\n-    </release>\r\n-    <release version=\"1.3\" date=\"2016-05-09\" description=\"Feature and bug fix release (Java 6 or above)\">\r\n-      <action issue=\"CSV-179\" type=\"add\" dev=\"britter\">Add shortcut method for using first record as header to CSVFormat</action>\r\n-      <action issue=\"CSV-180\" type=\"add\" dev=\"britter\">Add withHeader(Class&lt;? extends Enum&gt;) to CSVFormat</action>\r\n-      <action issue=\"CSV-167\" type=\"update\" dev=\"sebb\" due-to=\"Rene\">Comment line hides next record; update Javadoc to make behavior clear</action>\r\n-      <action issue=\"CSV-153\" type=\"update\" dev=\"britter\" due-to=\"Wren\">CSVPrinter doesn't skip creation of header record if skipHeaderRecord is set to true</action>\r\n-      <action issue=\"CSV-159\" type=\"add\" dev=\"ggregory\" due-to=\"Yamil Medina\">Add IgnoreCase option for accessing header names</action>\r\n-      <action issue=\"CSV-169\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">The null string should be case-sensitive when reading records</action>\r\n-      <action issue=\"CSV-168\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, cornel creanga\">CSVFormat.nullString should not be escaped</action>\r\n-      <action issue=\"CSV-170\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, cornel creanga\">CSVFormat.MYSQL nullString should be \"\\N\"</action>\r\n-      <action issue=\"CSV-161\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, Kristof Meixner, Emmanuel Bourg\">Fix Javadoc to say CSVFormat with() methods return a new CSVFormat</action>\r\n-      <action issue=\"CSV-175\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, Chris Jones\">Support for ignoring trailing delimiter.</action>\r\n-      <action issue=\"CSV-177\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Support trimming leading and trailing blanks.</action>\r\n-      <action issue=\"CSV-178\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Create default formats for Informix UNLOAD and UNLOAD CSV.</action>\r\n-    </release>\r\n-    <release version=\"1.2\" date=\"2015-08-24\" description=\"Feature and bug fix release (Java 6 or above)\">\r\n-      <action issue=\"CSV-145\" type=\"fix\" dev=\"ggregory\" due-to=\"Frank Ulbricht\">CSVFormat.with* methods clear the header comments</action>\r\n-      <action issue=\"CSV-156\" type=\"fix\" dev=\"ggregory\" due-to=\"Jason Steenstra-Pickens\">Incorrect Javadoc on QuoteMode.NONE</action>\r\n-      <action issue=\"CSV-157\" type=\"add\" dev=\"ggregory\">Add enum CSVFormat.Predefined that contains the default CSVFormat values.</action>\r\n-    </release>\r\n-    <release version=\"1.1\" date=\"2014-11-16\" description=\"Feature and bug fix release (Java 6 or above)\">\r\n-      <action issue=\"CSV-140\" type=\"fix\" dev=\"ggregory\" due-to=\"Damjan Jovanovic\">QuoteMode.NON_NUMERIC doesn't work with CSVPrinter.printRecords(ResultSet)</action>\r\n-      <action issue=\"CSV-130\" type=\"fix\" dev=\"ggregory\" due-to=\"Sergei Lebedev\">CSVFormat#withHeader doesn't work well with #printComment, add withHeaderComments(String...)</action>\r\n-      <action issue=\"CSV-128\" type=\"fix\" dev=\"ggregory\">CSVFormat.EXCEL should ignore empty header names</action>\r\n-      <action issue=\"CSV-132\" type=\"fix\" dev=\"ggregory\" due-to=\"Sascha Szott\">Incorrect Javadoc referencing org.apache.commons.csv.CSVFormat withQuote()</action>\r\n-      <action issue=\"CSV-124\" type=\"update\" dev=\"brentworden\" due-to=\"Kalyan\">Improve toString() implementation of CSVRecord</action>\r\n-      <action issue=\"CSV-134\" type=\"update\" dev=\"ggregory\" due-to=\"wu wen\">Unified parameter validation</action>\r\n-      <action issue=\"CSV-129\" type=\"add\" dev=\"ggregory\">Add CSVFormat#with 0-arg methods matching boolean arg methods</action>\r\n-      <action issue=\"CSV-131\" type=\"add\" dev=\"ggregory\" due-to=\"Holger Stratmann\">Save positions of records to enable random access</action>\r\n-      <action issue=\"CSV-139\" type=\"add\" dev=\"ggregory\">CSVPrinter.printRecord(ResultSet) with metadata</action>\r\n-    </release>\r\n-    <release version=\"1.0\" date=\"2014-08-14\" description=\"First release (Java 6 or above)\">\r\n-      <action issue=\"CSV-125\" type=\"fix\" dev=\"britter\">No longer works with Java 6</action>\r\n-      <action issue=\"CSV-122\" type=\"fix\" dev=\"britter\" due-to=\"Mike Lewis\">NullPointerException when empty header string and null string of \"\"</action>\r\n-      <action issue=\"CSV-117\" type=\"update\" dev=\"sebb\">Validate format parameters in constructor</action>\r\n-      <action issue=\"CSV-121\" type=\"add\" dev=\"ggregory\" due-to=\"Sebastian Hardt\">IllegalArgumentException thrown when the header contains duplicate names when the column names are empty.</action>\r\n-      <action issue=\"CSV-120\" type=\"add\" dev=\"ggregory\" due-to=\"Sergei Lebedev\">CSVFormat#withHeader doesn't work with CSVPrinter</action>\r\n-      <action issue=\"CSV-119\" type=\"add\" dev=\"ggregory\" due-to=\"Sergei Lebedev\">CSVFormat is missing a print(...) method</action>\r\n-      <action issue=\"CSV-118\" type=\"fix\" dev=\"ggregory\" due-to=\"Enrique Lara\">CSVRecord.toMap() throws NPE on formats with no\r\n-        headers.</action>\r\n-      <action issue=\"CSV-113\" type=\"fix\" dev=\"sebb\">Check whether ISE/IAE are being used appropriately</action>\r\n-      <action issue=\"CSV-114\" type=\"fix\" dev=\"sebb\">CSVFormat constructor should reject a header array with duplicate\r\n-        entries\r\n-      </action>\r\n-      <action issue=\"CSV-112\" type=\"fix\" dev=\"britter\">HeaderMap is inconsistent when it is parsed from an input with\r\n-        duplicate columns names\r\n-      </action>\r\n-      <action issue=\"CSV-111\" type=\"fix\" dev=\"ggregory\">CSVRecord.toMap() fails if row length shorter than header length\r\n-      </action>\r\n-      <action issue=\"CSV-106\" type=\"fix\" dev=\"ggregory\">CSVFormat.format allways append null</action>\r\n-      <action issue=\"CSV-105\" type=\"add\" dev=\"ggregory\">Add Map conversion API to CSVRecord</action>\r\n-      <action issue=\"CSV-100\" type=\"fix\" dev=\"ggregory\">CSVParser: getHeaderMap throws NPE</action>\r\n-      <action issue=\"CSV-42\" type=\"update\" dev=\"ebourg\" due-to=\"Bob Smith\">Lots of possible changes</action>\r\n-      <action issue=\"CSV-78\" type=\"update\" dev=\"sebb\">Use Character instead of char for char fields except delimiter\r\n-      </action>\r\n-      <action issue=\"CSV-99\" type=\"update\" dev=\"britter\">Revert Builder implementation in CSVFormat</action>\r\n-      <action issue=\"CSV-53\" type=\"fix\" dev=\"britter\">CSVRecord does not verify that the length of the header mapping\r\n-        matches the number of values\r\n-      </action>\r\n-      <action issue=\"CSV-93\" type=\"update\" dev=\"ggregory\">Allow the handling of NULL values</action>\r\n-      <action issue=\"CSV-68\" type=\"update\" dev=\"ggregory\">Use the Builder pattern for CSVFormat</action>\r\n-      <action issue=\"CSV-84\" type=\"update\" dev=\"sebb\">Clarify comment handling</action>\r\n-      <action issue=\"CSV-25\" type=\"update\" dev=\"ebourg\">CSVParser.nextValue() seems pointless</action>\r\n-      <action issue=\"CSV-97\" type=\"update\" dev=\"ggregory\">Allow the String value for null to be customized for the CSV\r\n-        printer\r\n-      </action>\r\n-      <action issue=\"CSV-88\" type=\"update\" dev=\"ggregory\">Not possible to create a CSVFormat from scratch</action>\r\n-      <action issue=\"CSV-52\" type=\"add\" dev=\"ggregory\">Keep track of record number</action>\r\n-      <action issue=\"CSV-94\" type=\"update\" dev=\"sebb\">Lexer should only use char fields</action>\r\n-      <action issue=\"CSV-92\" type=\"add\" dev=\"ggregory\">Need a way to extract parsed headers, e.g. for use in formatting\r\n-        output\r\n-      </action>\r\n-      <action issue=\"CSV-65\" type=\"add\" dev=\"ebourg\">Header support</action>\r\n-      <action issue=\"CSV-54\" type=\"fix\" dev=\"sebb\">Confusing semantic of the ignore leading/trailing spaces parameters\r\n-      </action>\r\n-      <action issue=\"CSV-71\" type=\"update\" dev=\"sebb\">Add convenience methods to CSVLexer</action>\r\n-      <action issue=\"CSV-59\" type=\"update\" dev=\"ebourg\">Is CharBuffer really needed, now that StringBuilder is available?\r\n-      </action>\r\n-      <action issue=\"CSV-55\" type=\"update\" dev=\"britter\">Replace while(true)-loop in CSVParser.getRecord with do-while-loop\r\n-      </action>\r\n-      <action issue=\"CSV-34\" type=\"fix\" dev=\"sebb\">CSVFormat describes itself as immutable, but it is not - in\r\n-        particular it is not thread-safe\r\n-      </action>\r\n-      <action issue=\"CSV-36\" type=\"fix\" dev=\"yonik\">Endless loops in CSV parser</action>\r\n-      <action issue=\"CSV-13\" type=\"fix\" dev=\"ebourg\">NullPointerException in CSVPrinter.print()/println()</action>\r\n-      <action issue=\"CSV-45\" type=\"update\" dev=\"yonik\">CSVPrinter overhaul</action>\r\n-      <action issue=\"CSV-23\" type=\"fix\" dev=\"ebourg\">Excel strategy uses wrong separator</action>\r\n-      <action issue=\"CSV-49\" type=\"update\" dev=\"ebourg\" due-to=\"Bob Smith\">CSVStrategy has modifiable public static variables\r\n-      </action>\r\n-      <action issue=\"CSV-48\" type=\"add\" dev=\"ebourg\">Predefined format for MYSQL</action>\r\n-      <action issue=\"CSV-46\" type=\"update\" dev=\"ebourg\">Reduce visibility of methods in internal classes</action>\r\n-      <action issue=\"CSV-26\" type=\"update\" dev=\"jacopoc\">ExtendedBufferedReader does too much</action>\r\n-      <action issue=\"CSV-27\" type=\"update\" dev=\"ebourg\">Decide whether to keep the csv.writer subpackage</action>\r\n-    </release>\r\n-\r\n-  </body>\r\n-</document>\r\n+<?xml version=\"1.0\"?>\n+<!--\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements. See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License. You may obtain a copy of the License at\n+\n+  http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+-->\n+\n+<!--\n+  This file is used by the maven-changes-plugin to generate the release notes.\n+  Useful ways of finding items to add to this file are:\n+\n+  1. Add items when you fix a bug or add a feature (this makes the\n+  release process easy :-).\n+\n+  2. Do a JIRA search for tickets closed since the previous release.\n+\n+  3. Use the report generated by the maven-changelog-plugin to see all\n+  SVN commits. Set the project.properties' maven.changelog.range\n+  property to the number of days since the last release.\n+\n+\n+  The <action> type attribute can be add,update,fix,remove.\n+-->\n+\n+<document xmlns=\"http://maven.apache.org/changes/2.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n+    xsi:schemaLocation=\"http://maven.apache.org/changes/2.0.0 https://maven.apache.org/xsd/changes-2.0.0.xsd\">\n+  <properties>\n+    <title>Apache Commons CSV Release Notes</title>\n+  </properties>\n+  <body>\n+    <release version=\"1.13.1\" date=\"YYYY-MM-DD\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\n+      <!-- FIX -->\n+      <action type=\"fix\" issue=\"CSV-317\" dev=\"ggregory\" due-to=\"Filipe Roque\">Release history link changed from changes-report.html to changes.html #516.</action>\n+      <!-- ADD -->\n+      <!-- UPDATE -->\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump com.opencsv:opencsv from 5.9 to 5.10.</action>\n+    </release>\n+    <release version=\"1.13.0\" date=\"2025-01-08\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\n+      <!-- FIX -->\n+      <action type=\"fix\" issue=\"CSV-314\" dev=\"ggregory\" due-to=\"Gary Gregory\">Required OSGi Import-Package version numbers in MANIFEST.MF #504.</action>\n+      <action type=\"fix\" issue=\"CSV-314\" dev=\"ggregory\" due-to=\"Gary Gregory\">CSVParser.nextRecord() should throw CSVException (an IOException subclass) instead of IOException and IllegalStateException, no method signature changes needed.</action>\n+      <!-- ADD -->\n+      <action type=\"add\" issue=\"CSV-313\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add CSVPrinter.getRecordCount().</action>\n+      <action type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add and use CSVParser.Builder and builder() and deprecate CSVParser constructors.</action>\n+      <action type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">CSVFormat.Builder implements Supplier&lt;CSVFormat&gt;.</action>\n+      <action type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Deprecate CSVFormat.Builder.build() for get().</action>\n+      <action type=\"add\" issue=\"CSV-196\" dev=\"ggregory\" due-to=\"Yuzhan Jiang, Gary Gregory\">Track byte position #502.</action>\n+      <!-- UPDATE -->\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump org.apache.commons:commons-parent from 76 to 78 #486, #495.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump org.codehaus.mojo:taglist-maven-plugin from 3.1.0 to 3.2.1 #493.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump commons-io:commons-io from 2.17.0 to 2.18.0 #505.</action> \n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump commons-codec:commons-codec from 1.17.1 to 1.17.2.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.apache.commons:commons-parent from 78 to 79.</action>\n+    </release>\n+    <release version=\"1.12.0\" date=\"2024-09-21\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\n+      <!-- ADD -->\n+      <action type=\"add\" issue=\"CSV-270\" dev=\"ggregory\" due-to=\"Thomas Kamps, Gary Gregory\">Add CSVException that extends IOException thrown on invalid input instead of IOException.</action>\n+      <!-- FIX -->\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Fix PMD issues for port to PMD 7.1.0.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Dvid Szigecsn, Gary Gregory\">Fix some Javadoc links #442.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Dvid Szigecsn\">Extract duplicated code into a method #444.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Dvid Szigecsn\">Migrate CSVFormat#print(File, Charset) to NIO #445.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Dvid Szigecsn\">Fix documentation for CSVFormat private constructor #466.</action>\n+      <action type=\"fix\" issue=\"CSV-294\" dev=\"ggregory\" due-to=\"Joern Huxhorn, Gary Gregory\">CSVFormat does not support explicit \" as escape char.</action>\n+      <action type=\"fix\" issue=\"CSV-150\" dev=\"ggregory\" due-to=\"dota17, Gary Gregory, Jrn Huxhorn\">Escaping is not disableable.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Fix Javadoc warnings on Java 23.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Improve parser performance by up to 20%, YMMV.</action>\n+      <!-- UPDATE -->\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump commons-codec:commons-codec from 1.16.1 to 1.17.1 #422, #449.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.apache.commons:commons-parent from 69 to 76 #435, #452, #465, #468, #475, #482.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.codehaus.mojo:taglist-maven-plugin from 3.0.0 to 3.1.0 #441.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.apache.commons:commons-lang3 from 3.14.0 to 3.17.0 #450, #459, #470.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.hamcrest:hamcrest from 2.2 to 3.0 #455.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump commons-io:commons-io from 2.16.1 to 2.17.0 #476.</action>\n+    </release>\n+    <release version=\"1.11.0\" date=\"2024-04-28\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\n+      <!-- ADD -->\n+      <action issue=\"CSV-308\" type=\"add\" dev=\"ggregory\" due-to=\"Buddhi De Silva, Gary Gregory\">[Javadoc] Add example to CSVFormat#setHeaderComments() #344.</action>\n+      <action type=\"add\" dev=\"ggregory\" due-to=\"DamjanJovanovic, Gary Gregory\">Add and use CSVFormat#setTrailingData(boolean) in CSVFormat.EXCEL for Excel compatibility #303.</action>\n+      <action type=\"add\" dev=\"ggregory\" due-to=\"DamjanJovanovic, Gary Gregory\">Add and use CSVFormat#setLenientEof(boolean) in CSVFormat.EXCEL for Excel compatibility #303.</action>\n+      <!-- FIX -->\n+      <action type=\"fix\" issue=\"CSV-306\" dev=\"ggregory\" due-to=\"Sam Ng, Bruno P. Kinoshita\">Replace deprecated method in user guide, update external link #324, #325.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Seth Falco, Bruno P. Kinoshita\">Document duplicate header behavior #309.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"jkbkupczyk\">Add missing docs #328.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"step-security-bot\">[StepSecurity] CI: Harden GitHub Actions #329, #330.</action>\n+      <action type=\"fix\" issue=\"CSV-147\" dev=\"ggregory\" due-to=\"Steven Peterson, Benedikt Ritter, Gary Gregory, Joerg Schaible, Buddhi De Silva, Elliotte Rusty Harold\">Better error message during faulty CSV record read #347.</action>\n+      <action type=\"fix\" issue=\"CSV-310\" dev=\"ggregory\" due-to=\"Buddhi De Silva\">Misleading error message when QuoteMode set to None #352.</action>\n+      <action type=\"fix\" issue=\"CSV-311\" dev=\"ggregory\" due-to=\"Christian Feuersaenger, Gary Gregory\">OutOfMemory for very long rows despite using column value of type Reader.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Use try-with-resources to manage JDBC CLOB in CSVPrinter.printRecords(ResultSet).</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">JDBC Blob columns are now output as Base64 instead of Object#toString(), which usually is InputStream#toString().</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"DamjanJovanovic, Gary Gregory\">Support unusual Excel use cases: Add support for trailing data after the closing quote, and EOF without a final closing quote #303.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Igor Kamyshnikov, Gary Gregory\">MongoDB CSV empty first column parsing fix #412.</action>\n+      <!-- UPDATE -->\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump commons-io:commons-io: from 2.11.0 to 2.16.1 #408, #413.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump commons-parent from 57 to 69 #410.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump h2 from 2.1.214 to 2.2.224 #333, #349, #359.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump commons-lang3 from 3.12.0 to 3.14.0.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Buddhi De Silva, Michael Osipov, Gary Gregory\">Update exception message in CSVRecord#getNextRecord() #348.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump tests using com.opencsv:opencsv from 5.8 to 5.9 #373.</action>\n+    </release>\n+    <release version=\"1.10.0\" date=\"2023-01-28\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\n+      <!-- FIX -->\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Minor changes #172.</action>\n+      <action issue=\"CSV-292\" type=\"fix\" dev=\"kinow\" due-to=\"Rob Vesse\">No Automatic-Module-Name prevents usage in JPMS projects without repacking the JAR.</action>\n+      <action issue=\"CSV-288\" type=\"fix\" dev=\"ggregory\" due-to=\"Santhsoh, Angus\">Fix for multi-char delimiter not working as expected #218.</action>\n+      <action issue=\"CSV-269\" type=\"fix\" dev=\"ggregory\" due-to=\"Auke te Winkel, Gary Gregory\">CSVRecord.get(Enum) should use Enum.name() instead of Enum.toString().</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Allow org.apache.commons.csv.IOUtils.copy(Reader, Appendable, CharBuffer) to compile on Java 11 and run on Java 8.</action>\n+      <action issue=\"CSV-300\" type=\"fix\" dev=\"ggregory\" due-to=\"Markus Spann, Gary Gregory\">CSVRecord.toList() does not give write access to the new List.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">CSVParser.getRecords() now throws UncheckedIOException instead of IOException.</action>\n+      <action issue=\"CSV-274\" type=\"fix\" dev=\"ggregory\" due-to=\"Peter Hull, Bruno P. Kinoshita, Gary Gregory\">Add comments to iterator() and stream() #270.</action>\n+      <action issue=\"CSV-290\" type=\"fix\" dev=\"ggregory\" due-to=\"angusdev, Gary Gregory\">Fix wrong assumptions in PostgreSQL formats #265.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Mykola Faryma\">Validate input to setDelimiter(String) for empty string #266.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Dependabot\">Bump CSVFormat#serialVersionUID from 1 to 2.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert\">CSVParser: Identify duplicates in null, empty and blank header names #279.</action>\n+      <!-- REMOVE -->\n+      <action                 type=\"remove\" dev=\"ggregory\">Serialization in CSVFormat is not supported from one version to the next.</action>\n+      <!-- ADD -->\n+      <action issue=\"CSV-291\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Make CSVRecord#values() public.</action>\n+      <action issue=\"CSV-264\" type=\"add\" dev=\"ggregory\" due-to=\"Sagar Tiwari, Seth Falco, Alex Herbert, Gary Gregory\">Add DuplicateHeaderMode for flexibility with header strictness. #114.</action>\n+      <action issue=\"CSV-295\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Support for parallelism in CSVPrinter.</action>\n+      <action issue=\"CSV-295\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add CSVPrinter.printRecord[s](Stream).</action>\n+      <action issue=\"CSV-304\" type=\"add\" dev=\"ggregory\" due-to=\"Peter Hull, Bruno P. Kinoshita, Gary Gregory\">Add accessors for header/trailer comments #257.</action>\n+      <action type=\"add\" dev=\"ggregory\">Add github/codeql-action.</action>\n+      <!-- UPDATE -->\n+      <action                 type=\"update\" dev=\"kinow\" due-to=\"Dependabot, Gary Gregory\">Bump actions/cache from 2.1.6 to 3.0.10 #196, #233, #243, #267, #271.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump actions/checkout from 2.3.4 to 3.1.0 #188, #195, #220, #272.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump actions/setup-java from 2 to 3.5.1.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump actions/upload-artifact from 3.1.0 to 3.1.1 #280.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump commons-parent from 52 to 57 #264, #288, #298, #323.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump checkstyle from 8.44 to 9.2.1 #180, #190, #194, #202, #207.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump junit-jupiter from 5.8.0-M1 to 5.9.1 #179, #186, #201, #244, #263.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump jmh-core from 1.32 to 1.36 #176, #208, #229, #285.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump jmh-generator-annprocess from 1.32 to 1.36 #175, #206, #226, #283.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump mockito-core from 3.11.2 to 4.11.0 #187, #197, #204, #212, #230, #237, #251, #259, #284, #292, #297.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump maven-pmd-plugin from 3.14.0 to 3.19.0 #184, #219, #238, #254, #258.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump pmd from 6.36.0 to 6.52.0 #173, #189, #193, #199, #227, #233, #214, #236, #240, #247, #255, #273.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump opencsv from 5.5.1 to 5.7.1 #182, #221, #260, #281.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump spotbugs-maven-plugin from 4.3.0 to 4.7.3.0 #192, #198, #203, #211, #225, #234, #242, #245, #261, #275, #282.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump com.github.spotbugs:spotbugs from 4.5.3 to 4.7.2.</action>\n+      <action                 type=\"update\" dev=\"kinow\" due-to=\"Dependabot\">Bump h2 from 1.4.200 to 2.1.214 #200, #205, #213, #239.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump maven-javadoc-plugin from 3.3.0 to 3.4.1.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump biz.aQute.bnd:biz.aQute.bndlib from 5.3.0 to 6.3.1.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump jacoco-maven-plugin from 0.8.7 to 0.8.8.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump japicmp-maven-plugin from 0.15.3 to 0.16.0.</action>\n+      <action                 type=\"update\" dev=\"kinow\" due-to=\"Dependabot\">Bump maven-checkstyle-plugin from 3.1.2 to 3.2.0 #253.</action>\n+    </release>\n+    <release version=\"1.9.0\" date=\"2021-07-24\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\n+      <!-- FIX -->\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Amey Jadiye\">Replace FindBugs with SpotBugs #56.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Javadoc typo in CSVFormat let's -> lets #57.</action>\n+      <action issue=\"CSV-259\" type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">CSVFormat.printWithEscapes throws StringIndexOutOfBoundsException when value is Reader #61.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Improve CSVFormat test coverage #63.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Fix CSVFileParserTest.java to allow for a null return value from record.getComment() #62.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Improve test coverage in CSVFormatTest #65.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Removed invalid Javadoc markup for CSVFormat EXCEL #64.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Improve CSVRecord and CSVPrinter code coverage #66.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Improve lexer and token coverage #67.</action>\n+      <action issue=\"CSV-211\" type=\"fix\" dev=\"ggregory\" due-to=\"Alpesh Kulkarni, Chen\">CSVFormat.format trims last delimiter if the delimiter is a white space #71.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Replace org.apache.commons.csv.Assertions.notNull() with Objects.requireNonNull().</action>\n+      <action issue=\"CSV-149\" type=\"fix\" dev=\"ggregory\" due-to=\"Kranthi, Gary Gregory, Brent Worden, dota17\">Line number is not proper at EOF.</action>\n+      <action issue=\"CSV-195\" type=\"fix\" dev=\"ggregory\" due-to=\"Rodolfo Duldulao, Rodolfo Duldulao, Michael Vitz, dota17\">Parser iterates over the last CSV Record twice.</action>\n+      <action issue=\"CSV-267\" type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Minor improvements #126, #127, #130.</action>\n+      <action issue=\"CSV-123\" type=\"fix\" dev=\"ggregory\" due-to=\"Emmanuel Bourg, Benedikt Ritter, shivakrishnaah, Gary Gregory\">Add possibility to use ResultSet header meta data as CSV header #11.</action>\n+      <action issue=\"CSV-148\" type=\"fix\" dev=\"ggregory\" due-to=\"dota17\">Add test cases for withIgnoreSurroundingSpaces() and withTrim() #70.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update CSVParser.parse(File, Charset, CSVFormat) from IO to NIO.</action>\n+      <action issue=\"CSV-271\" type=\"fix\" dev=\"ggregory\" due-to=\"Amar Prakash Pandey\">Missing separator with print(object) followed by printRecord(Object[]) #157.</action>\n+      <action issue=\"CSV-158\" type=\"fix\" dev=\"ggregory\" due-to=\"Alexander Bondarev, Benedikt Ritter, Gary Gregory, Chen\">Fix EOL checking for read array in ExtendedBufferedReader #5.</action>\n+      <action issue=\"CSV-263\" type=\"fix\" dev=\"ggregory\" due-to=\"Jason A. Guild, Gary Gregory\">Print from Reader with embedded quotes generates incorrect output #78.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Replace JUnit assert by simpler but equivalent calls. #159.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Seth Falco\">Update gitignore to ignore idea and vscode #160.</action>\n+      <action issue=\"CSV-281\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Update CSVBenchmark #165.</action>\n+      <action issue=\"CSV-283\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Remove Whitespace Check Determines Delimiter Twice #167.</action>\n+      <action issue=\"CSV-283\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Document and Automate CSV Benchmark Harness #166.</action>\n+      <action issue=\"CSV-279\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Optimize Lexer Delimiter Check for One Character Delimiter #163.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: org.apache.commons.csv.CSVParser.getHeaderNames() may expose internal representation by returning CSVParser.headerNames [org.apache.commons.csv.CSVParser] At CSVParser.java:[line 599] EI_EXPOSE_REP.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: new org.apache.commons.csv.CSVParser(Reader, CSVFormat, long, long) may expose internal representation by storing an externally mutable object into CSVParser.format [org.apache.commons.csv.CSVParser] At CSVParser.java:[line 433] EI_EXPOSE_REP2.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: new org.apache.commons.csv.CSVParser(Reader, CSVFormat, long, long) may expose internal representation by storing an externally mutable object into CSVParser.headerMap [org.apache.commons.csv.CSVParser] At CSVParser.java:[line 437] EI_EXPOSE_REP2.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: new org.apache.commons.csv.CSVParser(Reader, CSVFormat, long, long) may expose internal representation by storing an externally mutable object into CSVParser.headerNames [org.apache.commons.csv.CSVParser] At CSVParser.java:[line 438] EI_EXPOSE_REP2.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: new org.apache.commons.csv.CSVPrinter(Appendable, CSVFormat) may expose internal representation by storing an externally mutable object into CSVPrinter.format [org.apache.commons.csv.CSVPrinter] At CSVPrinter.java:[line 100] EI_EXPOSE_REP2.</action>\n+      <action issue=\"CSV-284\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Formalize PerformanceTest #168.</action>\n+      <action issue=\"CSV-278\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Reuse Buffers in Lexer for Delimiter Detection #162.</action>\n+      <action issue=\"CSV-286\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Cleanup and Document Performance Test Harness #170.</action>\n+      <action issue=\"CSV-265\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Update buffer position when reading line comment #120.</action>\n+      <!-- ADD -->\n+      <action issue=\"CSV-275\" type=\"add\" dev=\"ggregory\" due-to=\"Michael Wyraz, Gary Gregory\">Make CSVRecord#toList() public.</action>\n+      <action                 type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add CSVRecord#stream().</action>\n+      <action                 type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add CSVParser#stream().</action>\n+      <action issue=\"CSV-184\" type=\"add\" dev=\"ggregory\" due-to=\"Gaurav Agarwal, M. Steiger, Gary Gregory\">Make the method CSVRecord.putIn(Map) public.</action>\n+      <action                 type=\"add\" dev=\"ggregory\" due-to=\"dota17\">Add test cases for CSVRecord with get(Enum) and toString. #54.</action>\n+      <action                 type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, dota17\">Add and use CSVFormat.Builder, deprecated CSVFormat#with methods, based on #73.</action>\n+      <action issue=\"CSV-206\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, dota17\">Add support for String delimiters #76.</action>\n+      <!-- UPDATE -->\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update org.junit.jupiter:junit-jupiter from 5.6.0 to 5.7.0, #84 #109</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from Apache Commons Lang 3.9 to 3.12.0.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from commons-io:commons-io 2.6 to 2.11.0, #108.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump actions/checkout from v1 to v2.3.4, #79, #92, #121.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump commons-parent from 50 to 51 #80.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump tests from opencsv from 3.1 to 5.5.1 #81, #137, #158.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from super-csv from 2.2.1 to 2.4.0 #86.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump build actions/setup-java from v1.4.0 to v2, #101, #113.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump maven-pmd-plugin from 3.13.0 to 3.14.0 #122.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump tests from org.mockito:mockito-core 3.2.4 -> 3.11.2; #88, #107, #110, #123, #128, #129, #156.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump actions/cache from v2 to v2.1.6 #132, #153.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump maven-checkstyle-plugin from 3.0.0 to 3.1.2 #131.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump checkstyle from 8.29 to 8.44.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump junit-jupiter from 5.7.0 to 5.8.0-M1 #133, #149.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump commons.jacoco.version from 0.8.5 to 0.8.7 (Java 16).</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump commons.spotbugs.version from 4.0.4 to 4.3.0 (Java 16).</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump maven-javadoc-plugin from 3.2.0 to 3.3.0.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump jmh-generator-annprocess from 1.5.2 to 1.32 #151.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump PMD core from 6.29.0 to 6.36.0.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump biz.aQute.bnd:biz.aQute.bndlib from 5.1.2 to 5.3.0.</action>\n+    </release>\n+    <release version=\"1.8\" date=\"2020-02-01\" description=\"This is a feature and maintenance release. Java 8 or later is required.\n+\n+This release fixes serialization compatibility of CSVRecord with versions 1.0 to 1.6.\n+New fields added since 1.7 are not serialized. Support for Serializable is scheduled to be\n+removed in version 2.0.\n+\">\n+      <action issue=\"CSV-255\" type=\"add\" dev=\"ggregory\" due-to=\"0x100\">Add CSVRecord.isSet(int) method #52.</action>\n+      <action issue=\"CSV-135\" type=\"fix\" dev=\"sebb\" due-to=\"Mateusz Zakarczemny\">Char escape doesn't work properly with quoting.</action>\n+      <action issue=\"CSV-244\" type=\"fix\" dev=\"sebb\">Test case failures following CSVFormat#equals() update.</action>\n+      <action issue=\"CSV-243\" type=\"fix\" dev=\"sebb\">CSVFormat withTrim() and withIgnoreSurroundingSpaces() need better docs.</action>\n+      <action issue=\"CSV-242\" type=\"fix\" dev=\"sebb\">CSVFormat equals() and hashCode() don't use all fields.</action>\n+      <action issue=\"CSV-241\" type=\"fix\" dev=\"ggregory\" due-to=\"LuckyIlam, Gary Gregory\">CSVFormat#validate() does not account for allowDuplicateHeaderNames #43.</action>\n+      <action issue=\"CSV-245\" type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert\">Post 1.7 release fixes.</action>\n+      <action issue=\"CSV-252\" type=\"fix\" dev=\"ggregory\" due-to= \"Alex Herbert\">Upgrade test framework to JUnit 5 Jupiter #49, #50.</action>\n+      <action issue=\"CSV-247\" type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert, Gary Gregory\">A single empty header is allowed when not allowing empty column headers. #47.</action>\n+      <action issue=\"CSV-248\" type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert\">CSVRecord is not Serializable.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert\">Use test scope for supercsv #48.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from H2 1.4.199 to 1.4.200.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from Hamcrest 2.1 to 2.2.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from Mockito 3.1.0 to 3.2.4.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Chen\">Fix typos in site and test #53.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Chen\">Fix typo performance test #55.</action>\n+    </release>\n+    <release version=\"1.7\" date=\"2019-06-01\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\n+      <action issue=\"CSV-233\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add predefined CSVFormats for printing MongoDB CSV and TSV.</action>\n+      <action issue=\"CSV-208\" type=\"fix\" dev=\"ggregory\" due-to=\"Jurrie Overgoor\">Fix escape character for POSTGRESQL_TEXT and POSTGRESQL_CSV formats.</action>\n+      <action issue=\"CSV-232\" type=\"fix\" dev=\"ggregory\" due-to=\"Jurrie Overgoor, Gary Gregory\">Site link \"Source Repository\" does not work.</action>\n+      <action issue=\"CSV-234\" type=\"add\" dev=\"ggregory\" due-to=\"Roberto Benedetti, Gary Gregory\">Add support for java.sql.Clob.</action>\n+      <action issue=\"CSV-237\" type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update to Java 8.</action>\n+      <action issue=\"CSV-238\" type=\"fix\" dev=\"ggregory\" due-to=\"Stephen Olander-Waters\">Escape quotes in CLOBs #39.</action>\n+      <action issue=\"CSV-239\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, Dave Moten\">Cannot get headers in column order from CSVRecord.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from H2 1.4.198 to 1.4.199.</action>\n+    </release>\n+    <release version=\"1.6\" date=\"2018-09-22\" description=\"Feature and bug fix release (Java 7 or above)\">\n+      <action issue=\"CSV-231\" type=\"update\" dev=\"britter\">Add more documentation to CSVPrinter.</action>\n+      <action issue=\"CSV-217\" type=\"add\" dev=\"ggregory\" due-to=\"Korolyov Alexei\">Add autoFlush option for CsvPrinter. PR #24.</action>\n+      <action issue=\"CSV-219\" type=\"fix\" dev=\"ggregory\" due-to=\"Zhang Hongda\">The behavior of quote char using is not similar as Excel does when the first string contains CJK char(s).</action>\n+      <action issue=\"CSV-172\" type=\"fix\" dev=\"ggregory\" due-to=\"Andrew Pennebaker\">Don't quote cells just because they have UTF-8 encoded characters.</action>\n+      <action issue=\"CSV-220\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add API org.apache.commons.csv.CSVFormat.withSystemRecordSeparator().</action>\n+      <action issue=\"CSV-223\" type=\"fix\" dev=\"ggregory\" due-to=\"Samuel Martin\">Inconsistency between Javadoc of CSVFormat DEFAULT EXCEL.</action>\n+      <action issue=\"CSV-209\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Create CSVFormat.ORACLE preset.</action>\n+      <action issue=\"CSV-224\" type=\"fix\" dev=\"ggregory\" due-to=\"David Warshaw\">Some multi-iterator parsing peek sequences incorrectly consume elements.</action>\n+      <action issue=\"CSV-225\" type=\"fix\" dev=\"ggregory\" due-to=\"Anson Schwabecher\">Parse method should avoid creating a redundant BufferedReader.</action>\n+      <action issue=\"CSV-233\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add predefined CSVFormats for printing MongoDB CSV and TSV.</action>\n+    </release>\n+    <release version=\"1.5\" date=\"2017-09-03\" description=\"Feature and bug fix release (Java 7 or above)\">\n+      <action issue=\"CSV-203\" type=\"fix\" dev=\"ggregory\" due-to=\"Richard Wheeldon, Kai Paroth\">withNullString value is printed without quotes when QuoteMode.ALL is specified; add QuoteMode.ALL_NON_NULL. PR #17.</action>\n+      <action issue=\"CSV-194\" type=\"fix\" dev=\"ggregory\" due-to=\"Marc Prud'hommeaux\">Fix outdated comments about FileReader in CSVParser #13</action>\n+      <action issue=\"CSV-193\" type=\"fix\" dev=\"ggregory\" due-to=\"Matthias Wiehl\">Fix incorrect method name 'withFirstRowAsHeader' in user guide.</action>\n+      <action issue=\"CSV-171\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, Michael Graessle, Adrian Bridgett\">Negative numeric values in the first column are always quoted in minimal mode.</action>\n+      <action issue=\"CSV-187\" type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update platform requirement from Java 6 to 7.</action>\n+      <action issue=\"CSV-201\" type=\"update\" dev=\"ggregory\" due-to=\"Benedikt Ritter, Gary Gregory\">Do not use RuntimeException in CSVParser.iterator().new Iterator() {...}.getNextRecord()</action>\n+      <action issue=\"CSV-189\" type=\"add\" dev=\"ggregory\" due-to=\"Peter Holzwarth, Gary Gregory\">CSVParser: Add factory method accepting InputStream.</action>\n+      <action issue=\"CSV-190\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add convenience API CSVFormat.print(File, Charset)</action>\n+      <action issue=\"CSV-191\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add convenience API CSVFormat.print(Path, Charset)</action>\n+      <action issue=\"CSV-192\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add convenience API CSVParser.parse(Path, Charset, CSVFormat)</action>\n+      <action issue=\"CSV-205\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add convenience API CSVFormat#printer() to print to System.out</action>\n+      <action issue=\"CSV-207\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Provide a CSV Format for printing PostgreSQL CSV and Text formats.</action>\n+      <action issue=\"CSV-214\" type=\"add\" dev=\"ggregory\" due-to=\"Nitin Mahendru, Gary Gregory\">Adding a placeholder in the Lexer and CSV parser to store the end-of-line string.</action>\n+    </release>\n+    <release version=\"1.4\" date=\"2016-05-28\" description=\"Feature and bug fix release (Java 6 or above)\">\n+      <action issue=\"CSV-181\" type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Make CSVPrinter.print(Object) GC-free.</action>\n+      <action issue=\"CSV-182\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Allow some printing operations directly from CSVFormat.</action>\n+      <action issue=\"CSV-183\" type=\"update\" dev=\"ggregory\">Drop ferc.gov tests.</action>\n+    </release>\n+    <release version=\"1.3\" date=\"2016-05-09\" description=\"Feature and bug fix release (Java 6 or above)\">\n+      <action issue=\"CSV-179\" type=\"add\" dev=\"britter\">Add shortcut method for using first record as header to CSVFormat</action>\n+      <action issue=\"CSV-180\" type=\"add\" dev=\"britter\">Add withHeader(Class&lt;? extends Enum&gt;) to CSVFormat</action>\n+      <action issue=\"CSV-167\" type=\"update\" dev=\"sebb\" due-to=\"Rene\">Comment line hides next record; update Javadoc to make behavior clear</action>\n+      <action issue=\"CSV-153\" type=\"update\" dev=\"britter\" due-to=\"Wren\">CSVPrinter doesn't skip creation of header record if skipHeaderRecord is set to true</action>\n+      <action issue=\"CSV-159\" type=\"add\" dev=\"ggregory\" due-to=\"Yamil Medina\">Add IgnoreCase option for accessing header names</action>\n+      <action issue=\"CSV-169\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">The null string should be case-sensitive when reading records</action>\n+      <action issue=\"CSV-168\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, cornel creanga\">CSVFormat.nullString should not be escaped</action>\n+      <action issue=\"CSV-170\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, cornel creanga\">CSVFormat.MYSQL nullString should be \"\\N\"</action>\n+      <action issue=\"CSV-161\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, Kristof Meixner, Emmanuel Bourg\">Fix Javadoc to say CSVFormat with() methods return a new CSVFormat</action>\n+      <action issue=\"CSV-175\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, Chris Jones\">Support for ignoring trailing delimiter.</action>\n+      <action issue=\"CSV-177\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Support trimming leading and trailing blanks.</action>\n+      <action issue=\"CSV-178\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Create default formats for Informix UNLOAD and UNLOAD CSV.</action>\n+    </release>\n+    <release version=\"1.2\" date=\"2015-08-24\" description=\"Feature and bug fix release (Java 6 or above)\">\n+      <action issue=\"CSV-145\" type=\"fix\" dev=\"ggregory\" due-to=\"Frank Ulbricht\">CSVFormat.with* methods clear the header comments</action>\n+      <action issue=\"CSV-156\" type=\"fix\" dev=\"ggregory\" due-to=\"Jason Steenstra-Pickens\">Incorrect Javadoc on QuoteMode.NONE</action>\n+      <action issue=\"CSV-157\" type=\"add\" dev=\"ggregory\">Add enum CSVFormat.Predefined that contains the default CSVFormat values.</action>\n+    </release>\n+    <release version=\"1.1\" date=\"2014-11-16\" description=\"Feature and bug fix release (Java 6 or above)\">\n+      <action issue=\"CSV-140\" type=\"fix\" dev=\"ggregory\" due-to=\"Damjan Jovanovic\">QuoteMode.NON_NUMERIC doesn't work with CSVPrinter.printRecords(ResultSet)</action>\n+      <action issue=\"CSV-130\" type=\"fix\" dev=\"ggregory\" due-to=\"Sergei Lebedev\">CSVFormat#withHeader doesn't work well with #printComment, add withHeaderComments(String...)</action>\n+      <action issue=\"CSV-128\" type=\"fix\" dev=\"ggregory\">CSVFormat.EXCEL should ignore empty header names</action>\n+      <action issue=\"CSV-132\" type=\"fix\" dev=\"ggregory\" due-to=\"Sascha Szott\">Incorrect Javadoc referencing org.apache.commons.csv.CSVFormat withQuote()</action>\n+      <action issue=\"CSV-124\" type=\"update\" dev=\"brentworden\" due-to=\"Kalyan\">Improve toString() implementation of CSVRecord</action>\n+      <action issue=\"CSV-134\" type=\"update\" dev=\"ggregory\" due-to=\"wu wen\">Unified parameter validation</action>\n+      <action issue=\"CSV-129\" type=\"add\" dev=\"ggregory\">Add CSVFormat#with 0-arg methods matching boolean arg methods</action>\n+      <action issue=\"CSV-131\" type=\"add\" dev=\"ggregory\" due-to=\"Holger Stratmann\">Save positions of records to enable random access</action>\n+      <action issue=\"CSV-139\" type=\"add\" dev=\"ggregory\">CSVPrinter.printRecord(ResultSet) with metadata</action>\n+    </release>\n+    <release version=\"1.0\" date=\"2014-08-14\" description=\"First release (Java 6 or above)\">\n+      <action issue=\"CSV-125\" type=\"fix\" dev=\"britter\">No longer works with Java 6</action>\n+      <action issue=\"CSV-122\" type=\"fix\" dev=\"britter\" due-to=\"Mike Lewis\">NullPointerException when empty header string and null string of \"\"</action>\n+      <action issue=\"CSV-117\" type=\"update\" dev=\"sebb\">Validate format parameters in constructor</action>\n+      <action issue=\"CSV-121\" type=\"add\" dev=\"ggregory\" due-to=\"Sebastian Hardt\">IllegalArgumentException thrown when the header contains duplicate names when the column names are empty.</action>\n+      <action issue=\"CSV-120\" type=\"add\" dev=\"ggregory\" due-to=\"Sergei Lebedev\">CSVFormat#withHeader doesn't work with CSVPrinter</action>\n+      <action issue=\"CSV-119\" type=\"add\" dev=\"ggregory\" due-to=\"Sergei Lebedev\">CSVFormat is missing a print(...) method</action>\n+      <action issue=\"CSV-118\" type=\"fix\" dev=\"ggregory\" due-to=\"Enrique Lara\">CSVRecord.toMap() throws NPE on formats with no\n+        headers.</action>\n+      <action issue=\"CSV-113\" type=\"fix\" dev=\"sebb\">Check whether ISE/IAE are being used appropriately</action>\n+      <action issue=\"CSV-114\" type=\"fix\" dev=\"sebb\">CSVFormat constructor should reject a header array with duplicate\n+        entries\n+      </action>\n+      <action issue=\"CSV-112\" type=\"fix\" dev=\"britter\">HeaderMap is inconsistent when it is parsed from an input with\n+        duplicate columns names\n+      </action>\n+      <action issue=\"CSV-111\" type=\"fix\" dev=\"ggregory\">CSVRecord.toMap() fails if row length shorter than header length\n+      </action>\n+      <action issue=\"CSV-106\" type=\"fix\" dev=\"ggregory\">CSVFormat.format allways append null</action>\n+      <action issue=\"CSV-105\" type=\"add\" dev=\"ggregory\">Add Map conversion API to CSVRecord</action>\n+      <action issue=\"CSV-100\" type=\"fix\" dev=\"ggregory\">CSVParser: getHeaderMap throws NPE</action>\n+      <action issue=\"CSV-42\" type=\"update\" dev=\"ebourg\" due-to=\"Bob Smith\">Lots of possible changes</action>\n+      <action issue=\"CSV-78\" type=\"update\" dev=\"sebb\">Use Character instead of char for char fields except delimiter\n+      </action>\n+      <action issue=\"CSV-99\" type=\"update\" dev=\"britter\">Revert Builder implementation in CSVFormat</action>\n+      <action issue=\"CSV-53\" type=\"fix\" dev=\"britter\">CSVRecord does not verify that the length of the header mapping\n+        matches the number of values\n+      </action>\n+      <action issue=\"CSV-93\" type=\"update\" dev=\"ggregory\">Allow the handling of NULL values</action>\n+      <action issue=\"CSV-68\" type=\"update\" dev=\"ggregory\">Use the Builder pattern for CSVFormat</action>\n+      <action issue=\"CSV-84\" type=\"update\" dev=\"sebb\">Clarify comment handling</action>\n+      <action issue=\"CSV-25\" type=\"update\" dev=\"ebourg\">CSVParser.nextValue() seems pointless</action>\n+      <action issue=\"CSV-97\" type=\"update\" dev=\"ggregory\">Allow the String value for null to be customized for the CSV\n+        printer\n+      </action>\n+      <action issue=\"CSV-88\" type=\"update\" dev=\"ggregory\">Not possible to create a CSVFormat from scratch</action>\n+      <action issue=\"CSV-52\" type=\"add\" dev=\"ggregory\">Keep track of record number</action>\n+      <action issue=\"CSV-94\" type=\"update\" dev=\"sebb\">Lexer should only use char fields</action>\n+      <action issue=\"CSV-92\" type=\"add\" dev=\"ggregory\">Need a way to extract parsed headers, e.g. for use in formatting\n+        output\n+      </action>\n+      <action issue=\"CSV-65\" type=\"add\" dev=\"ebourg\">Header support</action>\n+      <action issue=\"CSV-54\" type=\"fix\" dev=\"sebb\">Confusing semantic of the ignore leading/trailing spaces parameters\n+      </action>\n+      <action issue=\"CSV-71\" type=\"update\" dev=\"sebb\">Add convenience methods to CSVLexer</action>\n+      <action issue=\"CSV-59\" type=\"update\" dev=\"ebourg\">Is CharBuffer really needed, now that StringBuilder is available?\n+      </action>\n+      <action issue=\"CSV-55\" type=\"update\" dev=\"britter\">Replace while(true)-loop in CSVParser.getRecord with do-while-loop\n+      </action>\n+      <action issue=\"CSV-34\" type=\"fix\" dev=\"sebb\">CSVFormat describes itself as immutable, but it is not - in\n+        particular it is not thread-safe\n+      </action>\n+      <action issue=\"CSV-36\" type=\"fix\" dev=\"yonik\">Endless loops in CSV parser</action>\n+      <action issue=\"CSV-13\" type=\"fix\" dev=\"ebourg\">NullPointerException in CSVPrinter.print()/println()</action>\n+      <action issue=\"CSV-45\" type=\"update\" dev=\"yonik\">CSVPrinter overhaul</action>\n+      <action issue=\"CSV-23\" type=\"fix\" dev=\"ebourg\">Excel strategy uses wrong separator</action>\n+      <action issue=\"CSV-49\" type=\"update\" dev=\"ebourg\" due-to=\"Bob Smith\">CSVStrategy has modifiable public static variables\n+      </action>\n+      <action issue=\"CSV-48\" type=\"add\" dev=\"ebourg\">Predefined format for MYSQL</action>\n+      <action issue=\"CSV-46\" type=\"update\" dev=\"ebourg\">Reduce visibility of methods in internal classes</action>\n+      <action issue=\"CSV-26\" type=\"update\" dev=\"jacopoc\">ExtendedBufferedReader does too much</action>\n+      <action issue=\"CSV-27\" type=\"update\" dev=\"ebourg\">Decide whether to keep the csv.writer subpackage</action>\n+    </release>\n+\n+  </body>\n+</document>\ndiff --git a/src/main/java/org/apache/commons/csv/CSVPrinter.java b/src/main/java/org/apache/commons/csv/CSVPrinter.java\nindex dce94692..67088c38 100644\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n@@ -1,520 +1,520 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv;\r\n-\r\n-import static org.apache.commons.csv.Constants.CR;\r\n-import static org.apache.commons.csv.Constants.LF;\r\n-import static org.apache.commons.csv.Constants.SP;\r\n-\r\n-import java.io.Closeable;\r\n-import java.io.Flushable;\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.Reader;\r\n-import java.sql.Blob;\r\n-import java.sql.Clob;\r\n-import java.sql.ResultSet;\r\n-import java.sql.SQLException;\r\n-import java.util.Arrays;\r\n-import java.util.Objects;\r\n-import java.util.stream.Stream;\r\n-\r\n-import org.apache.commons.io.function.IOStream;\r\n-\r\n-/**\r\n- * Prints values in a {@link CSVFormat CSV format}.\r\n- *\r\n- * <p>Values can be appended to the output by calling the {@link #print(Object)} method.\r\n- * Values are printed according to {@link String#valueOf(Object)}.\r\n- * To complete a record the {@link #println()} method has to be called.\r\n- * Comments can be appended by calling {@link #printComment(String)}.\r\n- * However a comment will only be written to the output if the {@link CSVFormat} supports comments.\r\n- * </p>\r\n- *\r\n- * <p>The printer also supports appending a complete record at once by calling {@link #printRecord(Object...)}\r\n- * or {@link #printRecord(Iterable)}.\r\n- * Furthermore {@link #printRecords(Object...)}, {@link #printRecords(Iterable)} and {@link #printRecords(ResultSet)}\r\n- * methods can be used to print several records at once.\r\n- * </p>\r\n- *\r\n- * <p>Example:</p>\r\n- *\r\n- * <pre>\r\n- * try (CSVPrinter printer = new CSVPrinter(new FileWriter(\"csv.txt\"), CSVFormat.EXCEL)) {\r\n- *     printer.printRecord(\"id\", \"userName\", \"firstName\", \"lastName\", \"birthday\");\r\n- *     printer.printRecord(1, \"john73\", \"John\", \"Doe\", LocalDate.of(1973, 9, 15));\r\n- *     printer.println();\r\n- *     printer.printRecord(2, \"mary\", \"Mary\", \"Meyer\", LocalDate.of(1985, 3, 29));\r\n- * } catch (IOException ex) {\r\n- *     ex.printStackTrace();\r\n- * }\r\n- * </pre>\r\n- *\r\n- * <p>This code will write the following to csv.txt:</p>\r\n- * <pre>\r\n- * id,userName,firstName,lastName,birthday\r\n- * 1,john73,John,Doe,1973-09-15\r\n- *\r\n- * 2,mary,Mary,Meyer,1985-03-29\r\n- * </pre>\r\n- */\r\n-public final class CSVPrinter implements Flushable, Closeable {\r\n-\r\n-    /** The place that the values get written. */\r\n-    private final Appendable appendable;\r\n-\r\n-    private final CSVFormat format;\r\n-\r\n-    /** True if we just began a new record. */\r\n-    private boolean newRecord = true;\r\n-\r\n-    private long recordCount;\r\n-\r\n-    /**\r\n-     * Creates a printer that will print values to the given stream following the CSVFormat.\r\n-     * <p>\r\n-     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\r\n-     * and escaping with a different character) are not supported.\r\n-     * </p>\r\n-     *\r\n-     * @param appendable\r\n-     *            stream to which to print. Must not be null.\r\n-     * @param format\r\n-     *            the CSV format. Must not be null.\r\n-     * @throws IOException\r\n-     *             thrown if the optional header cannot be printed.\r\n-     * @throws IllegalArgumentException\r\n-     *             thrown if the parameters of the format are inconsistent or if either out or format are null.\r\n-     */\r\n-    public CSVPrinter(final Appendable appendable, final CSVFormat format) throws IOException {\r\n-        Objects.requireNonNull(appendable, \"appendable\");\r\n-        Objects.requireNonNull(format, \"format\");\r\n-\r\n-        this.appendable = appendable;\r\n-        this.format = format.copy();\r\n-        // TODO: Is it a good idea to do this here instead of on the first call to a print method?\r\n-        // It seems a pain to have to track whether the header has already been printed or not.\r\n-        final String[] headerComments = format.getHeaderComments();\r\n-        if (headerComments != null) {\r\n-            for (final String line : headerComments) {\r\n-                printComment(line);\r\n-            }\r\n-        }\r\n-        if (format.getHeader() != null && !format.getSkipHeaderRecord()) {\r\n-            this.printRecord((Object[]) format.getHeader());\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void close() throws IOException {\r\n-        close(false);\r\n-    }\r\n-\r\n-    /**\r\n-     * Closes the underlying stream with an optional flush first.\r\n-     * @param flush whether to flush before the actual close.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     * @since 1.6\r\n-     */\r\n-    public void close(final boolean flush) throws IOException {\r\n-        if (flush || format.getAutoFlush()) {\r\n-            flush();\r\n-        }\r\n-        if (appendable instanceof Closeable) {\r\n-            ((Closeable) appendable).close();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Outputs the record separator and increments the record count.\r\n-     *\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    private synchronized void endOfRecord() throws IOException {\r\n-        println();\r\n-        recordCount++;\r\n-    }\r\n-\r\n-    /**\r\n-     * Flushes the underlying stream.\r\n-     *\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    @Override\r\n-    public void flush() throws IOException {\r\n-        if (appendable instanceof Flushable) {\r\n-            ((Flushable) appendable).flush();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Gets the target Appendable.\r\n-     *\r\n-     * @return the target Appendable.\r\n-     */\r\n-    public Appendable getOut() {\r\n-        return this.appendable;\r\n-    }\r\n-\r\n-    /**\r\n-     * Gets the record count printed, this does not include comments or headers.\r\n-     *\r\n-     * @return the record count, this does not include comments or headers.\r\n-     * @since 1.13.0\r\n-     */\r\n-    public long getRecordCount() {\r\n-        return recordCount;\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\r\n-     *\r\n-     * @param value\r\n-     *            value to be output.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    public synchronized void print(final Object value) throws IOException {\r\n-        format.print(value, appendable, newRecord);\r\n-        newRecord = false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints a comment on a new line among the delimiter-separated values.\r\n-     *\r\n-     * <p>\r\n-     * Comments will always begin on a new line and occupy at least one full line. The character specified to start\r\n-     * comments and a space will be inserted at the beginning of each new line in the comment.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If comments are disabled in the current CSV format this method does nothing.\r\n-     * </p>\r\n-     *\r\n-     * <p>This method detects line breaks inside the comment string and inserts {@link CSVFormat#getRecordSeparator()}\r\n-     * to start a new line of the comment. Note that this might produce unexpected results for formats that do not use\r\n-     * line breaks as record separators.</p>\r\n-     *\r\n-     * @param comment\r\n-     *            the comment to output\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    public synchronized void printComment(final String comment) throws IOException {\r\n-        if (comment == null || !format.isCommentMarkerSet()) {\r\n-            return;\r\n-        }\r\n-        if (!newRecord) {\r\n-            println();\r\n-        }\r\n-        appendable.append(format.getCommentMarker().charValue()); // N.B. Explicit (un)boxing is intentional\r\n-        appendable.append(SP);\r\n-        for (int i = 0; i < comment.length(); i++) {\r\n-            final char c = comment.charAt(i);\r\n-            switch (c) {\r\n-            case CR:\r\n-                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\r\n-                    i++;\r\n-                }\r\n-                // falls-through: break intentionally excluded.\r\n-            case LF:\r\n-                println();\r\n-                appendable.append(format.getCommentMarker().charValue()); // N.B. Explicit (un)boxing is intentional\r\n-                appendable.append(SP);\r\n-                break;\r\n-            default:\r\n-                appendable.append(c);\r\n-                break;\r\n-            }\r\n-        }\r\n-        println();\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints headers for a result set based on its metadata.\r\n-     *\r\n-     * @param resultSet The ResultSet to query for metadata.\r\n-     * @throws IOException If an I/O error occurs.\r\n-     * @throws SQLException If a database access error occurs or this method is called on a closed result set.\r\n-     * @since 1.9.0\r\n-     */\r\n-    public synchronized void printHeaders(final ResultSet resultSet) throws IOException, SQLException {\r\n-        try (IOStream<String> stream = IOStream.of(format.builder().setHeader(resultSet).get().getHeader())) {\r\n-            stream.forEachOrdered(this::print);\r\n-        }\r\n-        println();\r\n-    }\r\n-\r\n-    /**\r\n-     * Outputs the record separator.\r\n-     *\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    public synchronized void println() throws IOException {\r\n-        format.println(appendable);\r\n-        newRecord = true;\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints the given values as a single record of delimiter-separated values followed by the record separator.\r\n-     *\r\n-     * <p>\r\n-     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\r\n-     * separator to the output after printing the record, so there is no need to call {@link #println()}.\r\n-     * </p>\r\n-     *\r\n-     * @param values\r\n-     *            values to output.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    @SuppressWarnings(\"resource\")\r\n-    public synchronized void printRecord(final Iterable<?> values) throws IOException {\r\n-        IOStream.of(values).forEachOrdered(this::print);\r\n-        endOfRecord();\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints the given values as a single record of delimiter-separated values followed by the record separator.\r\n-     *\r\n-     * <p>\r\n-     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\r\n-     * separator to the output after printing the record, so there is no need to call {@link #println()}.\r\n-     * </p>\r\n-     *\r\n-     * @param values\r\n-     *            values to output.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    public void printRecord(final Object... values) throws IOException {\r\n-        printRecord(Arrays.asList(values));\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints the given values as a single record of delimiter-separated values followed by the record separator.\r\n-     *\r\n-     * <p>\r\n-     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\r\n-     * separator to the output after printing the record, so there is no need to call {@link #println()}.\r\n-     * </p>\r\n-     *\r\n-     * @param values\r\n-     *            values to output.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     * @since 1.10.0\r\n-     */\r\n-    @SuppressWarnings(\"resource\") // caller closes.\r\n-    public synchronized void printRecord(final Stream<?> values) throws IOException {\r\n-        IOStream.adapt(values).forEachOrdered(this::print);\r\n-        endOfRecord();\r\n-    }\r\n-\r\n-    private void printRecordObject(final Object value) throws IOException {\r\n-        if (value instanceof Object[]) {\r\n-            this.printRecord((Object[]) value);\r\n-        } else if (value instanceof Iterable) {\r\n-            this.printRecord((Iterable<?>) value);\r\n-        } else {\r\n-            this.printRecord(value);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints all the objects in the given {@link Iterable} handling nested collections/arrays as records.\r\n-     *\r\n-     * <p>\r\n-     * If the given Iterable only contains simple objects, this method will print a single record like\r\n-     * {@link #printRecord(Iterable)}. If the given Iterable contains nested collections/arrays those nested elements\r\n-     * will each be printed as records using {@link #printRecord(Object...)}.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Given the following data structure:\r\n-     * </p>\r\n-     *\r\n-     * <pre>{@code\r\n-     * List<String[]> data = new ArrayList<>();\r\n-     * data.add(new String[]{ \"A\", \"B\", \"C\" });\r\n-     * data.add(new String[]{ \"1\", \"2\", \"3\" });\r\n-     * data.add(new String[]{ \"A1\", \"B2\", \"C3\" });\r\n-     * }\r\n-     * </pre>\r\n-     *\r\n-     * <p>\r\n-     * Calling this method will print:\r\n-     * </p>\r\n-     *\r\n-     * <pre>\r\n-     * {@code\r\n-     * A, B, C\r\n-     * 1, 2, 3\r\n-     * A1, B2, C3\r\n-     * }\r\n-     * </pre>\r\n-     *\r\n-     * @param values\r\n-     *            the values to print.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    @SuppressWarnings(\"resource\")\r\n-    public void printRecords(final Iterable<?> values) throws IOException {\r\n-        IOStream.of(values).forEachOrdered(this::printRecordObject);\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints all the objects in the given array handling nested collections/arrays as records.\r\n-     *\r\n-     * <p>\r\n-     * If the given array only contains simple objects, this method will print a single record like\r\n-     * {@link #printRecord(Object...)}. If the given collections contain nested collections or arrays, those nested\r\n-     * elements will each be printed as records using {@link #printRecord(Object...)}.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Given the following data structure:\r\n-     * </p>\r\n-     *\r\n-     * <pre>{@code\r\n-     * String[][] data = new String[3][]\r\n-     * data[0] = String[]{ \"A\", \"B\", \"C\" };\r\n-     * data[1] = new String[]{ \"1\", \"2\", \"3\" };\r\n-     * data[2] = new String[]{ \"A1\", \"B2\", \"C3\" };\r\n-     * }\r\n-     * </pre>\r\n-     *\r\n-     * <p>\r\n-     * Calling this method will print:\r\n-     * </p>\r\n-     *\r\n-     * <pre>{@code\r\n-     * A, B, C\r\n-     * 1, 2, 3\r\n-     * A1, B2, C3\r\n-     * }\r\n-     * </pre>\r\n-     *\r\n-     * @param values\r\n-     *            the values to print.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    public void printRecords(final Object... values) throws IOException {\r\n-        printRecords(Arrays.asList(values));\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints all the objects in the given JDBC result set.\r\n-     *\r\n-     * @param resultSet\r\n-     *             The values to print.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs.\r\n-     * @throws SQLException\r\n-     *             Thrown when a database access error occurs.\r\n-     */\r\n-    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\r\n-        final int columnCount = resultSet.getMetaData().getColumnCount();\r\n-        while (resultSet.next()) {\r\n-            for (int i = 1; i <= columnCount; i++) {\r\n-                final Object object = resultSet.getObject(i);\r\n-                if (object instanceof Clob) {\r\n-                    try (Reader reader = ((Clob) object).getCharacterStream()) {\r\n-                        print(reader);\r\n-                    }\r\n-                } else if (object instanceof Blob) {\r\n-                    try (InputStream inputStream = ((Blob) object).getBinaryStream()) {\r\n-                        print(inputStream);\r\n-                    }\r\n-                } else {\r\n-                    print(object);\r\n-                }\r\n-            }\r\n-            endOfRecord();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints all the objects with metadata in the given JDBC result set based on the header boolean.\r\n-     *\r\n-     * @param resultSet source of row data.\r\n-     * @param printHeader whether to print headers.\r\n-     * @throws IOException If an I/O error occurs\r\n-     * @throws SQLException if a database access error occurs\r\n-     * @since 1.9.0\r\n-     */\r\n-    public void printRecords(final ResultSet resultSet, final boolean printHeader) throws SQLException, IOException {\r\n-        if (printHeader) {\r\n-            printHeaders(resultSet);\r\n-        }\r\n-        printRecords(resultSet);\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints all the objects in the given {@link Stream} handling nested collections/arrays as records.\r\n-     *\r\n-     * <p>\r\n-     * If the given Stream only contains simple objects, this method will print a single record like\r\n-     * {@link #printRecord(Iterable)}. If the given Stream contains nested collections/arrays those nested elements\r\n-     * will each be printed as records using {@link #printRecord(Object...)}.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Given the following data structure:\r\n-     * </p>\r\n-     *\r\n-     * <pre>{@code\r\n-     * List<String[]> data = new ArrayList<>();\r\n-     * data.add(new String[]{ \"A\", \"B\", \"C\" });\r\n-     * data.add(new String[]{ \"1\", \"2\", \"3\" });\r\n-     * data.add(new String[]{ \"A1\", \"B2\", \"C3\" });\r\n-     * Stream<String[]> stream = data.stream();\r\n-     * }\r\n-     * </pre>\r\n-     *\r\n-     * <p>\r\n-     * Calling this method will print:\r\n-     * </p>\r\n-     *\r\n-     * <pre>\r\n-     * {@code\r\n-     * A, B, C\r\n-     * 1, 2, 3\r\n-     * A1, B2, C3\r\n-     * }\r\n-     * </pre>\r\n-     *\r\n-     * @param values\r\n-     *            the values to print.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     * @since 1.10.0\r\n-     */\r\n-    @SuppressWarnings({ \"resource\" }) // Caller closes.\r\n-    public void printRecords(final Stream<?> values) throws IOException {\r\n-        IOStream.adapt(values).forEachOrdered(this::printRecordObject);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import static org.apache.commons.csv.Constants.CR;\n+import static org.apache.commons.csv.Constants.LF;\n+import static org.apache.commons.csv.Constants.SP;\n+\n+import java.io.Closeable;\n+import java.io.Flushable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.function.IOStream;\n+\n+/**\n+ * Prints values in a {@link CSVFormat CSV format}.\n+ *\n+ * <p>Values can be appended to the output by calling the {@link #print(Object)} method.\n+ * Values are printed according to {@link String#valueOf(Object)}.\n+ * To complete a record the {@link #println()} method has to be called.\n+ * Comments can be appended by calling {@link #printComment(String)}.\n+ * However a comment will only be written to the output if the {@link CSVFormat} supports comments.\n+ * </p>\n+ *\n+ * <p>The printer also supports appending a complete record at once by calling {@link #printRecord(Object...)}\n+ * or {@link #printRecord(Iterable)}.\n+ * Furthermore {@link #printRecords(Object...)}, {@link #printRecords(Iterable)} and {@link #printRecords(ResultSet)}\n+ * methods can be used to print several records at once.\n+ * </p>\n+ *\n+ * <p>Example:</p>\n+ *\n+ * <pre>\n+ * try (CSVPrinter printer = new CSVPrinter(new FileWriter(\"csv.txt\"), CSVFormat.EXCEL)) {\n+ *     printer.printRecord(\"id\", \"userName\", \"firstName\", \"lastName\", \"birthday\");\n+ *     printer.printRecord(1, \"john73\", \"John\", \"Doe\", LocalDate.of(1973, 9, 15));\n+ *     printer.println();\n+ *     printer.printRecord(2, \"mary\", \"Mary\", \"Meyer\", LocalDate.of(1985, 3, 29));\n+ * } catch (IOException ex) {\n+ *     ex.printStackTrace();\n+ * }\n+ * </pre>\n+ *\n+ * <p>This code will write the following to csv.txt:</p>\n+ * <pre>\n+ * id,userName,firstName,lastName,birthday\n+ * 1,john73,John,Doe,1973-09-15\n+ *\n+ * 2,mary,Mary,Meyer,1985-03-29\n+ * </pre>\n+ */\n+public final class CSVPrinter implements Flushable, Closeable {\n+\n+    /** The place that the values get written. */\n+    private final Appendable appendable;\n+\n+    private final CSVFormat format;\n+\n+    /** True if we just began a new record. */\n+    private boolean newRecord = true;\n+\n+    private long recordCount;\n+\n+    /**\n+     * Creates a printer that will print values to the given stream following the CSVFormat.\n+     * <p>\n+     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\n+     * and escaping with a different character) are not supported.\n+     * </p>\n+     *\n+     * @param appendable\n+     *            stream to which to print. Must not be null.\n+     * @param format\n+     *            the CSV format. Must not be null.\n+     * @throws IOException\n+     *             thrown if the optional header cannot be printed.\n+     * @throws IllegalArgumentException\n+     *             thrown if the parameters of the format are inconsistent or if either out or format are null.\n+     */\n+    public CSVPrinter(final Appendable appendable, final CSVFormat format) throws IOException {\n+        Objects.requireNonNull(appendable, \"appendable\");\n+        Objects.requireNonNull(format, \"format\");\n+\n+        this.appendable = appendable;\n+        this.format = format.copy();\n+        // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n+        // It seems a pain to have to track whether the header has already been printed or not.\n+        final String[] headerComments = format.getHeaderComments();\n+        if (headerComments != null) {\n+            for (final String line : headerComments) {\n+                printComment(line);\n+            }\n+        }\n+        if (format.getHeader() != null && !format.getSkipHeaderRecord()) {\n+            this.printRecord((Object[]) format.getHeader());\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        close(false);\n+    }\n+\n+    /**\n+     * Closes the underlying stream with an optional flush first.\n+     * @param flush whether to flush before the actual close.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     * @since 1.6\n+     */\n+    public void close(final boolean flush) throws IOException {\n+        if (flush || format.getAutoFlush()) {\n+            flush();\n+        }\n+        if (appendable instanceof Closeable) {\n+            ((Closeable) appendable).close();\n+        }\n+    }\n+\n+    /**\n+     * Outputs the record separator and increments the record count.\n+     *\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    private synchronized void endOfRecord() throws IOException {\n+        println();\n+        recordCount++;\n+    }\n+\n+    /**\n+     * Flushes the underlying stream.\n+     *\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    @Override\n+    public void flush() throws IOException {\n+        if (appendable instanceof Flushable) {\n+            ((Flushable) appendable).flush();\n+        }\n+    }\n+\n+    /**\n+     * Gets the target Appendable.\n+     *\n+     * @return the target Appendable.\n+     */\n+    public Appendable getOut() {\n+        return this.appendable;\n+    }\n+\n+    /**\n+     * Gets the record count printed, this does not include comments or headers.\n+     *\n+     * @return the record count, this does not include comments or headers.\n+     * @since 1.13.0\n+     */\n+    public long getRecordCount() {\n+        return recordCount;\n+    }\n+\n+    /**\n+     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n+     *\n+     * @param value\n+     *            value to be output.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public synchronized void print(final Object value) throws IOException {\n+        format.print(value, appendable, newRecord);\n+        newRecord = false;\n+    }\n+\n+    /**\n+     * Prints a comment on a new line among the delimiter-separated values.\n+     *\n+     * <p>\n+     * Comments will always begin on a new line and occupy at least one full line. The character specified to start\n+     * comments and a space will be inserted at the beginning of each new line in the comment.\n+     * </p>\n+     *\n+     * <p>\n+     * If comments are disabled in the current CSV format this method does nothing.\n+     * </p>\n+     *\n+     * <p>This method detects line breaks inside the comment string and inserts {@link CSVFormat#getRecordSeparator()}\n+     * to start a new line of the comment. Note that this might produce unexpected results for formats that do not use\n+     * line breaks as record separators.</p>\n+     *\n+     * @param comment\n+     *            the comment to output\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public synchronized void printComment(final String comment) throws IOException {\n+        if (comment == null || !format.isCommentMarkerSet()) {\n+            return;\n+        }\n+        if (!newRecord) {\n+            println();\n+        }\n+        appendable.append(format.getCommentMarker().charValue()); // N.B. Explicit (un)boxing is intentional\n+        appendable.append(SP);\n+        for (int i = 0; i < comment.length(); i++) {\n+            final char c = comment.charAt(i);\n+            switch (c) {\n+            case CR:\n+                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n+                    i++;\n+                }\n+                // falls-through: break intentionally excluded.\n+            case LF:\n+                println();\n+                appendable.append(format.getCommentMarker().charValue()); // N.B. Explicit (un)boxing is intentional\n+                appendable.append(SP);\n+                break;\n+            default:\n+                appendable.append(c);\n+                break;\n+            }\n+        }\n+        println();\n+    }\n+\n+    /**\n+     * Prints headers for a result set based on its metadata.\n+     *\n+     * @param resultSet The ResultSet to query for metadata.\n+     * @throws IOException If an I/O error occurs.\n+     * @throws SQLException If a database access error occurs or this method is called on a closed result set.\n+     * @since 1.9.0\n+     */\n+    public synchronized void printHeaders(final ResultSet resultSet) throws IOException, SQLException {\n+        try (IOStream<String> stream = IOStream.of(format.builder().setHeader(resultSet).get().getHeader())) {\n+            stream.forEachOrdered(this::print);\n+        }\n+        println();\n+    }\n+\n+    /**\n+     * Outputs the record separator.\n+     *\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public synchronized void println() throws IOException {\n+        format.println(appendable);\n+        newRecord = true;\n+    }\n+\n+    /**\n+     * Prints the given values as a single record of delimiter-separated values followed by the record separator.\n+     *\n+     * <p>\n+     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n+     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n+     * </p>\n+     *\n+     * @param values\n+     *            values to output.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    @SuppressWarnings(\"resource\")\n+    public synchronized void printRecord(final Iterable<?> values) throws IOException {\n+        IOStream.of(values).forEachOrdered(this::print);\n+        endOfRecord();\n+    }\n+\n+    /**\n+     * Prints the given values as a single record of delimiter-separated values followed by the record separator.\n+     *\n+     * <p>\n+     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n+     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n+     * </p>\n+     *\n+     * @param values\n+     *            values to output.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public void printRecord(final Object... values) throws IOException {\n+        printRecord(Arrays.asList(values));\n+    }\n+\n+    /**\n+     * Prints the given values as a single record of delimiter-separated values followed by the record separator.\n+     *\n+     * <p>\n+     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n+     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n+     * </p>\n+     *\n+     * @param values\n+     *            values to output.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     * @since 1.10.0\n+     */\n+    @SuppressWarnings(\"resource\") // caller closes.\n+    public synchronized void printRecord(final Stream<?> values) throws IOException {\n+        IOStream.adapt(values).forEachOrdered(this::print);\n+        endOfRecord();\n+    }\n+\n+    private void printRecordObject(final Object value) throws IOException {\n+        if (value instanceof Object[]) {\n+            this.printRecord((Object[]) value);\n+        } else if (value instanceof Iterable) {\n+            this.printRecord((Iterable<?>) value);\n+        } else {\n+            this.printRecord(value);\n+        }\n+    }\n+\n+    /**\n+     * Prints all the objects in the given {@link Iterable} handling nested collections/arrays as records.\n+     *\n+     * <p>\n+     * If the given Iterable only contains simple objects, this method will print a single record like\n+     * {@link #printRecord(Iterable)}. If the given Iterable contains nested collections/arrays those nested elements\n+     * will each be printed as records using {@link #printRecord(Object...)}.\n+     * </p>\n+     *\n+     * <p>\n+     * Given the following data structure:\n+     * </p>\n+     *\n+     * <pre>{@code\n+     * List<String[]> data = new ArrayList<>();\n+     * data.add(new String[]{ \"A\", \"B\", \"C\" });\n+     * data.add(new String[]{ \"1\", \"2\", \"3\" });\n+     * data.add(new String[]{ \"A1\", \"B2\", \"C3\" });\n+     * }\n+     * </pre>\n+     *\n+     * <p>\n+     * Calling this method will print:\n+     * </p>\n+     *\n+     * <pre>\n+     * {@code\n+     * A, B, C\n+     * 1, 2, 3\n+     * A1, B2, C3\n+     * }\n+     * </pre>\n+     *\n+     * @param values\n+     *            the values to print.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    @SuppressWarnings(\"resource\")\n+    public void printRecords(final Iterable<?> values) throws IOException {\n+        IOStream.of(values).forEachOrdered(this::printRecordObject);\n+    }\n+\n+    /**\n+     * Prints all the objects in the given array handling nested collections/arrays as records.\n+     *\n+     * <p>\n+     * If the given array only contains simple objects, this method will print a single record like\n+     * {@link #printRecord(Object...)}. If the given collections contain nested collections or arrays, those nested\n+     * elements will each be printed as records using {@link #printRecord(Object...)}.\n+     * </p>\n+     *\n+     * <p>\n+     * Given the following data structure:\n+     * </p>\n+     *\n+     * <pre>{@code\n+     * String[][] data = new String[3][]\n+     * data[0] = String[]{ \"A\", \"B\", \"C\" };\n+     * data[1] = new String[]{ \"1\", \"2\", \"3\" };\n+     * data[2] = new String[]{ \"A1\", \"B2\", \"C3\" };\n+     * }\n+     * </pre>\n+     *\n+     * <p>\n+     * Calling this method will print:\n+     * </p>\n+     *\n+     * <pre>{@code\n+     * A, B, C\n+     * 1, 2, 3\n+     * A1, B2, C3\n+     * }\n+     * </pre>\n+     *\n+     * @param values\n+     *            the values to print.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public void printRecords(final Object... values) throws IOException {\n+        printRecords(Arrays.asList(values));\n+    }\n+\n+    /**\n+     * Prints all the objects in the given JDBC result set.\n+     *\n+     * @param resultSet\n+     *             The values to print.\n+     * @throws IOException\n+     *             If an I/O error occurs.\n+     * @throws SQLException\n+     *             Thrown when a database access error occurs.\n+     */\n+    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n+        final int columnCount = resultSet.getMetaData().getColumnCount();\n+        while (resultSet.next()) {\n+            for (int i = 1; i <= columnCount; i++) {\n+                final Object object = resultSet.getObject(i);\n+                if (object instanceof Clob) {\n+                    try (Reader reader = ((Clob) object).getCharacterStream()) {\n+                        print(reader);\n+                    }\n+                } else if (object instanceof Blob) {\n+                    try (InputStream inputStream = ((Blob) object).getBinaryStream()) {\n+                        print(inputStream);\n+                    }\n+                } else {\n+                    print(object);\n+                }\n+            }\n+            endOfRecord();\n+        }\n+    }\n+\n+    /**\n+     * Prints all the objects with metadata in the given JDBC result set based on the header boolean.\n+     *\n+     * @param resultSet source of row data.\n+     * @param printHeader whether to print headers.\n+     * @throws IOException If an I/O error occurs\n+     * @throws SQLException if a database access error occurs\n+     * @since 1.9.0\n+     */\n+    public void printRecords(final ResultSet resultSet, final boolean printHeader) throws SQLException, IOException {\n+        if (printHeader) {\n+            printHeaders(resultSet);\n+        }\n+        printRecords(resultSet);\n+    }\n+\n+    /**\n+     * Prints all the objects in the given {@link Stream} handling nested collections/arrays as records.\n+     *\n+     * <p>\n+     * If the given Stream only contains simple objects, this method will print a single record like\n+     * {@link #printRecord(Iterable)}. If the given Stream contains nested collections/arrays those nested elements\n+     * will each be printed as records using {@link #printRecord(Object...)}.\n+     * </p>\n+     *\n+     * <p>\n+     * Given the following data structure:\n+     * </p>\n+     *\n+     * <pre>{@code\n+     * List<String[]> data = new ArrayList<>();\n+     * data.add(new String[]{ \"A\", \"B\", \"C\" });\n+     * data.add(new String[]{ \"1\", \"2\", \"3\" });\n+     * data.add(new String[]{ \"A1\", \"B2\", \"C3\" });\n+     * Stream<String[]> stream = data.stream();\n+     * }\n+     * </pre>\n+     *\n+     * <p>\n+     * Calling this method will print:\n+     * </p>\n+     *\n+     * <pre>\n+     * {@code\n+     * A, B, C\n+     * 1, 2, 3\n+     * A1, B2, C3\n+     * }\n+     * </pre>\n+     *\n+     * @param values\n+     *            the values to print.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     * @since 1.10.0\n+     */\n+    @SuppressWarnings({ \"resource\" }) // Caller closes.\n+    public void printRecords(final Stream<?> values) throws IOException {\n+        IOStream.adapt(values).forEachOrdered(this::printRecordObject);\n+    }\n+}\ndiff --git a/src/main/java/org/apache/commons/csv/Constants.java b/src/main/java/org/apache/commons/csv/Constants.java\nindex 5f8a5cf4..e8557846 100644\n--- a/src/main/java/org/apache/commons/csv/Constants.java\n+++ b/src/main/java/org/apache/commons/csv/Constants.java\n@@ -1,90 +1,90 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv;\r\n-\r\n-/**\r\n- * Private constants to this package.\r\n- */\r\n-final class Constants {\r\n-\r\n-    static final char BACKSLASH = '\\\\';\r\n-\r\n-    static final char BACKSPACE = '\\b';\r\n-\r\n-    static final String COMMA = \",\";\r\n-\r\n-    /**\r\n-     * Starts a comment, the remainder of the line is the comment.\r\n-     */\r\n-    static final char COMMENT = '#';\r\n-\r\n-    static final char CR = '\\r';\r\n-\r\n-    /** RFC 4180 defines line breaks as CRLF */\r\n-    static final String CRLF = \"\\r\\n\";\r\n-\r\n-    static final Character DOUBLE_QUOTE_CHAR = Character.valueOf('\"');  // N.B. Explicit (un)boxing is intentional\r\n-\r\n-    static final String EMPTY = \"\";\r\n-\r\n-    static final String[] EMPTY_STRING_ARRAY = {};\r\n-\r\n-    static final char FF = '\\f';\r\n-\r\n-    static final char LF = '\\n';\r\n-\r\n-    /**\r\n-     * Unicode line separator.\r\n-     */\r\n-    static final String LINE_SEPARATOR = \"\\u2028\";\r\n-\r\n-    /**\r\n-     * Unicode next line.\r\n-     */\r\n-    static final String NEXT_LINE = \"\\u0085\";\r\n-\r\n-    /**\r\n-     * Unicode paragraph separator.\r\n-     */\r\n-    static final String PARAGRAPH_SEPARATOR = \"\\u2029\";\r\n-\r\n-    static final char PIPE = '|';\r\n-\r\n-    /** ASCII record separator */\r\n-    static final char RS = 30;\r\n-\r\n-    static final char SP = ' ';\r\n-\r\n-    static final String SQL_NULL_STRING = \"\\\\N\";\r\n-\r\n-    static final char TAB = '\\t';\r\n-\r\n-    /** Undefined state for the lookahead char */\r\n-    static final int UNDEFINED = -2;\r\n-\r\n-    /** ASCII unit separator */\r\n-    static final char US = 31;\r\n-\r\n-    /** No instances. */\r\n-    private Constants() {\r\n-        // noop\r\n-    }\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+/**\n+ * Private constants to this package.\n+ */\n+final class Constants {\n+\n+    static final char BACKSLASH = '\\\\';\n+\n+    static final char BACKSPACE = '\\b';\n+\n+    static final String COMMA = \",\";\n+\n+    /**\n+     * Starts a comment, the remainder of the line is the comment.\n+     */\n+    static final char COMMENT = '#';\n+\n+    static final char CR = '\\r';\n+\n+    /** RFC 4180 defines line breaks as CRLF */\n+    static final String CRLF = \"\\r\\n\";\n+\n+    static final Character DOUBLE_QUOTE_CHAR = Character.valueOf('\"');  // N.B. Explicit (un)boxing is intentional\n+\n+    static final String EMPTY = \"\";\n+\n+    static final String[] EMPTY_STRING_ARRAY = {};\n+\n+    static final char FF = '\\f';\n+\n+    static final char LF = '\\n';\n+\n+    /**\n+     * Unicode line separator.\n+     */\n+    static final String LINE_SEPARATOR = \"\\u2028\";\n+\n+    /**\n+     * Unicode next line.\n+     */\n+    static final String NEXT_LINE = \"\\u0085\";\n+\n+    /**\n+     * Unicode paragraph separator.\n+     */\n+    static final String PARAGRAPH_SEPARATOR = \"\\u2029\";\n+\n+    static final char PIPE = '|';\n+\n+    /** ASCII record separator */\n+    static final char RS = 30;\n+\n+    static final char SP = ' ';\n+\n+    static final String SQL_NULL_STRING = \"\\\\N\";\n+\n+    static final char TAB = '\\t';\n+\n+    /** Undefined state for the lookahead char */\n+    static final int UNDEFINED = -2;\n+\n+    /** ASCII unit separator */\n+    static final char US = 31;\n+\n+    /** No instances. */\n+    private Constants() {\n+        // noop\n+    }\n+\n+}\ndiff --git a/src/test/java/org/apache/commons/csv/CSVFormatTest.java b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\nindex 50dfd0f8..9677d8ec 100644\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n@@ -1,1533 +1,1533 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv;\r\n-\r\n-import static org.apache.commons.csv.CSVFormat.RFC4180;\r\n-import static org.apache.commons.csv.Constants.CR;\r\n-import static org.apache.commons.csv.Constants.CRLF;\r\n-import static org.apache.commons.csv.Constants.LF;\r\n-import static org.junit.jupiter.api.Assertions.assertArrayEquals;\r\n-import static org.junit.jupiter.api.Assertions.assertEquals;\r\n-import static org.junit.jupiter.api.Assertions.assertFalse;\r\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\r\n-import static org.junit.jupiter.api.Assertions.assertNotSame;\r\n-import static org.junit.jupiter.api.Assertions.assertNull;\r\n-import static org.junit.jupiter.api.Assertions.assertThrows;\r\n-import static org.junit.jupiter.api.Assertions.assertTrue;\r\n-import static org.junit.jupiter.api.Assertions.fail;\r\n-\r\n-import java.io.ByteArrayInputStream;\r\n-import java.io.ByteArrayOutputStream;\r\n-import java.io.IOException;\r\n-import java.io.ObjectInputStream;\r\n-import java.io.ObjectOutputStream;\r\n-import java.io.Reader;\r\n-import java.io.StringReader;\r\n-import java.lang.reflect.Method;\r\n-import java.lang.reflect.Modifier;\r\n-import java.sql.ResultSet;\r\n-import java.sql.SQLException;\r\n-import java.util.Arrays;\r\n-import java.util.Objects;\r\n-\r\n-import org.apache.commons.csv.CSVFormat.Builder;\r\n-import org.junit.jupiter.api.Assertions;\r\n-import org.junit.jupiter.api.Test;\r\n-\r\n-/**\r\n- * Tests {@link CSVFormat}.\r\n- */\r\n-public class CSVFormatTest {\r\n-\r\n-    public enum EmptyEnum {\r\n-        // empty enum.\r\n-    }\r\n-\r\n-    public enum Header {\r\n-        Name, Email, Phone\r\n-    }\r\n-\r\n-    private static void assertNotEquals(final Object right, final Object left) {\r\n-        Assertions.assertNotEquals(right, left);\r\n-        Assertions.assertNotEquals(left, right);\r\n-    }\r\n-\r\n-    private static CSVFormat copy(final CSVFormat format) {\r\n-        return format.builder().setDelimiter(format.getDelimiter()).get();\r\n-    }\r\n-\r\n-    private void assertNotEquals(final String name, final String type, final Object left, final Object right) {\r\n-        if (left.equals(right) || right.equals(left)) {\r\n-            fail(\"Objects must not compare equal for \" + name + \"(\" + type + \")\");\r\n-        }\r\n-        if (left.hashCode() == right.hashCode()) {\r\n-            fail(\"Hash code should not be equal for \" + name + \"(\" + type + \")\");\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testBuildVsGet() {\r\n-        final Builder builder = CSVFormat.DEFAULT.builder();\r\n-        assertNotSame(builder.get(), builder.build());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimiterEmptyStringThrowsException1() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter(\"\").get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testDelimiterSameAsCommentStartThrowsException_Deprecated() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter('!').withCommentMarker('!'));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimiterSameAsCommentStartThrowsException1() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter('!').setCommentMarker('!').get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testDelimiterSameAsEscapeThrowsException_Deprecated() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter('!').withEscape('!'));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimiterSameAsEscapeThrowsException1() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter('!').setEscape('!').get());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimiterSameAsRecordSeparatorThrowsException() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat(CR));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDuplicateHeaderElements() {\r\n-        final String[] header = { \"A\", \"A\" };\r\n-        final CSVFormat format = CSVFormat.DEFAULT.builder().setHeader(header).get();\r\n-        assertEquals(2, format.getHeader().length);\r\n-        assertArrayEquals(header, format.getHeader());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testDuplicateHeaderElements_Deprecated() {\r\n-        final String[] header = { \"A\", \"A\" };\r\n-        final CSVFormat format = CSVFormat.DEFAULT.withHeader(header);\r\n-        assertEquals(2, format.getHeader().length);\r\n-        assertArrayEquals(header, format.getHeader());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDuplicateHeaderElementsFalse() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(false).setHeader(\"A\", \"A\").get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testDuplicateHeaderElementsFalse_Deprecated() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withAllowDuplicateHeaderNames(false).withHeader(\"A\", \"A\"));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDuplicateHeaderElementsTrue() {\r\n-        CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(true).setHeader(\"A\", \"A\").get();\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testDuplicateHeaderElementsTrue_Deprecated() {\r\n-        CSVFormat.DEFAULT.withAllowDuplicateHeaderNames(true).withHeader(\"A\", \"A\");\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDuplicateHeaderElementsTrueContainsEmpty1() {\r\n-        CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(false).setHeader(\"A\", \"\", \"B\", \"\").get();\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDuplicateHeaderElementsTrueContainsEmpty2() {\r\n-        CSVFormat.DEFAULT.builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).setHeader(\"A\", \"\", \"B\", \"\").get();\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDuplicateHeaderElementsTrueContainsEmpty3() {\r\n-        CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(false).setAllowMissingColumnNames(true).setHeader(\"A\", \"\", \"B\", \"\").get();\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEquals() {\r\n-        final CSVFormat right = CSVFormat.DEFAULT;\r\n-        final CSVFormat left = copy(right);\r\n-        Assertions.assertNotEquals(null, right);\r\n-        Assertions.assertNotEquals(\"A String Instance\", right);\r\n-        assertEquals(right, right);\r\n-        assertEquals(right, left);\r\n-        assertEquals(left, right);\r\n-        assertEquals(right.hashCode(), right.hashCode());\r\n-        assertEquals(right.hashCode(), left.hashCode());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsCommentStart() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').setCommentMarker('#').setQuoteMode(QuoteMode.ALL).get();\r\n-        final CSVFormat left = right.builder().setCommentMarker('!').get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsCommentStart_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"').withCommentMarker('#').withQuoteMode(QuoteMode.ALL);\r\n-        final CSVFormat left = right.withCommentMarker('!');\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsDelimiter() {\r\n-        final CSVFormat right = CSVFormat.newFormat('!');\r\n-        final CSVFormat left = CSVFormat.newFormat('?');\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsEscape() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').setCommentMarker('#').setEscape('+').setQuoteMode(QuoteMode.ALL).get();\r\n-        final CSVFormat left = right.builder().setEscape('!').get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsEscape_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"').withCommentMarker('#').withEscape('+').withQuoteMode(QuoteMode.ALL);\r\n-        final CSVFormat left = right.withEscape('!');\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsHash() throws Exception {\r\n-        final Method[] methods = CSVFormat.class.getDeclaredMethods();\r\n-        for (final Method method : methods) {\r\n-            if (Modifier.isPublic(method.getModifiers())) {\r\n-                final String name = method.getName();\r\n-                if (name.startsWith(\"with\")) {\r\n-                    for (final Class<?> cls : method.getParameterTypes()) {\r\n-                        final String type = cls.getCanonicalName();\r\n-                        switch (type) {\r\n-                        case \"boolean\": {\r\n-                            final Object defTrue = method.invoke(CSVFormat.DEFAULT, Boolean.TRUE);\r\n-                            final Object defFalse = method.invoke(CSVFormat.DEFAULT, Boolean.FALSE);\r\n-                            assertNotEquals(name, type, defTrue, defFalse);\r\n-                            break;\r\n-                        }\r\n-                        case \"char\": {\r\n-                            final Object a = method.invoke(CSVFormat.DEFAULT, 'a');\r\n-                            final Object b = method.invoke(CSVFormat.DEFAULT, 'b');\r\n-                            assertNotEquals(name, type, a, b);\r\n-                            break;\r\n-                        }\r\n-                        case \"java.lang.Character\": {\r\n-                            final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { null });\r\n-                            final Object b = method.invoke(CSVFormat.DEFAULT, Character.valueOf('d'));\r\n-                            assertNotEquals(name, type, a, b);\r\n-                            break;\r\n-                        }\r\n-                        case \"java.lang.String\": {\r\n-                            final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { null });\r\n-                            final Object b = method.invoke(CSVFormat.DEFAULT, \"e\");\r\n-                            assertNotEquals(name, type, a, b);\r\n-                            break;\r\n-                        }\r\n-                        case \"java.lang.String[]\": {\r\n-                            final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { new String[] { null, null } });\r\n-                            final Object b = method.invoke(CSVFormat.DEFAULT, new Object[] { new String[] { \"f\", \"g\" } });\r\n-                            assertNotEquals(name, type, a, b);\r\n-                            break;\r\n-                        }\r\n-                        case \"org.apache.commons.csv.QuoteMode\": {\r\n-                            final Object a = method.invoke(CSVFormat.DEFAULT, QuoteMode.MINIMAL);\r\n-                            final Object b = method.invoke(CSVFormat.DEFAULT, QuoteMode.ALL);\r\n-                            assertNotEquals(name, type, a, b);\r\n-                            break;\r\n-                        }\r\n-                        case \"org.apache.commons.csv.DuplicateHeaderMode\": {\r\n-                            final Object a = method.invoke(CSVFormat.DEFAULT, DuplicateHeaderMode.ALLOW_ALL);\r\n-                            final Object b = method.invoke(CSVFormat.DEFAULT, DuplicateHeaderMode.DISALLOW);\r\n-                            assertNotEquals(name, type, a, b);\r\n-                            break;\r\n-                        }\r\n-                        case \"java.lang.Object[]\": {\r\n-                            final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { new Object[] { null, null } });\r\n-                            final Object b = method.invoke(CSVFormat.DEFAULT, new Object[] { new Object[] { new Object(), new Object() } });\r\n-                            assertNotEquals(name, type, a, b);\r\n-                            break;\r\n-                        }\r\n-                        default:\r\n-                            if (\"withHeader\".equals(name)) { // covered above by String[]\r\n-                                // ignored\r\n-                            } else {\r\n-                                fail(\"Unhandled method: \" + name + \"(\" + type + \")\");\r\n-                            }\r\n-                            break;\r\n-                        }\r\n-                    }\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsHeader() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setHeader(\"One\", \"Two\", \"Three\")\r\n-                .setIgnoreEmptyLines(true).setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\r\n-        final CSVFormat left = right.builder().setHeader(\"Three\", \"Two\", \"One\").get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsHeader_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withHeader(\"One\", \"Two\", \"Three\")\r\n-                .withIgnoreEmptyLines().withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL);\r\n-        final CSVFormat left = right.withHeader(\"Three\", \"Two\", \"One\");\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsIgnoreEmptyLines() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true)\r\n-                .setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\r\n-        final CSVFormat left = right.builder().setIgnoreEmptyLines(false).get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsIgnoreEmptyLines_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withCommentMarker('#').withEscape('+').withIgnoreEmptyLines().withIgnoreSurroundingSpaces()\r\n-                .withQuote('\"').withQuoteMode(QuoteMode.ALL);\r\n-        final CSVFormat left = right.withIgnoreEmptyLines(false);\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsIgnoreSurroundingSpaces() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setCommentMarker('#').setEscape('+').setIgnoreSurroundingSpaces(true).setQuote('\"')\r\n-                .setQuoteMode(QuoteMode.ALL).get();\r\n-        final CSVFormat left = right.builder().setIgnoreSurroundingSpaces(false).get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsIgnoreSurroundingSpaces_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withCommentMarker('#').withEscape('+').withIgnoreSurroundingSpaces().withQuote('\"')\r\n-                .withQuoteMode(QuoteMode.ALL);\r\n-        final CSVFormat left = right.withIgnoreSurroundingSpaces(false);\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsLeftNoQuoteRightQuote() {\r\n-        final CSVFormat left = CSVFormat.newFormat(',').builder().setQuote(null).get();\r\n-        final CSVFormat right = left.builder().setQuote('#').get();\r\n-\r\n-        assertNotEquals(left, right);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsLeftNoQuoteRightQuote_Deprecated() {\r\n-        final CSVFormat left = CSVFormat.newFormat(',').withQuote(null);\r\n-        final CSVFormat right = left.withQuote('#');\r\n-\r\n-        assertNotEquals(left, right);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsNoQuotes() {\r\n-        final CSVFormat left = CSVFormat.newFormat(',').builder().setQuote(null).get();\r\n-        final CSVFormat right = left.builder().setQuote(null).get();\r\n-\r\n-        assertEquals(left, right);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsNoQuotes_Deprecated() {\r\n-        final CSVFormat left = CSVFormat.newFormat(',').withQuote(null);\r\n-        final CSVFormat right = left.withQuote(null);\r\n-\r\n-        assertEquals(left, right);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsNullString() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true)\r\n-                .setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).setNullString(\"null\").get();\r\n-        final CSVFormat left = right.builder().setNullString(\"---\").get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsNullString_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withIgnoreEmptyLines()\r\n-                .withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL).withNullString(\"null\");\r\n-        final CSVFormat left = right.withNullString(\"---\");\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsOne() {\r\n-\r\n-        final CSVFormat csvFormatOne = CSVFormat.INFORMIX_UNLOAD;\r\n-        final CSVFormat csvFormatTwo = CSVFormat.MYSQL;\r\n-\r\n-        assertEquals('\\\\', (char) csvFormatOne.getEscapeCharacter());\r\n-        assertEquals('\\\\', csvFormatOne.getEscapeChar());\r\n-        assertNull(csvFormatOne.getQuoteMode());\r\n-\r\n-        assertTrue(csvFormatOne.getIgnoreEmptyLines());\r\n-        assertFalse(csvFormatOne.getSkipHeaderRecord());\r\n-\r\n-        assertFalse(csvFormatOne.getIgnoreHeaderCase());\r\n-        assertNull(csvFormatOne.getCommentMarker());\r\n-\r\n-        assertFalse(csvFormatOne.isCommentMarkerSet());\r\n-        assertTrue(csvFormatOne.isQuoteCharacterSet());\r\n-\r\n-        assertEquals('|', csvFormatOne.getDelimiter());\r\n-        assertFalse(csvFormatOne.getAllowMissingColumnNames());\r\n-\r\n-        assertTrue(csvFormatOne.isEscapeCharacterSet());\r\n-        assertEquals(\"\\n\", csvFormatOne.getRecordSeparator());\r\n-\r\n-        assertEquals('\\\"', (char) csvFormatOne.getQuoteCharacter());\r\n-        assertFalse(csvFormatOne.getTrailingDelimiter());\r\n-\r\n-        assertFalse(csvFormatOne.getTrim());\r\n-        assertFalse(csvFormatOne.isNullStringSet());\r\n-\r\n-        assertNull(csvFormatOne.getNullString());\r\n-        assertFalse(csvFormatOne.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertTrue(csvFormatTwo.isEscapeCharacterSet());\r\n-        assertNull(csvFormatTwo.getQuoteCharacter());\r\n-\r\n-        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n-        assertEquals(QuoteMode.ALL_NON_NULL, csvFormatTwo.getQuoteMode());\r\n-\r\n-        assertEquals('\\t', csvFormatTwo.getDelimiter());\r\n-        assertArrayEquals(new char[] { '\\t' }, csvFormatTwo.getDelimiterCharArray());\r\n-        assertEquals(\"\\t\", csvFormatTwo.getDelimiterString());\r\n-        assertEquals(\"\\n\", csvFormatTwo.getRecordSeparator());\r\n-\r\n-        assertFalse(csvFormatTwo.isQuoteCharacterSet());\r\n-        assertTrue(csvFormatTwo.isNullStringSet());\r\n-\r\n-        assertEquals('\\\\', (char) csvFormatTwo.getEscapeCharacter());\r\n-        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n-\r\n-        assertFalse(csvFormatTwo.getTrim());\r\n-        assertFalse(csvFormatTwo.getIgnoreEmptyLines());\r\n-\r\n-        assertEquals(\"\\\\N\", csvFormatTwo.getNullString());\r\n-        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n-        assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n-\r\n-        assertNull(csvFormatTwo.getCommentMarker());\r\n-        assertFalse(csvFormatTwo.isCommentMarkerSet());\r\n-\r\n-        assertNotSame(csvFormatTwo, csvFormatOne);\r\n-        Assertions.assertNotEquals(csvFormatTwo, csvFormatOne);\r\n-\r\n-        assertEquals('\\\\', (char) csvFormatOne.getEscapeCharacter());\r\n-        assertNull(csvFormatOne.getQuoteMode());\r\n-\r\n-        assertTrue(csvFormatOne.getIgnoreEmptyLines());\r\n-        assertFalse(csvFormatOne.getSkipHeaderRecord());\r\n-\r\n-        assertFalse(csvFormatOne.getIgnoreHeaderCase());\r\n-        assertNull(csvFormatOne.getCommentMarker());\r\n-\r\n-        assertFalse(csvFormatOne.isCommentMarkerSet());\r\n-        assertTrue(csvFormatOne.isQuoteCharacterSet());\r\n-\r\n-        assertEquals('|', csvFormatOne.getDelimiter());\r\n-        assertFalse(csvFormatOne.getAllowMissingColumnNames());\r\n-\r\n-        assertTrue(csvFormatOne.isEscapeCharacterSet());\r\n-        assertEquals(\"\\n\", csvFormatOne.getRecordSeparator());\r\n-\r\n-        assertEquals('\\\"', (char) csvFormatOne.getQuoteCharacter());\r\n-        assertFalse(csvFormatOne.getTrailingDelimiter());\r\n-\r\n-        assertFalse(csvFormatOne.getTrim());\r\n-        assertFalse(csvFormatOne.isNullStringSet());\r\n-\r\n-        assertNull(csvFormatOne.getNullString());\r\n-        assertFalse(csvFormatOne.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertTrue(csvFormatTwo.isEscapeCharacterSet());\r\n-        assertNull(csvFormatTwo.getQuoteCharacter());\r\n-\r\n-        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n-        assertEquals(QuoteMode.ALL_NON_NULL, csvFormatTwo.getQuoteMode());\r\n-\r\n-        assertEquals('\\t', csvFormatTwo.getDelimiter());\r\n-        assertEquals(\"\\n\", csvFormatTwo.getRecordSeparator());\r\n-\r\n-        assertFalse(csvFormatTwo.isQuoteCharacterSet());\r\n-        assertTrue(csvFormatTwo.isNullStringSet());\r\n-\r\n-        assertEquals('\\\\', (char) csvFormatTwo.getEscapeCharacter());\r\n-        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n-\r\n-        assertFalse(csvFormatTwo.getTrim());\r\n-        assertFalse(csvFormatTwo.getIgnoreEmptyLines());\r\n-\r\n-        assertEquals(\"\\\\N\", csvFormatTwo.getNullString());\r\n-        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n-        assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n-\r\n-        assertNull(csvFormatTwo.getCommentMarker());\r\n-        assertFalse(csvFormatTwo.isCommentMarkerSet());\r\n-\r\n-        assertNotSame(csvFormatOne, csvFormatTwo);\r\n-        assertNotSame(csvFormatTwo, csvFormatOne);\r\n-\r\n-        Assertions.assertNotEquals(csvFormatOne, csvFormatTwo);\r\n-        Assertions.assertNotEquals(csvFormatTwo, csvFormatOne);\r\n-\r\n-        Assertions.assertNotEquals(csvFormatTwo, csvFormatOne);\r\n-\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsQuoteChar() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').get();\r\n-        final CSVFormat left = right.builder().setQuote('!').get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsQuoteChar_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"');\r\n-        final CSVFormat left = right.withQuote('!');\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsQuotePolicy() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\r\n-        final CSVFormat left = right.builder().setQuoteMode(QuoteMode.MINIMAL).get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsQuotePolicy_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"').withQuoteMode(QuoteMode.ALL);\r\n-        final CSVFormat left = right.withQuoteMode(QuoteMode.MINIMAL);\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsRecordSeparator() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true)\r\n-                .setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\r\n-        final CSVFormat left = right.builder().setRecordSeparator(LF).get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsRecordSeparator_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withIgnoreEmptyLines()\r\n-                .withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL);\r\n-        final CSVFormat left = right.withRecordSeparator(LF);\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    public void testEqualsSkipHeaderRecord() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true)\r\n-                .setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).setNullString(\"null\").setSkipHeaderRecord(true).get();\r\n-        final CSVFormat left = right.builder().setSkipHeaderRecord(false).get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsSkipHeaderRecord_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withIgnoreEmptyLines()\r\n-                .withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL).withNullString(\"null\").withSkipHeaderRecord();\r\n-        final CSVFormat left = right.withSkipHeaderRecord(false);\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsWithNull() {\r\n-\r\n-        final CSVFormat csvFormat = CSVFormat.POSTGRESQL_TEXT;\r\n-\r\n-        assertEquals('\\\\', (char) csvFormat.getEscapeCharacter());\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-        assertFalse(csvFormat.getTrim());\r\n-\r\n-        assertFalse(csvFormat.isQuoteCharacterSet());\r\n-        assertEquals(\"\\\\N\", csvFormat.getNullString());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertTrue(csvFormat.isEscapeCharacterSet());\r\n-\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-        assertEquals(QuoteMode.ALL_NON_NULL, csvFormat.getQuoteMode());\r\n-\r\n-        assertEquals('\\t', csvFormat.getDelimiter());\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-\r\n-        assertEquals(\"\\n\", csvFormat.getRecordSeparator());\r\n-        assertFalse(csvFormat.getIgnoreEmptyLines());\r\n-\r\n-        assertNull(csvFormat.getQuoteCharacter());\r\n-        assertTrue(csvFormat.isNullStringSet());\r\n-\r\n-        assertEquals('\\\\', (char) csvFormat.getEscapeCharacter());\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-        assertFalse(csvFormat.getTrim());\r\n-\r\n-        assertFalse(csvFormat.isQuoteCharacterSet());\r\n-        assertEquals(\"\\\\N\", csvFormat.getNullString());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertTrue(csvFormat.isEscapeCharacterSet());\r\n-\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-        assertEquals(QuoteMode.ALL_NON_NULL, csvFormat.getQuoteMode());\r\n-\r\n-        assertEquals('\\t', csvFormat.getDelimiter());\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-\r\n-        assertEquals(\"\\n\", csvFormat.getRecordSeparator());\r\n-        assertFalse(csvFormat.getIgnoreEmptyLines());\r\n-\r\n-        assertNull(csvFormat.getQuoteCharacter());\r\n-        assertTrue(csvFormat.isNullStringSet());\r\n-\r\n-        Assertions.assertNotEquals(null, csvFormat);\r\n-\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeSameAsCommentStartThrowsException() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setEscape('!').setCommentMarker('!').get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEscapeSameAsCommentStartThrowsException_Deprecated() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withEscape('!').withCommentMarker('!'));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeSameAsCommentStartThrowsExceptionForWrapperType() {\r\n-        // Cannot assume that callers won't use different Character objects\r\n-        assertThrows(IllegalArgumentException.class,\r\n-                () -> CSVFormat.DEFAULT.builder().setEscape(Character.valueOf('!')).setCommentMarker(Character.valueOf('!')).get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEscapeSameAsCommentStartThrowsExceptionForWrapperType_Deprecated() {\r\n-        // Cannot assume that callers won't use different Character objects\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withEscape(Character.valueOf('!')).withCommentMarker(Character.valueOf('!')));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testFormat() {\r\n-        final CSVFormat format = CSVFormat.DEFAULT;\r\n-\r\n-        assertEquals(\"\", format.format());\r\n-        assertEquals(\"a,b,c\", format.format(\"a\", \"b\", \"c\"));\r\n-        assertEquals(\"\\\"x,y\\\",z\", format.format(\"x,y\", \"z\"));\r\n-    }\r\n-\r\n-    @Test // I assume this to be a defect.\r\n-    public void testFormatThrowsNullPointerException() {\r\n-\r\n-        final CSVFormat csvFormat = CSVFormat.MYSQL;\r\n-\r\n-        final NullPointerException e = assertThrows(NullPointerException.class, () -> csvFormat.format((Object[]) null));\r\n-        assertEquals(Objects.class.getName(), e.getStackTrace()[0].getClassName());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testFormatToString() {\r\n-        // @formatter:off\r\n-        final CSVFormat format = CSVFormat.RFC4180\r\n-                .withEscape('?')\r\n-                .withDelimiter(',')\r\n-                .withQuoteMode(QuoteMode.MINIMAL)\r\n-                .withRecordSeparator(CRLF)\r\n-                .withQuote('\"')\r\n-                .withNullString(\"\")\r\n-                .withIgnoreHeaderCase(true)\r\n-                .withHeaderComments(\"This is HeaderComments\")\r\n-                .withHeader(\"col1\", \"col2\", \"col3\");\r\n-        // @formatter:on\r\n-        assertEquals(\r\n-                \"Delimiter=<,> Escape=<?> QuoteChar=<\\\"> QuoteMode=<MINIMAL> NullString=<> RecordSeparator=<\" + CRLF +\r\n-                        \"> IgnoreHeaderCase:ignored SkipHeaderRecord:false HeaderComments:[This is HeaderComments] Header:[col1, col2, col3]\",\r\n-                format.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetAllowDuplicateHeaderNames() {\r\n-        final Builder builder = CSVFormat.DEFAULT.builder();\r\n-        assertTrue(builder.get().getAllowDuplicateHeaderNames());\r\n-        assertTrue(builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).get().getAllowDuplicateHeaderNames());\r\n-        assertFalse(builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).get().getAllowDuplicateHeaderNames());\r\n-        assertFalse(builder.setDuplicateHeaderMode(DuplicateHeaderMode.DISALLOW).get().getAllowDuplicateHeaderNames());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetDuplicateHeaderMode() {\r\n-        final Builder builder = CSVFormat.DEFAULT.builder();\r\n-\r\n-        assertEquals(DuplicateHeaderMode.ALLOW_ALL, builder.get().getDuplicateHeaderMode());\r\n-        assertEquals(DuplicateHeaderMode.ALLOW_ALL, builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).get().getDuplicateHeaderMode());\r\n-        assertEquals(DuplicateHeaderMode.ALLOW_EMPTY, builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).get().getDuplicateHeaderMode());\r\n-        assertEquals(DuplicateHeaderMode.DISALLOW, builder.setDuplicateHeaderMode(DuplicateHeaderMode.DISALLOW).get().getDuplicateHeaderMode());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeader() {\r\n-        final String[] header = { \"one\", \"two\", \"three\" };\r\n-        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(header);\r\n-        // getHeader() makes a copy of the header array.\r\n-        final String[] headerCopy = formatWithHeader.getHeader();\r\n-        headerCopy[0] = \"A\";\r\n-        headerCopy[1] = \"B\";\r\n-        headerCopy[2] = \"C\";\r\n-        assertFalse(Arrays.equals(formatWithHeader.getHeader(), headerCopy));\r\n-        assertNotSame(formatWithHeader.getHeader(), headerCopy);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHashCodeAndWithIgnoreHeaderCase() {\r\n-\r\n-        final CSVFormat csvFormat = CSVFormat.INFORMIX_UNLOAD_CSV;\r\n-        final CSVFormat csvFormatTwo = csvFormat.withIgnoreHeaderCase();\r\n-        csvFormatTwo.hashCode();\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertTrue(csvFormatTwo.getIgnoreHeaderCase()); // now different\r\n-        assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n-\r\n-        Assertions.assertNotEquals(csvFormatTwo, csvFormat); // CSV-244 - should not be equal\r\n-        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n-\r\n-        assertFalse(csvFormatTwo.getTrim());\r\n-\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testJiraCsv236() {\r\n-        CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(true).setHeader(\"CC\", \"VV\", \"VV\").get();\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testJiraCsv236__Deprecated() {\r\n-        CSVFormat.DEFAULT.withAllowDuplicateHeaderNames().withHeader(\"CC\", \"VV\", \"VV\");\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNewFormat() {\r\n-\r\n-        final CSVFormat csvFormat = CSVFormat.newFormat('X');\r\n-\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-        assertFalse(csvFormat.isEscapeCharacterSet());\r\n-\r\n-        assertNull(csvFormat.getRecordSeparator());\r\n-        assertNull(csvFormat.getQuoteMode());\r\n-\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-        assertFalse(csvFormat.getTrim());\r\n-\r\n-        assertFalse(csvFormat.isNullStringSet());\r\n-        assertNull(csvFormat.getEscapeCharacter());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-\r\n-        assertEquals('X', csvFormat.getDelimiter());\r\n-        assertNull(csvFormat.getNullString());\r\n-\r\n-        assertFalse(csvFormat.isQuoteCharacterSet());\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-\r\n-        assertNull(csvFormat.getQuoteCharacter());\r\n-        assertFalse(csvFormat.getIgnoreEmptyLines());\r\n-\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-        assertFalse(csvFormat.isEscapeCharacterSet());\r\n-\r\n-        assertNull(csvFormat.getRecordSeparator());\r\n-        assertNull(csvFormat.getQuoteMode());\r\n-\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-        assertFalse(csvFormat.getTrim());\r\n-\r\n-        assertFalse(csvFormat.isNullStringSet());\r\n-        assertNull(csvFormat.getEscapeCharacter());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-\r\n-        assertEquals('X', csvFormat.getDelimiter());\r\n-        assertNull(csvFormat.getNullString());\r\n-\r\n-        assertFalse(csvFormat.isQuoteCharacterSet());\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-\r\n-        assertNull(csvFormat.getQuoteCharacter());\r\n-        assertFalse(csvFormat.getIgnoreEmptyLines());\r\n-\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNullRecordSeparatorCsv106() {\r\n-        final CSVFormat format = CSVFormat.newFormat(';').builder().setSkipHeaderRecord(true).setHeader(\"H1\", \"H2\").get();\r\n-        final String formatStr = format.format(\"A\", \"B\");\r\n-        assertNotNull(formatStr);\r\n-        assertFalse(formatStr.endsWith(\"null\"));\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testNullRecordSeparatorCsv106__Deprecated() {\r\n-        final CSVFormat format = CSVFormat.newFormat(';').withSkipHeaderRecord().withHeader(\"H1\", \"H2\");\r\n-        final String formatStr = format.format(\"A\", \"B\");\r\n-        assertNotNull(formatStr);\r\n-        assertFalse(formatStr.endsWith(\"null\"));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintRecord() throws IOException {\r\n-        final Appendable out = new StringBuilder();\r\n-        final CSVFormat format = CSVFormat.RFC4180;\r\n-        format.printRecord(out, \"a\", \"b\", \"c\");\r\n-        assertEquals(\"a,b,c\" + format.getRecordSeparator(), out.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintRecordEmpty() throws IOException {\r\n-        final Appendable out = new StringBuilder();\r\n-        final CSVFormat format = CSVFormat.RFC4180;\r\n-        format.printRecord(out);\r\n-        assertEquals(format.getRecordSeparator(), out.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintWithEscapesEndWithCRLF() throws IOException {\r\n-        final Reader in = new StringReader(\"x,y,x\\r\\na,?b,c\\r\\n\");\r\n-        final Appendable out = new StringBuilder();\r\n-        final CSVFormat format = CSVFormat.RFC4180.withEscape('?').withDelimiter(',').withQuote(null).withRecordSeparator(CRLF);\r\n-        format.print(in, out, true);\r\n-        assertEquals(\"x?,y?,x?r?na?,??b?,c?r?n\", out.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintWithEscapesEndWithoutCRLF() throws IOException {\r\n-        final Reader in = new StringReader(\"x,y,x\");\r\n-        final Appendable out = new StringBuilder();\r\n-        final CSVFormat format = CSVFormat.RFC4180.withEscape('?').withDelimiter(',').withQuote(null).withRecordSeparator(CRLF);\r\n-        format.print(in, out, true);\r\n-        assertEquals(\"x?,y?,x\", out.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintWithoutQuotes() throws IOException {\r\n-        final Reader in = new StringReader(\"\");\r\n-        final Appendable out = new StringBuilder();\r\n-        final CSVFormat format = CSVFormat.RFC4180.withDelimiter(',').withQuote('\"').withEscape('?').withQuoteMode(QuoteMode.NON_NUMERIC);\r\n-        format.print(in, out, true);\r\n-        assertEquals(\"\\\"\\\"\", out.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintWithQuoteModeIsNONE() throws IOException {\r\n-        final Reader in = new StringReader(\"a,b,c\");\r\n-        final Appendable out = new StringBuilder();\r\n-        final CSVFormat format = CSVFormat.RFC4180.withDelimiter(',').withQuote('\"').withEscape('?').withQuoteMode(QuoteMode.NONE);\r\n-        format.print(in, out, true);\r\n-        assertEquals(\"a?,b?,c\", out.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintWithQuotes() throws IOException {\r\n-        final Reader in = new StringReader(\"\\\"a,b,c\\r\\nx,y,z\");\r\n-        final Appendable out = new StringBuilder();\r\n-        final CSVFormat format = CSVFormat.RFC4180.withDelimiter(',').withQuote('\"').withEscape('?').withQuoteMode(QuoteMode.NON_NUMERIC);\r\n-        format.print(in, out, true);\r\n-        assertEquals(\"\\\"\\\"\\\"a,b,c\\r\\nx,y,z\\\"\", out.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testQuoteCharSameAsCommentStartThrowsException() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setQuote('!').setCommentMarker('!').get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testQuoteCharSameAsCommentStartThrowsException_Deprecated() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote('!').withCommentMarker('!'));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType() {\r\n-        // Cannot assume that callers won't use different Character objects\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setQuote(Character.valueOf('!')).setCommentMarker('!').get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType_Deprecated() {\r\n-        // Cannot assume that callers won't use different Character objects\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote(Character.valueOf('!')).withCommentMarker('!'));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testQuoteCharSameAsDelimiterThrowsException() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setQuote('!').setDelimiter('!').get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testQuoteCharSameAsDelimiterThrowsException_Deprecated() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote('!').withDelimiter('!'));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testQuoteModeNoneShouldReturnMeaningfulExceptionMessage() {\r\n-        final Exception exception = assertThrows(IllegalArgumentException.class, () ->\r\n-        // @formatter:off\r\n-            CSVFormat.DEFAULT.builder()\r\n-                    .setHeader(\"Col1\", \"Col2\", \"Col3\", \"Col4\")\r\n-                    .setQuoteMode(QuoteMode.NONE)\r\n-                    .get()\r\n-        // @formatter:on\r\n-        );\r\n-        final String actualMessage = exception.getMessage();\r\n-        final String expectedMessage = \"Quote mode set to NONE but no escape character is set\";\r\n-        assertEquals(expectedMessage, actualMessage);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testQuotePolicyNoneWithoutEscapeThrowsException() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat('!').builder().setQuoteMode(QuoteMode.NONE).get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testQuotePolicyNoneWithoutEscapeThrowsException_Deprecated() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat('!').withQuoteMode(QuoteMode.NONE));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRFC4180() {\r\n-        assertNull(RFC4180.getCommentMarker());\r\n-        assertEquals(',', RFC4180.getDelimiter());\r\n-        assertNull(RFC4180.getEscapeCharacter());\r\n-        assertFalse(RFC4180.getIgnoreEmptyLines());\r\n-        assertEquals(Character.valueOf('\"'), RFC4180.getQuoteCharacter());\r\n-        assertNull(RFC4180.getQuoteMode());\r\n-        assertEquals(\"\\r\\n\", RFC4180.getRecordSeparator());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"boxing\") // no need to worry about boxing here\r\n-    @Test\r\n-    public void testSerialization() throws Exception {\r\n-        final ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n-\r\n-        try (ObjectOutputStream oos = new ObjectOutputStream(out)) {\r\n-            oos.writeObject(CSVFormat.DEFAULT);\r\n-            oos.flush();\r\n-        }\r\n-\r\n-        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\r\n-        final CSVFormat format = (CSVFormat) in.readObject();\r\n-\r\n-        assertNotNull(format);\r\n-        assertEquals(CSVFormat.DEFAULT.getDelimiter(), format.getDelimiter(), \"delimiter\");\r\n-        assertEquals(CSVFormat.DEFAULT.getQuoteCharacter(), format.getQuoteCharacter(), \"encapsulator\");\r\n-        assertEquals(CSVFormat.DEFAULT.getCommentMarker(), format.getCommentMarker(), \"comment start\");\r\n-        assertEquals(CSVFormat.DEFAULT.getRecordSeparator(), format.getRecordSeparator(), \"record separator\");\r\n-        assertEquals(CSVFormat.DEFAULT.getEscapeCharacter(), format.getEscapeCharacter(), \"escape\");\r\n-        assertEquals(CSVFormat.DEFAULT.getIgnoreSurroundingSpaces(), format.getIgnoreSurroundingSpaces(), \"trim\");\r\n-        assertEquals(CSVFormat.DEFAULT.getIgnoreEmptyLines(), format.getIgnoreEmptyLines(), \"empty lines\");\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testToString() {\r\n-\r\n-        final String string = CSVFormat.INFORMIX_UNLOAD.toString();\r\n-\r\n-        assertEquals(\"Delimiter=<|> Escape=<\\\\> QuoteChar=<\\\"> RecordSeparator=<\\n> EmptyLines:ignored SkipHeaderRecord:false\", string);\r\n-\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testToStringAndWithCommentMarkerTakingCharacter() {\r\n-\r\n-        final CSVFormat.Predefined csvFormatPredefined = CSVFormat.Predefined.Default;\r\n-        final CSVFormat csvFormat = csvFormatPredefined.getFormat();\r\n-\r\n-        assertNull(csvFormat.getEscapeCharacter());\r\n-        assertTrue(csvFormat.isQuoteCharacterSet());\r\n-\r\n-        assertFalse(csvFormat.getTrim());\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-        assertEquals(',', csvFormat.getDelimiter());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n-\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-\r\n-        assertFalse(csvFormat.isNullStringSet());\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-\r\n-        assertFalse(csvFormat.isEscapeCharacterSet());\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-\r\n-        assertNull(csvFormat.getNullString());\r\n-        assertNull(csvFormat.getQuoteMode());\r\n-\r\n-        assertTrue(csvFormat.getIgnoreEmptyLines());\r\n-        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n-\r\n-        final Character character = Character.valueOf('n');\r\n-\r\n-        final CSVFormat csvFormatTwo = csvFormat.withCommentMarker(character);\r\n-\r\n-        assertNull(csvFormat.getEscapeCharacter());\r\n-        assertTrue(csvFormat.isQuoteCharacterSet());\r\n-\r\n-        assertFalse(csvFormat.getTrim());\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-        assertEquals(',', csvFormat.getDelimiter());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n-\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-\r\n-        assertFalse(csvFormat.isNullStringSet());\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-\r\n-        assertFalse(csvFormat.isEscapeCharacterSet());\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-\r\n-        assertNull(csvFormat.getNullString());\r\n-        assertNull(csvFormat.getQuoteMode());\r\n-\r\n-        assertTrue(csvFormat.getIgnoreEmptyLines());\r\n-        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n-\r\n-        assertFalse(csvFormatTwo.isNullStringSet());\r\n-        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n-\r\n-        assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\r\n-        assertNull(csvFormatTwo.getNullString());\r\n-\r\n-        assertEquals(',', csvFormatTwo.getDelimiter());\r\n-        assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n-\r\n-        assertTrue(csvFormatTwo.isCommentMarkerSet());\r\n-        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n-\r\n-        assertFalse(csvFormatTwo.getTrim());\r\n-        assertNull(csvFormatTwo.getEscapeCharacter());\r\n-\r\n-        assertTrue(csvFormatTwo.isQuoteCharacterSet());\r\n-        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\r\n-        assertNull(csvFormatTwo.getQuoteMode());\r\n-\r\n-        assertEquals('n', (char) csvFormatTwo.getCommentMarker());\r\n-        assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n-\r\n-        assertFalse(csvFormatTwo.isEscapeCharacterSet());\r\n-        assertTrue(csvFormatTwo.getIgnoreEmptyLines());\r\n-\r\n-        assertNotSame(csvFormat, csvFormatTwo);\r\n-        assertNotSame(csvFormatTwo, csvFormat);\r\n-\r\n-        Assertions.assertNotEquals(csvFormatTwo, csvFormat);\r\n-\r\n-        assertNull(csvFormat.getEscapeCharacter());\r\n-        assertTrue(csvFormat.isQuoteCharacterSet());\r\n-\r\n-        assertFalse(csvFormat.getTrim());\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-        assertEquals(',', csvFormat.getDelimiter());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n-\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-\r\n-        assertFalse(csvFormat.isNullStringSet());\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-\r\n-        assertFalse(csvFormat.isEscapeCharacterSet());\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-\r\n-        assertNull(csvFormat.getNullString());\r\n-        assertNull(csvFormat.getQuoteMode());\r\n-\r\n-        assertTrue(csvFormat.getIgnoreEmptyLines());\r\n-        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n-\r\n-        assertFalse(csvFormatTwo.isNullStringSet());\r\n-        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n-\r\n-        assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\r\n-        assertNull(csvFormatTwo.getNullString());\r\n-\r\n-        assertEquals(',', csvFormatTwo.getDelimiter());\r\n-        assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n-\r\n-        assertTrue(csvFormatTwo.isCommentMarkerSet());\r\n-        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n-\r\n-        assertFalse(csvFormatTwo.getTrim());\r\n-        assertNull(csvFormatTwo.getEscapeCharacter());\r\n-\r\n-        assertTrue(csvFormatTwo.isQuoteCharacterSet());\r\n-        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\r\n-        assertNull(csvFormatTwo.getQuoteMode());\r\n-\r\n-        assertEquals('n', (char) csvFormatTwo.getCommentMarker());\r\n-        assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n-\r\n-        assertFalse(csvFormatTwo.isEscapeCharacterSet());\r\n-        assertTrue(csvFormatTwo.getIgnoreEmptyLines());\r\n-\r\n-        assertNotSame(csvFormat, csvFormatTwo);\r\n-        assertNotSame(csvFormatTwo, csvFormat);\r\n-\r\n-        Assertions.assertNotEquals(csvFormat, csvFormatTwo);\r\n-\r\n-        Assertions.assertNotEquals(csvFormatTwo, csvFormat);\r\n-        assertEquals(\"Delimiter=<,> QuoteChar=<\\\"> CommentStart=<n> \" + \"RecordSeparator=<\\r\\n> EmptyLines:ignored SkipHeaderRecord:false\",\r\n-                csvFormatTwo.toString());\r\n-\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testTrim() throws IOException {\r\n-        final CSVFormat formatWithTrim = CSVFormat.DEFAULT.withDelimiter(',').withTrim().withQuote(null).withRecordSeparator(CRLF);\r\n-\r\n-        CharSequence in = \"a,b,c\";\r\n-        final StringBuilder out = new StringBuilder();\r\n-        formatWithTrim.print(in, out, true);\r\n-        assertEquals(\"a,b,c\", out.toString());\r\n-\r\n-        in = new StringBuilder(\" x,y,z\");\r\n-        out.setLength(0);\r\n-        formatWithTrim.print(in, out, true);\r\n-        assertEquals(\"x,y,z\", out.toString());\r\n-\r\n-        in = new StringBuilder(\"\");\r\n-        out.setLength(0);\r\n-        formatWithTrim.print(in, out, true);\r\n-        assertEquals(\"\", out.toString());\r\n-\r\n-        in = new StringBuilder(\"header\\r\\n\");\r\n-        out.setLength(0);\r\n-        formatWithTrim.print(in, out, true);\r\n-        assertEquals(\"header\", out.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithCommentStart() {\r\n-        final CSVFormat formatWithCommentStart = CSVFormat.DEFAULT.withCommentMarker('#');\r\n-        assertEquals(Character.valueOf('#'), formatWithCommentStart.getCommentMarker());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithCommentStartCRThrowsException() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withCommentMarker(CR));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithDelimiter() {\r\n-        final CSVFormat formatWithDelimiter = CSVFormat.DEFAULT.withDelimiter('!');\r\n-        assertEquals('!', formatWithDelimiter.getDelimiter());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithDelimiterLFThrowsException() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter(LF));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithEmptyDuplicates() {\r\n-        final CSVFormat formatWithEmptyDuplicates = CSVFormat.DEFAULT.builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).get();\r\n-\r\n-        assertEquals(DuplicateHeaderMode.ALLOW_EMPTY, formatWithEmptyDuplicates.getDuplicateHeaderMode());\r\n-        assertFalse(formatWithEmptyDuplicates.getAllowDuplicateHeaderNames());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithEmptyEnum() {\r\n-        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(EmptyEnum.class);\r\n-        assertEquals(0, formatWithHeader.getHeader().length);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithEscape() {\r\n-        final CSVFormat formatWithEscape = CSVFormat.DEFAULT.withEscape('&');\r\n-        assertEquals(Character.valueOf('&'), formatWithEscape.getEscapeCharacter());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithEscapeCRThrowsExceptions() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withEscape(CR));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithFirstRecordAsHeader() {\r\n-        final CSVFormat formatWithFirstRecordAsHeader = CSVFormat.DEFAULT.withFirstRecordAsHeader();\r\n-        assertTrue(formatWithFirstRecordAsHeader.getSkipHeaderRecord());\r\n-        assertEquals(0, formatWithFirstRecordAsHeader.getHeader().length);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithHeader() {\r\n-        final String[] header = { \"one\", \"two\", \"three\" };\r\n-        // withHeader() makes a copy of the header array.\r\n-        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(header);\r\n-        assertArrayEquals(header, formatWithHeader.getHeader());\r\n-        assertNotSame(header, formatWithHeader.getHeader());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithHeaderComments() {\r\n-\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT;\r\n-\r\n-        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-\r\n-        assertFalse(csvFormat.isEscapeCharacterSet());\r\n-        assertTrue(csvFormat.isQuoteCharacterSet());\r\n-\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-        assertNull(csvFormat.getQuoteMode());\r\n-\r\n-        assertEquals(',', csvFormat.getDelimiter());\r\n-        assertTrue(csvFormat.getIgnoreEmptyLines());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-\r\n-        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-        assertFalse(csvFormat.getTrim());\r\n-\r\n-        assertFalse(csvFormat.isNullStringSet());\r\n-        assertNull(csvFormat.getNullString());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-        assertNull(csvFormat.getEscapeCharacter());\r\n-\r\n-        final Object[] objectArray = new Object[8];\r\n-        final CSVFormat csvFormatTwo = csvFormat.withHeaderComments(objectArray);\r\n-\r\n-        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-\r\n-        assertFalse(csvFormat.isEscapeCharacterSet());\r\n-        assertTrue(csvFormat.isQuoteCharacterSet());\r\n-\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-        assertNull(csvFormat.getQuoteMode());\r\n-\r\n-        assertEquals(',', csvFormat.getDelimiter());\r\n-        assertTrue(csvFormat.getIgnoreEmptyLines());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-\r\n-        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-        assertFalse(csvFormat.getTrim());\r\n-\r\n-        assertFalse(csvFormat.isNullStringSet());\r\n-        assertNull(csvFormat.getNullString());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-        assertNull(csvFormat.getEscapeCharacter());\r\n-\r\n-        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n-        assertNull(csvFormatTwo.getQuoteMode());\r\n-\r\n-        assertTrue(csvFormatTwo.getIgnoreEmptyLines());\r\n-        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertNull(csvFormatTwo.getEscapeCharacter());\r\n-        assertFalse(csvFormatTwo.getTrim());\r\n-\r\n-        assertFalse(csvFormatTwo.isEscapeCharacterSet());\r\n-        assertTrue(csvFormatTwo.isQuoteCharacterSet());\r\n-\r\n-        assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n-        assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\r\n-\r\n-        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n-        assertNull(csvFormatTwo.getNullString());\r\n-\r\n-        assertFalse(csvFormatTwo.isNullStringSet());\r\n-        assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n-\r\n-        assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\r\n-        assertEquals(',', csvFormatTwo.getDelimiter());\r\n-\r\n-        assertNull(csvFormatTwo.getCommentMarker());\r\n-        assertFalse(csvFormatTwo.isCommentMarkerSet());\r\n-\r\n-        assertNotSame(csvFormat, csvFormatTwo);\r\n-        assertNotSame(csvFormatTwo, csvFormat);\r\n-\r\n-        Assertions.assertNotEquals(csvFormatTwo, csvFormat); // CSV-244 - should not be equal\r\n-\r\n-        final String string = csvFormatTwo.format(objectArray);\r\n-\r\n-        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-\r\n-        assertFalse(csvFormat.isEscapeCharacterSet());\r\n-        assertTrue(csvFormat.isQuoteCharacterSet());\r\n-\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-        assertNull(csvFormat.getQuoteMode());\r\n-\r\n-        assertEquals(',', csvFormat.getDelimiter());\r\n-        assertTrue(csvFormat.getIgnoreEmptyLines());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-\r\n-        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-        assertFalse(csvFormat.getTrim());\r\n-\r\n-        assertFalse(csvFormat.isNullStringSet());\r\n-        assertNull(csvFormat.getNullString());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-        assertNull(csvFormat.getEscapeCharacter());\r\n-\r\n-        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n-        assertNull(csvFormatTwo.getQuoteMode());\r\n-\r\n-        assertTrue(csvFormatTwo.getIgnoreEmptyLines());\r\n-        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertNull(csvFormatTwo.getEscapeCharacter());\r\n-        assertFalse(csvFormatTwo.getTrim());\r\n-\r\n-        assertFalse(csvFormatTwo.isEscapeCharacterSet());\r\n-        assertTrue(csvFormatTwo.isQuoteCharacterSet());\r\n-\r\n-        assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n-        assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\r\n-\r\n-        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n-        assertNull(csvFormatTwo.getNullString());\r\n-\r\n-        assertFalse(csvFormatTwo.isNullStringSet());\r\n-        assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n-\r\n-        assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\r\n-        assertEquals(',', csvFormatTwo.getDelimiter());\r\n-\r\n-        assertNull(csvFormatTwo.getCommentMarker());\r\n-        assertFalse(csvFormatTwo.isCommentMarkerSet());\r\n-\r\n-        assertNotSame(csvFormat, csvFormatTwo);\r\n-        assertNotSame(csvFormatTwo, csvFormat);\r\n-\r\n-        assertNotNull(string);\r\n-        Assertions.assertNotEquals(csvFormat, csvFormatTwo); // CSV-244 - should not be equal\r\n-\r\n-        Assertions.assertNotEquals(csvFormatTwo, csvFormat); // CSV-244 - should not be equal\r\n-        assertEquals(\",,,,,,,\", string);\r\n-\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithHeaderEnum() {\r\n-        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(Header.class);\r\n-        assertArrayEquals(new String[] { \"Name\", \"Email\", \"Phone\" }, formatWithHeader.getHeader());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithHeaderEnumNull() {\r\n-        final CSVFormat format = CSVFormat.DEFAULT;\r\n-        final Class<Enum<?>> simpleName = null;\r\n-        format.withHeader(simpleName);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithHeaderResultSetNull() throws SQLException {\r\n-        final CSVFormat format = CSVFormat.DEFAULT;\r\n-        final ResultSet resultSet = null;\r\n-        format.withHeader(resultSet);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithIgnoreEmptyLines() {\r\n-        assertFalse(CSVFormat.DEFAULT.withIgnoreEmptyLines(false).getIgnoreEmptyLines());\r\n-        assertTrue(CSVFormat.DEFAULT.withIgnoreEmptyLines().getIgnoreEmptyLines());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithIgnoreSurround() {\r\n-        assertFalse(CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(false).getIgnoreSurroundingSpaces());\r\n-        assertTrue(CSVFormat.DEFAULT.withIgnoreSurroundingSpaces().getIgnoreSurroundingSpaces());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithNullString() {\r\n-        final CSVFormat formatWithNullString = CSVFormat.DEFAULT.withNullString(\"null\");\r\n-        assertEquals(\"null\", formatWithNullString.getNullString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithQuoteChar() {\r\n-        final CSVFormat formatWithQuoteChar = CSVFormat.DEFAULT.withQuote('\"');\r\n-        assertEquals(Character.valueOf('\"'), formatWithQuoteChar.getQuoteCharacter());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithQuoteLFThrowsException() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote(LF));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithQuotePolicy() {\r\n-        final CSVFormat formatWithQuotePolicy = CSVFormat.DEFAULT.withQuoteMode(QuoteMode.ALL);\r\n-        assertEquals(QuoteMode.ALL, formatWithQuotePolicy.getQuoteMode());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithRecordSeparatorCR() {\r\n-        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator(CR);\r\n-        assertEquals(String.valueOf(CR), formatWithRecordSeparator.getRecordSeparator());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithRecordSeparatorCRLF() {\r\n-        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator(CRLF);\r\n-        assertEquals(CRLF, formatWithRecordSeparator.getRecordSeparator());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithRecordSeparatorLF() {\r\n-        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator(LF);\r\n-        assertEquals(String.valueOf(LF), formatWithRecordSeparator.getRecordSeparator());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithSystemRecordSeparator() {\r\n-        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withSystemRecordSeparator();\r\n-        assertEquals(System.lineSeparator(), formatWithRecordSeparator.getRecordSeparator());\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import static org.apache.commons.csv.CSVFormat.RFC4180;\n+import static org.apache.commons.csv.Constants.CR;\n+import static org.apache.commons.csv.Constants.CRLF;\n+import static org.apache.commons.csv.Constants.LF;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+import org.apache.commons.csv.CSVFormat.Builder;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * Tests {@link CSVFormat}.\n+ */\n+public class CSVFormatTest {\n+\n+    public enum EmptyEnum {\n+        // empty enum.\n+    }\n+\n+    public enum Header {\n+        Name, Email, Phone\n+    }\n+\n+    private static void assertNotEquals(final Object right, final Object left) {\n+        Assertions.assertNotEquals(right, left);\n+        Assertions.assertNotEquals(left, right);\n+    }\n+\n+    private static CSVFormat copy(final CSVFormat format) {\n+        return format.builder().setDelimiter(format.getDelimiter()).get();\n+    }\n+\n+    private void assertNotEquals(final String name, final String type, final Object left, final Object right) {\n+        if (left.equals(right) || right.equals(left)) {\n+            fail(\"Objects must not compare equal for \" + name + \"(\" + type + \")\");\n+        }\n+        if (left.hashCode() == right.hashCode()) {\n+            fail(\"Hash code should not be equal for \" + name + \"(\" + type + \")\");\n+        }\n+    }\n+\n+    @Test\n+    public void testBuildVsGet() {\n+        final Builder builder = CSVFormat.DEFAULT.builder();\n+        assertNotSame(builder.get(), builder.build());\n+    }\n+\n+    @Test\n+    public void testDelimiterEmptyStringThrowsException1() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter(\"\").get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testDelimiterSameAsCommentStartThrowsException_Deprecated() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter('!').withCommentMarker('!'));\n+    }\n+\n+    @Test\n+    public void testDelimiterSameAsCommentStartThrowsException1() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter('!').setCommentMarker('!').get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testDelimiterSameAsEscapeThrowsException_Deprecated() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter('!').withEscape('!'));\n+    }\n+\n+    @Test\n+    public void testDelimiterSameAsEscapeThrowsException1() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter('!').setEscape('!').get());\n+    }\n+\n+    @Test\n+    public void testDelimiterSameAsRecordSeparatorThrowsException() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat(CR));\n+    }\n+\n+    @Test\n+    public void testDuplicateHeaderElements() {\n+        final String[] header = { \"A\", \"A\" };\n+        final CSVFormat format = CSVFormat.DEFAULT.builder().setHeader(header).get();\n+        assertEquals(2, format.getHeader().length);\n+        assertArrayEquals(header, format.getHeader());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testDuplicateHeaderElements_Deprecated() {\n+        final String[] header = { \"A\", \"A\" };\n+        final CSVFormat format = CSVFormat.DEFAULT.withHeader(header);\n+        assertEquals(2, format.getHeader().length);\n+        assertArrayEquals(header, format.getHeader());\n+    }\n+\n+    @Test\n+    public void testDuplicateHeaderElementsFalse() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(false).setHeader(\"A\", \"A\").get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testDuplicateHeaderElementsFalse_Deprecated() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withAllowDuplicateHeaderNames(false).withHeader(\"A\", \"A\"));\n+    }\n+\n+    @Test\n+    public void testDuplicateHeaderElementsTrue() {\n+        CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(true).setHeader(\"A\", \"A\").get();\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testDuplicateHeaderElementsTrue_Deprecated() {\n+        CSVFormat.DEFAULT.withAllowDuplicateHeaderNames(true).withHeader(\"A\", \"A\");\n+    }\n+\n+    @Test\n+    public void testDuplicateHeaderElementsTrueContainsEmpty1() {\n+        CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(false).setHeader(\"A\", \"\", \"B\", \"\").get();\n+    }\n+\n+    @Test\n+    public void testDuplicateHeaderElementsTrueContainsEmpty2() {\n+        CSVFormat.DEFAULT.builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).setHeader(\"A\", \"\", \"B\", \"\").get();\n+    }\n+\n+    @Test\n+    public void testDuplicateHeaderElementsTrueContainsEmpty3() {\n+        CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(false).setAllowMissingColumnNames(true).setHeader(\"A\", \"\", \"B\", \"\").get();\n+    }\n+\n+    @Test\n+    public void testEquals() {\n+        final CSVFormat right = CSVFormat.DEFAULT;\n+        final CSVFormat left = copy(right);\n+        Assertions.assertNotEquals(null, right);\n+        Assertions.assertNotEquals(\"A String Instance\", right);\n+        assertEquals(right, right);\n+        assertEquals(right, left);\n+        assertEquals(left, right);\n+        assertEquals(right.hashCode(), right.hashCode());\n+        assertEquals(right.hashCode(), left.hashCode());\n+    }\n+\n+    @Test\n+    public void testEqualsCommentStart() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').setCommentMarker('#').setQuoteMode(QuoteMode.ALL).get();\n+        final CSVFormat left = right.builder().setCommentMarker('!').get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsCommentStart_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"').withCommentMarker('#').withQuoteMode(QuoteMode.ALL);\n+        final CSVFormat left = right.withCommentMarker('!');\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsDelimiter() {\n+        final CSVFormat right = CSVFormat.newFormat('!');\n+        final CSVFormat left = CSVFormat.newFormat('?');\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsEscape() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').setCommentMarker('#').setEscape('+').setQuoteMode(QuoteMode.ALL).get();\n+        final CSVFormat left = right.builder().setEscape('!').get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsEscape_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"').withCommentMarker('#').withEscape('+').withQuoteMode(QuoteMode.ALL);\n+        final CSVFormat left = right.withEscape('!');\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsHash() throws Exception {\n+        final Method[] methods = CSVFormat.class.getDeclaredMethods();\n+        for (final Method method : methods) {\n+            if (Modifier.isPublic(method.getModifiers())) {\n+                final String name = method.getName();\n+                if (name.startsWith(\"with\")) {\n+                    for (final Class<?> cls : method.getParameterTypes()) {\n+                        final String type = cls.getCanonicalName();\n+                        switch (type) {\n+                        case \"boolean\": {\n+                            final Object defTrue = method.invoke(CSVFormat.DEFAULT, Boolean.TRUE);\n+                            final Object defFalse = method.invoke(CSVFormat.DEFAULT, Boolean.FALSE);\n+                            assertNotEquals(name, type, defTrue, defFalse);\n+                            break;\n+                        }\n+                        case \"char\": {\n+                            final Object a = method.invoke(CSVFormat.DEFAULT, 'a');\n+                            final Object b = method.invoke(CSVFormat.DEFAULT, 'b');\n+                            assertNotEquals(name, type, a, b);\n+                            break;\n+                        }\n+                        case \"java.lang.Character\": {\n+                            final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { null });\n+                            final Object b = method.invoke(CSVFormat.DEFAULT, Character.valueOf('d'));\n+                            assertNotEquals(name, type, a, b);\n+                            break;\n+                        }\n+                        case \"java.lang.String\": {\n+                            final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { null });\n+                            final Object b = method.invoke(CSVFormat.DEFAULT, \"e\");\n+                            assertNotEquals(name, type, a, b);\n+                            break;\n+                        }\n+                        case \"java.lang.String[]\": {\n+                            final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { new String[] { null, null } });\n+                            final Object b = method.invoke(CSVFormat.DEFAULT, new Object[] { new String[] { \"f\", \"g\" } });\n+                            assertNotEquals(name, type, a, b);\n+                            break;\n+                        }\n+                        case \"org.apache.commons.csv.QuoteMode\": {\n+                            final Object a = method.invoke(CSVFormat.DEFAULT, QuoteMode.MINIMAL);\n+                            final Object b = method.invoke(CSVFormat.DEFAULT, QuoteMode.ALL);\n+                            assertNotEquals(name, type, a, b);\n+                            break;\n+                        }\n+                        case \"org.apache.commons.csv.DuplicateHeaderMode\": {\n+                            final Object a = method.invoke(CSVFormat.DEFAULT, DuplicateHeaderMode.ALLOW_ALL);\n+                            final Object b = method.invoke(CSVFormat.DEFAULT, DuplicateHeaderMode.DISALLOW);\n+                            assertNotEquals(name, type, a, b);\n+                            break;\n+                        }\n+                        case \"java.lang.Object[]\": {\n+                            final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { new Object[] { null, null } });\n+                            final Object b = method.invoke(CSVFormat.DEFAULT, new Object[] { new Object[] { new Object(), new Object() } });\n+                            assertNotEquals(name, type, a, b);\n+                            break;\n+                        }\n+                        default:\n+                            if (\"withHeader\".equals(name)) { // covered above by String[]\n+                                // ignored\n+                            } else {\n+                                fail(\"Unhandled method: \" + name + \"(\" + type + \")\");\n+                            }\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testEqualsHeader() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setHeader(\"One\", \"Two\", \"Three\")\n+                .setIgnoreEmptyLines(true).setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\n+        final CSVFormat left = right.builder().setHeader(\"Three\", \"Two\", \"One\").get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsHeader_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withHeader(\"One\", \"Two\", \"Three\")\n+                .withIgnoreEmptyLines().withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL);\n+        final CSVFormat left = right.withHeader(\"Three\", \"Two\", \"One\");\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsIgnoreEmptyLines() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true)\n+                .setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\n+        final CSVFormat left = right.builder().setIgnoreEmptyLines(false).get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsIgnoreEmptyLines_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withCommentMarker('#').withEscape('+').withIgnoreEmptyLines().withIgnoreSurroundingSpaces()\n+                .withQuote('\"').withQuoteMode(QuoteMode.ALL);\n+        final CSVFormat left = right.withIgnoreEmptyLines(false);\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsIgnoreSurroundingSpaces() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setCommentMarker('#').setEscape('+').setIgnoreSurroundingSpaces(true).setQuote('\"')\n+                .setQuoteMode(QuoteMode.ALL).get();\n+        final CSVFormat left = right.builder().setIgnoreSurroundingSpaces(false).get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsIgnoreSurroundingSpaces_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withCommentMarker('#').withEscape('+').withIgnoreSurroundingSpaces().withQuote('\"')\n+                .withQuoteMode(QuoteMode.ALL);\n+        final CSVFormat left = right.withIgnoreSurroundingSpaces(false);\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsLeftNoQuoteRightQuote() {\n+        final CSVFormat left = CSVFormat.newFormat(',').builder().setQuote(null).get();\n+        final CSVFormat right = left.builder().setQuote('#').get();\n+\n+        assertNotEquals(left, right);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsLeftNoQuoteRightQuote_Deprecated() {\n+        final CSVFormat left = CSVFormat.newFormat(',').withQuote(null);\n+        final CSVFormat right = left.withQuote('#');\n+\n+        assertNotEquals(left, right);\n+    }\n+\n+    @Test\n+    public void testEqualsNoQuotes() {\n+        final CSVFormat left = CSVFormat.newFormat(',').builder().setQuote(null).get();\n+        final CSVFormat right = left.builder().setQuote(null).get();\n+\n+        assertEquals(left, right);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsNoQuotes_Deprecated() {\n+        final CSVFormat left = CSVFormat.newFormat(',').withQuote(null);\n+        final CSVFormat right = left.withQuote(null);\n+\n+        assertEquals(left, right);\n+    }\n+\n+    @Test\n+    public void testEqualsNullString() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true)\n+                .setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).setNullString(\"null\").get();\n+        final CSVFormat left = right.builder().setNullString(\"---\").get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsNullString_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withIgnoreEmptyLines()\n+                .withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL).withNullString(\"null\");\n+        final CSVFormat left = right.withNullString(\"---\");\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsOne() {\n+\n+        final CSVFormat csvFormatOne = CSVFormat.INFORMIX_UNLOAD;\n+        final CSVFormat csvFormatTwo = CSVFormat.MYSQL;\n+\n+        assertEquals('\\\\', (char) csvFormatOne.getEscapeCharacter());\n+        assertEquals('\\\\', csvFormatOne.getEscapeChar());\n+        assertNull(csvFormatOne.getQuoteMode());\n+\n+        assertTrue(csvFormatOne.getIgnoreEmptyLines());\n+        assertFalse(csvFormatOne.getSkipHeaderRecord());\n+\n+        assertFalse(csvFormatOne.getIgnoreHeaderCase());\n+        assertNull(csvFormatOne.getCommentMarker());\n+\n+        assertFalse(csvFormatOne.isCommentMarkerSet());\n+        assertTrue(csvFormatOne.isQuoteCharacterSet());\n+\n+        assertEquals('|', csvFormatOne.getDelimiter());\n+        assertFalse(csvFormatOne.getAllowMissingColumnNames());\n+\n+        assertTrue(csvFormatOne.isEscapeCharacterSet());\n+        assertEquals(\"\\n\", csvFormatOne.getRecordSeparator());\n+\n+        assertEquals('\\\"', (char) csvFormatOne.getQuoteCharacter());\n+        assertFalse(csvFormatOne.getTrailingDelimiter());\n+\n+        assertFalse(csvFormatOne.getTrim());\n+        assertFalse(csvFormatOne.isNullStringSet());\n+\n+        assertNull(csvFormatOne.getNullString());\n+        assertFalse(csvFormatOne.getIgnoreSurroundingSpaces());\n+\n+        assertTrue(csvFormatTwo.isEscapeCharacterSet());\n+        assertNull(csvFormatTwo.getQuoteCharacter());\n+\n+        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\n+        assertEquals(QuoteMode.ALL_NON_NULL, csvFormatTwo.getQuoteMode());\n+\n+        assertEquals('\\t', csvFormatTwo.getDelimiter());\n+        assertArrayEquals(new char[] { '\\t' }, csvFormatTwo.getDelimiterCharArray());\n+        assertEquals(\"\\t\", csvFormatTwo.getDelimiterString());\n+        assertEquals(\"\\n\", csvFormatTwo.getRecordSeparator());\n+\n+        assertFalse(csvFormatTwo.isQuoteCharacterSet());\n+        assertTrue(csvFormatTwo.isNullStringSet());\n+\n+        assertEquals('\\\\', (char) csvFormatTwo.getEscapeCharacter());\n+        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\n+\n+        assertFalse(csvFormatTwo.getTrim());\n+        assertFalse(csvFormatTwo.getIgnoreEmptyLines());\n+\n+        assertEquals(\"\\\\N\", csvFormatTwo.getNullString());\n+        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\n+\n+        assertFalse(csvFormatTwo.getTrailingDelimiter());\n+        assertFalse(csvFormatTwo.getSkipHeaderRecord());\n+\n+        assertNull(csvFormatTwo.getCommentMarker());\n+        assertFalse(csvFormatTwo.isCommentMarkerSet());\n+\n+        assertNotSame(csvFormatTwo, csvFormatOne);\n+        Assertions.assertNotEquals(csvFormatTwo, csvFormatOne);\n+\n+        assertEquals('\\\\', (char) csvFormatOne.getEscapeCharacter());\n+        assertNull(csvFormatOne.getQuoteMode());\n+\n+        assertTrue(csvFormatOne.getIgnoreEmptyLines());\n+        assertFalse(csvFormatOne.getSkipHeaderRecord());\n+\n+        assertFalse(csvFormatOne.getIgnoreHeaderCase());\n+        assertNull(csvFormatOne.getCommentMarker());\n+\n+        assertFalse(csvFormatOne.isCommentMarkerSet());\n+        assertTrue(csvFormatOne.isQuoteCharacterSet());\n+\n+        assertEquals('|', csvFormatOne.getDelimiter());\n+        assertFalse(csvFormatOne.getAllowMissingColumnNames());\n+\n+        assertTrue(csvFormatOne.isEscapeCharacterSet());\n+        assertEquals(\"\\n\", csvFormatOne.getRecordSeparator());\n+\n+        assertEquals('\\\"', (char) csvFormatOne.getQuoteCharacter());\n+        assertFalse(csvFormatOne.getTrailingDelimiter());\n+\n+        assertFalse(csvFormatOne.getTrim());\n+        assertFalse(csvFormatOne.isNullStringSet());\n+\n+        assertNull(csvFormatOne.getNullString());\n+        assertFalse(csvFormatOne.getIgnoreSurroundingSpaces());\n+\n+        assertTrue(csvFormatTwo.isEscapeCharacterSet());\n+        assertNull(csvFormatTwo.getQuoteCharacter());\n+\n+        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\n+        assertEquals(QuoteMode.ALL_NON_NULL, csvFormatTwo.getQuoteMode());\n+\n+        assertEquals('\\t', csvFormatTwo.getDelimiter());\n+        assertEquals(\"\\n\", csvFormatTwo.getRecordSeparator());\n+\n+        assertFalse(csvFormatTwo.isQuoteCharacterSet());\n+        assertTrue(csvFormatTwo.isNullStringSet());\n+\n+        assertEquals('\\\\', (char) csvFormatTwo.getEscapeCharacter());\n+        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\n+\n+        assertFalse(csvFormatTwo.getTrim());\n+        assertFalse(csvFormatTwo.getIgnoreEmptyLines());\n+\n+        assertEquals(\"\\\\N\", csvFormatTwo.getNullString());\n+        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\n+\n+        assertFalse(csvFormatTwo.getTrailingDelimiter());\n+        assertFalse(csvFormatTwo.getSkipHeaderRecord());\n+\n+        assertNull(csvFormatTwo.getCommentMarker());\n+        assertFalse(csvFormatTwo.isCommentMarkerSet());\n+\n+        assertNotSame(csvFormatOne, csvFormatTwo);\n+        assertNotSame(csvFormatTwo, csvFormatOne);\n+\n+        Assertions.assertNotEquals(csvFormatOne, csvFormatTwo);\n+        Assertions.assertNotEquals(csvFormatTwo, csvFormatOne);\n+\n+        Assertions.assertNotEquals(csvFormatTwo, csvFormatOne);\n+\n+    }\n+\n+    @Test\n+    public void testEqualsQuoteChar() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').get();\n+        final CSVFormat left = right.builder().setQuote('!').get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsQuoteChar_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"');\n+        final CSVFormat left = right.withQuote('!');\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsQuotePolicy() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\n+        final CSVFormat left = right.builder().setQuoteMode(QuoteMode.MINIMAL).get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsQuotePolicy_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"').withQuoteMode(QuoteMode.ALL);\n+        final CSVFormat left = right.withQuoteMode(QuoteMode.MINIMAL);\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsRecordSeparator() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true)\n+                .setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\n+        final CSVFormat left = right.builder().setRecordSeparator(LF).get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsRecordSeparator_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withIgnoreEmptyLines()\n+                .withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL);\n+        final CSVFormat left = right.withRecordSeparator(LF);\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    public void testEqualsSkipHeaderRecord() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true)\n+                .setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).setNullString(\"null\").setSkipHeaderRecord(true).get();\n+        final CSVFormat left = right.builder().setSkipHeaderRecord(false).get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsSkipHeaderRecord_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withIgnoreEmptyLines()\n+                .withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL).withNullString(\"null\").withSkipHeaderRecord();\n+        final CSVFormat left = right.withSkipHeaderRecord(false);\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsWithNull() {\n+\n+        final CSVFormat csvFormat = CSVFormat.POSTGRESQL_TEXT;\n+\n+        assertEquals('\\\\', (char) csvFormat.getEscapeCharacter());\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+        assertFalse(csvFormat.getTrim());\n+\n+        assertFalse(csvFormat.isQuoteCharacterSet());\n+        assertEquals(\"\\\\N\", csvFormat.getNullString());\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertTrue(csvFormat.isEscapeCharacterSet());\n+\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+        assertNull(csvFormat.getCommentMarker());\n+\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+        assertEquals(QuoteMode.ALL_NON_NULL, csvFormat.getQuoteMode());\n+\n+        assertEquals('\\t', csvFormat.getDelimiter());\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+\n+        assertEquals(\"\\n\", csvFormat.getRecordSeparator());\n+        assertFalse(csvFormat.getIgnoreEmptyLines());\n+\n+        assertNull(csvFormat.getQuoteCharacter());\n+        assertTrue(csvFormat.isNullStringSet());\n+\n+        assertEquals('\\\\', (char) csvFormat.getEscapeCharacter());\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+        assertFalse(csvFormat.getTrim());\n+\n+        assertFalse(csvFormat.isQuoteCharacterSet());\n+        assertEquals(\"\\\\N\", csvFormat.getNullString());\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertTrue(csvFormat.isEscapeCharacterSet());\n+\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+        assertNull(csvFormat.getCommentMarker());\n+\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+        assertEquals(QuoteMode.ALL_NON_NULL, csvFormat.getQuoteMode());\n+\n+        assertEquals('\\t', csvFormat.getDelimiter());\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+\n+        assertEquals(\"\\n\", csvFormat.getRecordSeparator());\n+        assertFalse(csvFormat.getIgnoreEmptyLines());\n+\n+        assertNull(csvFormat.getQuoteCharacter());\n+        assertTrue(csvFormat.isNullStringSet());\n+\n+        Assertions.assertNotEquals(null, csvFormat);\n+\n+    }\n+\n+    @Test\n+    public void testEscapeSameAsCommentStartThrowsException() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setEscape('!').setCommentMarker('!').get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEscapeSameAsCommentStartThrowsException_Deprecated() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withEscape('!').withCommentMarker('!'));\n+    }\n+\n+    @Test\n+    public void testEscapeSameAsCommentStartThrowsExceptionForWrapperType() {\n+        // Cannot assume that callers won't use different Character objects\n+        assertThrows(IllegalArgumentException.class,\n+                () -> CSVFormat.DEFAULT.builder().setEscape(Character.valueOf('!')).setCommentMarker(Character.valueOf('!')).get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEscapeSameAsCommentStartThrowsExceptionForWrapperType_Deprecated() {\n+        // Cannot assume that callers won't use different Character objects\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withEscape(Character.valueOf('!')).withCommentMarker(Character.valueOf('!')));\n+    }\n+\n+    @Test\n+    public void testFormat() {\n+        final CSVFormat format = CSVFormat.DEFAULT;\n+\n+        assertEquals(\"\", format.format());\n+        assertEquals(\"a,b,c\", format.format(\"a\", \"b\", \"c\"));\n+        assertEquals(\"\\\"x,y\\\",z\", format.format(\"x,y\", \"z\"));\n+    }\n+\n+    @Test // I assume this to be a defect.\n+    public void testFormatThrowsNullPointerException() {\n+\n+        final CSVFormat csvFormat = CSVFormat.MYSQL;\n+\n+        final NullPointerException e = assertThrows(NullPointerException.class, () -> csvFormat.format((Object[]) null));\n+        assertEquals(Objects.class.getName(), e.getStackTrace()[0].getClassName());\n+    }\n+\n+    @Test\n+    public void testFormatToString() {\n+        // @formatter:off\n+        final CSVFormat format = CSVFormat.RFC4180\n+                .withEscape('?')\n+                .withDelimiter(',')\n+                .withQuoteMode(QuoteMode.MINIMAL)\n+                .withRecordSeparator(CRLF)\n+                .withQuote('\"')\n+                .withNullString(\"\")\n+                .withIgnoreHeaderCase(true)\n+                .withHeaderComments(\"This is HeaderComments\")\n+                .withHeader(\"col1\", \"col2\", \"col3\");\n+        // @formatter:on\n+        assertEquals(\n+                \"Delimiter=<,> Escape=<?> QuoteChar=<\\\"> QuoteMode=<MINIMAL> NullString=<> RecordSeparator=<\" + CRLF +\n+                        \"> IgnoreHeaderCase:ignored SkipHeaderRecord:false HeaderComments:[This is HeaderComments] Header:[col1, col2, col3]\",\n+                format.toString());\n+    }\n+\n+    @Test\n+    public void testGetAllowDuplicateHeaderNames() {\n+        final Builder builder = CSVFormat.DEFAULT.builder();\n+        assertTrue(builder.get().getAllowDuplicateHeaderNames());\n+        assertTrue(builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).get().getAllowDuplicateHeaderNames());\n+        assertFalse(builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).get().getAllowDuplicateHeaderNames());\n+        assertFalse(builder.setDuplicateHeaderMode(DuplicateHeaderMode.DISALLOW).get().getAllowDuplicateHeaderNames());\n+    }\n+\n+    @Test\n+    public void testGetDuplicateHeaderMode() {\n+        final Builder builder = CSVFormat.DEFAULT.builder();\n+\n+        assertEquals(DuplicateHeaderMode.ALLOW_ALL, builder.get().getDuplicateHeaderMode());\n+        assertEquals(DuplicateHeaderMode.ALLOW_ALL, builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).get().getDuplicateHeaderMode());\n+        assertEquals(DuplicateHeaderMode.ALLOW_EMPTY, builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).get().getDuplicateHeaderMode());\n+        assertEquals(DuplicateHeaderMode.DISALLOW, builder.setDuplicateHeaderMode(DuplicateHeaderMode.DISALLOW).get().getDuplicateHeaderMode());\n+    }\n+\n+    @Test\n+    public void testGetHeader() {\n+        final String[] header = { \"one\", \"two\", \"three\" };\n+        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(header);\n+        // getHeader() makes a copy of the header array.\n+        final String[] headerCopy = formatWithHeader.getHeader();\n+        headerCopy[0] = \"A\";\n+        headerCopy[1] = \"B\";\n+        headerCopy[2] = \"C\";\n+        assertFalse(Arrays.equals(formatWithHeader.getHeader(), headerCopy));\n+        assertNotSame(formatWithHeader.getHeader(), headerCopy);\n+    }\n+\n+    @Test\n+    public void testHashCodeAndWithIgnoreHeaderCase() {\n+\n+        final CSVFormat csvFormat = CSVFormat.INFORMIX_UNLOAD_CSV;\n+        final CSVFormat csvFormatTwo = csvFormat.withIgnoreHeaderCase();\n+        csvFormatTwo.hashCode();\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertTrue(csvFormatTwo.getIgnoreHeaderCase()); // now different\n+        assertFalse(csvFormatTwo.getTrailingDelimiter());\n+\n+        Assertions.assertNotEquals(csvFormatTwo, csvFormat); // CSV-244 - should not be equal\n+        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\n+\n+        assertFalse(csvFormatTwo.getTrim());\n+\n+    }\n+\n+    @Test\n+    public void testJiraCsv236() {\n+        CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(true).setHeader(\"CC\", \"VV\", \"VV\").get();\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testJiraCsv236__Deprecated() {\n+        CSVFormat.DEFAULT.withAllowDuplicateHeaderNames().withHeader(\"CC\", \"VV\", \"VV\");\n+    }\n+\n+    @Test\n+    public void testNewFormat() {\n+\n+        final CSVFormat csvFormat = CSVFormat.newFormat('X');\n+\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+        assertFalse(csvFormat.isEscapeCharacterSet());\n+\n+        assertNull(csvFormat.getRecordSeparator());\n+        assertNull(csvFormat.getQuoteMode());\n+\n+        assertNull(csvFormat.getCommentMarker());\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+        assertFalse(csvFormat.getTrim());\n+\n+        assertFalse(csvFormat.isNullStringSet());\n+        assertNull(csvFormat.getEscapeCharacter());\n+\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+\n+        assertEquals('X', csvFormat.getDelimiter());\n+        assertNull(csvFormat.getNullString());\n+\n+        assertFalse(csvFormat.isQuoteCharacterSet());\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+\n+        assertNull(csvFormat.getQuoteCharacter());\n+        assertFalse(csvFormat.getIgnoreEmptyLines());\n+\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+        assertFalse(csvFormat.isEscapeCharacterSet());\n+\n+        assertNull(csvFormat.getRecordSeparator());\n+        assertNull(csvFormat.getQuoteMode());\n+\n+        assertNull(csvFormat.getCommentMarker());\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+        assertFalse(csvFormat.getTrim());\n+\n+        assertFalse(csvFormat.isNullStringSet());\n+        assertNull(csvFormat.getEscapeCharacter());\n+\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+\n+        assertEquals('X', csvFormat.getDelimiter());\n+        assertNull(csvFormat.getNullString());\n+\n+        assertFalse(csvFormat.isQuoteCharacterSet());\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+\n+        assertNull(csvFormat.getQuoteCharacter());\n+        assertFalse(csvFormat.getIgnoreEmptyLines());\n+\n+    }\n+\n+    @Test\n+    public void testNullRecordSeparatorCsv106() {\n+        final CSVFormat format = CSVFormat.newFormat(';').builder().setSkipHeaderRecord(true).setHeader(\"H1\", \"H2\").get();\n+        final String formatStr = format.format(\"A\", \"B\");\n+        assertNotNull(formatStr);\n+        assertFalse(formatStr.endsWith(\"null\"));\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testNullRecordSeparatorCsv106__Deprecated() {\n+        final CSVFormat format = CSVFormat.newFormat(';').withSkipHeaderRecord().withHeader(\"H1\", \"H2\");\n+        final String formatStr = format.format(\"A\", \"B\");\n+        assertNotNull(formatStr);\n+        assertFalse(formatStr.endsWith(\"null\"));\n+    }\n+\n+    @Test\n+    public void testPrintRecord() throws IOException {\n+        final Appendable out = new StringBuilder();\n+        final CSVFormat format = CSVFormat.RFC4180;\n+        format.printRecord(out, \"a\", \"b\", \"c\");\n+        assertEquals(\"a,b,c\" + format.getRecordSeparator(), out.toString());\n+    }\n+\n+    @Test\n+    public void testPrintRecordEmpty() throws IOException {\n+        final Appendable out = new StringBuilder();\n+        final CSVFormat format = CSVFormat.RFC4180;\n+        format.printRecord(out);\n+        assertEquals(format.getRecordSeparator(), out.toString());\n+    }\n+\n+    @Test\n+    public void testPrintWithEscapesEndWithCRLF() throws IOException {\n+        final Reader in = new StringReader(\"x,y,x\\r\\na,?b,c\\r\\n\");\n+        final Appendable out = new StringBuilder();\n+        final CSVFormat format = CSVFormat.RFC4180.withEscape('?').withDelimiter(',').withQuote(null).withRecordSeparator(CRLF);\n+        format.print(in, out, true);\n+        assertEquals(\"x?,y?,x?r?na?,??b?,c?r?n\", out.toString());\n+    }\n+\n+    @Test\n+    public void testPrintWithEscapesEndWithoutCRLF() throws IOException {\n+        final Reader in = new StringReader(\"x,y,x\");\n+        final Appendable out = new StringBuilder();\n+        final CSVFormat format = CSVFormat.RFC4180.withEscape('?').withDelimiter(',').withQuote(null).withRecordSeparator(CRLF);\n+        format.print(in, out, true);\n+        assertEquals(\"x?,y?,x\", out.toString());\n+    }\n+\n+    @Test\n+    public void testPrintWithoutQuotes() throws IOException {\n+        final Reader in = new StringReader(\"\");\n+        final Appendable out = new StringBuilder();\n+        final CSVFormat format = CSVFormat.RFC4180.withDelimiter(',').withQuote('\"').withEscape('?').withQuoteMode(QuoteMode.NON_NUMERIC);\n+        format.print(in, out, true);\n+        assertEquals(\"\\\"\\\"\", out.toString());\n+    }\n+\n+    @Test\n+    public void testPrintWithQuoteModeIsNONE() throws IOException {\n+        final Reader in = new StringReader(\"a,b,c\");\n+        final Appendable out = new StringBuilder();\n+        final CSVFormat format = CSVFormat.RFC4180.withDelimiter(',').withQuote('\"').withEscape('?').withQuoteMode(QuoteMode.NONE);\n+        format.print(in, out, true);\n+        assertEquals(\"a?,b?,c\", out.toString());\n+    }\n+\n+    @Test\n+    public void testPrintWithQuotes() throws IOException {\n+        final Reader in = new StringReader(\"\\\"a,b,c\\r\\nx,y,z\");\n+        final Appendable out = new StringBuilder();\n+        final CSVFormat format = CSVFormat.RFC4180.withDelimiter(',').withQuote('\"').withEscape('?').withQuoteMode(QuoteMode.NON_NUMERIC);\n+        format.print(in, out, true);\n+        assertEquals(\"\\\"\\\"\\\"a,b,c\\r\\nx,y,z\\\"\", out.toString());\n+    }\n+\n+    @Test\n+    public void testQuoteCharSameAsCommentStartThrowsException() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setQuote('!').setCommentMarker('!').get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testQuoteCharSameAsCommentStartThrowsException_Deprecated() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote('!').withCommentMarker('!'));\n+    }\n+\n+    @Test\n+    public void testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType() {\n+        // Cannot assume that callers won't use different Character objects\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setQuote(Character.valueOf('!')).setCommentMarker('!').get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType_Deprecated() {\n+        // Cannot assume that callers won't use different Character objects\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote(Character.valueOf('!')).withCommentMarker('!'));\n+    }\n+\n+    @Test\n+    public void testQuoteCharSameAsDelimiterThrowsException() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setQuote('!').setDelimiter('!').get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testQuoteCharSameAsDelimiterThrowsException_Deprecated() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote('!').withDelimiter('!'));\n+    }\n+\n+    @Test\n+    public void testQuoteModeNoneShouldReturnMeaningfulExceptionMessage() {\n+        final Exception exception = assertThrows(IllegalArgumentException.class, () ->\n+        // @formatter:off\n+            CSVFormat.DEFAULT.builder()\n+                    .setHeader(\"Col1\", \"Col2\", \"Col3\", \"Col4\")\n+                    .setQuoteMode(QuoteMode.NONE)\n+                    .get()\n+        // @formatter:on\n+        );\n+        final String actualMessage = exception.getMessage();\n+        final String expectedMessage = \"Quote mode set to NONE but no escape character is set\";\n+        assertEquals(expectedMessage, actualMessage);\n+    }\n+\n+    @Test\n+    public void testQuotePolicyNoneWithoutEscapeThrowsException() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat('!').builder().setQuoteMode(QuoteMode.NONE).get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testQuotePolicyNoneWithoutEscapeThrowsException_Deprecated() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat('!').withQuoteMode(QuoteMode.NONE));\n+    }\n+\n+    @Test\n+    public void testRFC4180() {\n+        assertNull(RFC4180.getCommentMarker());\n+        assertEquals(',', RFC4180.getDelimiter());\n+        assertNull(RFC4180.getEscapeCharacter());\n+        assertFalse(RFC4180.getIgnoreEmptyLines());\n+        assertEquals(Character.valueOf('\"'), RFC4180.getQuoteCharacter());\n+        assertNull(RFC4180.getQuoteMode());\n+        assertEquals(\"\\r\\n\", RFC4180.getRecordSeparator());\n+    }\n+\n+    @SuppressWarnings(\"boxing\") // no need to worry about boxing here\n+    @Test\n+    public void testSerialization() throws Exception {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+\n+        try (ObjectOutputStream oos = new ObjectOutputStream(out)) {\n+            oos.writeObject(CSVFormat.DEFAULT);\n+            oos.flush();\n+        }\n+\n+        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n+        final CSVFormat format = (CSVFormat) in.readObject();\n+\n+        assertNotNull(format);\n+        assertEquals(CSVFormat.DEFAULT.getDelimiter(), format.getDelimiter(), \"delimiter\");\n+        assertEquals(CSVFormat.DEFAULT.getQuoteCharacter(), format.getQuoteCharacter(), \"encapsulator\");\n+        assertEquals(CSVFormat.DEFAULT.getCommentMarker(), format.getCommentMarker(), \"comment start\");\n+        assertEquals(CSVFormat.DEFAULT.getRecordSeparator(), format.getRecordSeparator(), \"record separator\");\n+        assertEquals(CSVFormat.DEFAULT.getEscapeCharacter(), format.getEscapeCharacter(), \"escape\");\n+        assertEquals(CSVFormat.DEFAULT.getIgnoreSurroundingSpaces(), format.getIgnoreSurroundingSpaces(), \"trim\");\n+        assertEquals(CSVFormat.DEFAULT.getIgnoreEmptyLines(), format.getIgnoreEmptyLines(), \"empty lines\");\n+    }\n+\n+    @Test\n+    public void testToString() {\n+\n+        final String string = CSVFormat.INFORMIX_UNLOAD.toString();\n+\n+        assertEquals(\"Delimiter=<|> Escape=<\\\\> QuoteChar=<\\\"> RecordSeparator=<\\n> EmptyLines:ignored SkipHeaderRecord:false\", string);\n+\n+    }\n+\n+    @Test\n+    public void testToStringAndWithCommentMarkerTakingCharacter() {\n+\n+        final CSVFormat.Predefined csvFormatPredefined = CSVFormat.Predefined.Default;\n+        final CSVFormat csvFormat = csvFormatPredefined.getFormat();\n+\n+        assertNull(csvFormat.getEscapeCharacter());\n+        assertTrue(csvFormat.isQuoteCharacterSet());\n+\n+        assertFalse(csvFormat.getTrim());\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+        assertEquals(',', csvFormat.getDelimiter());\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\n+\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+        assertNull(csvFormat.getCommentMarker());\n+\n+        assertFalse(csvFormat.isNullStringSet());\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+\n+        assertFalse(csvFormat.isEscapeCharacterSet());\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+\n+        assertNull(csvFormat.getNullString());\n+        assertNull(csvFormat.getQuoteMode());\n+\n+        assertTrue(csvFormat.getIgnoreEmptyLines());\n+        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\n+\n+        final Character character = Character.valueOf('n');\n+\n+        final CSVFormat csvFormatTwo = csvFormat.withCommentMarker(character);\n+\n+        assertNull(csvFormat.getEscapeCharacter());\n+        assertTrue(csvFormat.isQuoteCharacterSet());\n+\n+        assertFalse(csvFormat.getTrim());\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+        assertEquals(',', csvFormat.getDelimiter());\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\n+\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+        assertNull(csvFormat.getCommentMarker());\n+\n+        assertFalse(csvFormat.isNullStringSet());\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+\n+        assertFalse(csvFormat.isEscapeCharacterSet());\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+\n+        assertNull(csvFormat.getNullString());\n+        assertNull(csvFormat.getQuoteMode());\n+\n+        assertTrue(csvFormat.getIgnoreEmptyLines());\n+        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\n+\n+        assertFalse(csvFormatTwo.isNullStringSet());\n+        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\n+\n+        assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\n+        assertNull(csvFormatTwo.getNullString());\n+\n+        assertEquals(',', csvFormatTwo.getDelimiter());\n+        assertFalse(csvFormatTwo.getTrailingDelimiter());\n+\n+        assertTrue(csvFormatTwo.isCommentMarkerSet());\n+        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\n+\n+        assertFalse(csvFormatTwo.getTrim());\n+        assertNull(csvFormatTwo.getEscapeCharacter());\n+\n+        assertTrue(csvFormatTwo.isQuoteCharacterSet());\n+        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\n+\n+        assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\n+        assertNull(csvFormatTwo.getQuoteMode());\n+\n+        assertEquals('n', (char) csvFormatTwo.getCommentMarker());\n+        assertFalse(csvFormatTwo.getSkipHeaderRecord());\n+\n+        assertFalse(csvFormatTwo.isEscapeCharacterSet());\n+        assertTrue(csvFormatTwo.getIgnoreEmptyLines());\n+\n+        assertNotSame(csvFormat, csvFormatTwo);\n+        assertNotSame(csvFormatTwo, csvFormat);\n+\n+        Assertions.assertNotEquals(csvFormatTwo, csvFormat);\n+\n+        assertNull(csvFormat.getEscapeCharacter());\n+        assertTrue(csvFormat.isQuoteCharacterSet());\n+\n+        assertFalse(csvFormat.getTrim());\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+        assertEquals(',', csvFormat.getDelimiter());\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\n+\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+        assertNull(csvFormat.getCommentMarker());\n+\n+        assertFalse(csvFormat.isNullStringSet());\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+\n+        assertFalse(csvFormat.isEscapeCharacterSet());\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+\n+        assertNull(csvFormat.getNullString());\n+        assertNull(csvFormat.getQuoteMode());\n+\n+        assertTrue(csvFormat.getIgnoreEmptyLines());\n+        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\n+\n+        assertFalse(csvFormatTwo.isNullStringSet());\n+        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\n+\n+        assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\n+        assertNull(csvFormatTwo.getNullString());\n+\n+        assertEquals(',', csvFormatTwo.getDelimiter());\n+        assertFalse(csvFormatTwo.getTrailingDelimiter());\n+\n+        assertTrue(csvFormatTwo.isCommentMarkerSet());\n+        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\n+\n+        assertFalse(csvFormatTwo.getTrim());\n+        assertNull(csvFormatTwo.getEscapeCharacter());\n+\n+        assertTrue(csvFormatTwo.isQuoteCharacterSet());\n+        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\n+\n+        assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\n+        assertNull(csvFormatTwo.getQuoteMode());\n+\n+        assertEquals('n', (char) csvFormatTwo.getCommentMarker());\n+        assertFalse(csvFormatTwo.getSkipHeaderRecord());\n+\n+        assertFalse(csvFormatTwo.isEscapeCharacterSet());\n+        assertTrue(csvFormatTwo.getIgnoreEmptyLines());\n+\n+        assertNotSame(csvFormat, csvFormatTwo);\n+        assertNotSame(csvFormatTwo, csvFormat);\n+\n+        Assertions.assertNotEquals(csvFormat, csvFormatTwo);\n+\n+        Assertions.assertNotEquals(csvFormatTwo, csvFormat);\n+        assertEquals(\"Delimiter=<,> QuoteChar=<\\\"> CommentStart=<n> \" + \"RecordSeparator=<\\r\\n> EmptyLines:ignored SkipHeaderRecord:false\",\n+                csvFormatTwo.toString());\n+\n+    }\n+\n+    @Test\n+    public void testTrim() throws IOException {\n+        final CSVFormat formatWithTrim = CSVFormat.DEFAULT.withDelimiter(',').withTrim().withQuote(null).withRecordSeparator(CRLF);\n+\n+        CharSequence in = \"a,b,c\";\n+        final StringBuilder out = new StringBuilder();\n+        formatWithTrim.print(in, out, true);\n+        assertEquals(\"a,b,c\", out.toString());\n+\n+        in = new StringBuilder(\" x,y,z\");\n+        out.setLength(0);\n+        formatWithTrim.print(in, out, true);\n+        assertEquals(\"x,y,z\", out.toString());\n+\n+        in = new StringBuilder(\"\");\n+        out.setLength(0);\n+        formatWithTrim.print(in, out, true);\n+        assertEquals(\"\", out.toString());\n+\n+        in = new StringBuilder(\"header\\r\\n\");\n+        out.setLength(0);\n+        formatWithTrim.print(in, out, true);\n+        assertEquals(\"header\", out.toString());\n+    }\n+\n+    @Test\n+    public void testWithCommentStart() {\n+        final CSVFormat formatWithCommentStart = CSVFormat.DEFAULT.withCommentMarker('#');\n+        assertEquals(Character.valueOf('#'), formatWithCommentStart.getCommentMarker());\n+    }\n+\n+    @Test\n+    public void testWithCommentStartCRThrowsException() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withCommentMarker(CR));\n+    }\n+\n+    @Test\n+    public void testWithDelimiter() {\n+        final CSVFormat formatWithDelimiter = CSVFormat.DEFAULT.withDelimiter('!');\n+        assertEquals('!', formatWithDelimiter.getDelimiter());\n+    }\n+\n+    @Test\n+    public void testWithDelimiterLFThrowsException() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter(LF));\n+    }\n+\n+    @Test\n+    public void testWithEmptyDuplicates() {\n+        final CSVFormat formatWithEmptyDuplicates = CSVFormat.DEFAULT.builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).get();\n+\n+        assertEquals(DuplicateHeaderMode.ALLOW_EMPTY, formatWithEmptyDuplicates.getDuplicateHeaderMode());\n+        assertFalse(formatWithEmptyDuplicates.getAllowDuplicateHeaderNames());\n+    }\n+\n+    @Test\n+    public void testWithEmptyEnum() {\n+        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(EmptyEnum.class);\n+        assertEquals(0, formatWithHeader.getHeader().length);\n+    }\n+\n+    @Test\n+    public void testWithEscape() {\n+        final CSVFormat formatWithEscape = CSVFormat.DEFAULT.withEscape('&');\n+        assertEquals(Character.valueOf('&'), formatWithEscape.getEscapeCharacter());\n+    }\n+\n+    @Test\n+    public void testWithEscapeCRThrowsExceptions() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withEscape(CR));\n+    }\n+\n+    @Test\n+    public void testWithFirstRecordAsHeader() {\n+        final CSVFormat formatWithFirstRecordAsHeader = CSVFormat.DEFAULT.withFirstRecordAsHeader();\n+        assertTrue(formatWithFirstRecordAsHeader.getSkipHeaderRecord());\n+        assertEquals(0, formatWithFirstRecordAsHeader.getHeader().length);\n+    }\n+\n+    @Test\n+    public void testWithHeader() {\n+        final String[] header = { \"one\", \"two\", \"three\" };\n+        // withHeader() makes a copy of the header array.\n+        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(header);\n+        assertArrayEquals(header, formatWithHeader.getHeader());\n+        assertNotSame(header, formatWithHeader.getHeader());\n+    }\n+\n+    @Test\n+    public void testWithHeaderComments() {\n+\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT;\n+\n+        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+\n+        assertFalse(csvFormat.isEscapeCharacterSet());\n+        assertTrue(csvFormat.isQuoteCharacterSet());\n+\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+        assertNull(csvFormat.getQuoteMode());\n+\n+        assertEquals(',', csvFormat.getDelimiter());\n+        assertTrue(csvFormat.getIgnoreEmptyLines());\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertNull(csvFormat.getCommentMarker());\n+\n+        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+        assertFalse(csvFormat.getTrim());\n+\n+        assertFalse(csvFormat.isNullStringSet());\n+        assertNull(csvFormat.getNullString());\n+\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+        assertNull(csvFormat.getEscapeCharacter());\n+\n+        final Object[] objectArray = new Object[8];\n+        final CSVFormat csvFormatTwo = csvFormat.withHeaderComments(objectArray);\n+\n+        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+\n+        assertFalse(csvFormat.isEscapeCharacterSet());\n+        assertTrue(csvFormat.isQuoteCharacterSet());\n+\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+        assertNull(csvFormat.getQuoteMode());\n+\n+        assertEquals(',', csvFormat.getDelimiter());\n+        assertTrue(csvFormat.getIgnoreEmptyLines());\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertNull(csvFormat.getCommentMarker());\n+\n+        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+        assertFalse(csvFormat.getTrim());\n+\n+        assertFalse(csvFormat.isNullStringSet());\n+        assertNull(csvFormat.getNullString());\n+\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+        assertNull(csvFormat.getEscapeCharacter());\n+\n+        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\n+        assertNull(csvFormatTwo.getQuoteMode());\n+\n+        assertTrue(csvFormatTwo.getIgnoreEmptyLines());\n+        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\n+\n+        assertNull(csvFormatTwo.getEscapeCharacter());\n+        assertFalse(csvFormatTwo.getTrim());\n+\n+        assertFalse(csvFormatTwo.isEscapeCharacterSet());\n+        assertTrue(csvFormatTwo.isQuoteCharacterSet());\n+\n+        assertFalse(csvFormatTwo.getSkipHeaderRecord());\n+        assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\n+\n+        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\n+        assertNull(csvFormatTwo.getNullString());\n+\n+        assertFalse(csvFormatTwo.isNullStringSet());\n+        assertFalse(csvFormatTwo.getTrailingDelimiter());\n+\n+        assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\n+        assertEquals(',', csvFormatTwo.getDelimiter());\n+\n+        assertNull(csvFormatTwo.getCommentMarker());\n+        assertFalse(csvFormatTwo.isCommentMarkerSet());\n+\n+        assertNotSame(csvFormat, csvFormatTwo);\n+        assertNotSame(csvFormatTwo, csvFormat);\n+\n+        Assertions.assertNotEquals(csvFormatTwo, csvFormat); // CSV-244 - should not be equal\n+\n+        final String string = csvFormatTwo.format(objectArray);\n+\n+        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+\n+        assertFalse(csvFormat.isEscapeCharacterSet());\n+        assertTrue(csvFormat.isQuoteCharacterSet());\n+\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+        assertNull(csvFormat.getQuoteMode());\n+\n+        assertEquals(',', csvFormat.getDelimiter());\n+        assertTrue(csvFormat.getIgnoreEmptyLines());\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertNull(csvFormat.getCommentMarker());\n+\n+        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+        assertFalse(csvFormat.getTrim());\n+\n+        assertFalse(csvFormat.isNullStringSet());\n+        assertNull(csvFormat.getNullString());\n+\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+        assertNull(csvFormat.getEscapeCharacter());\n+\n+        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\n+        assertNull(csvFormatTwo.getQuoteMode());\n+\n+        assertTrue(csvFormatTwo.getIgnoreEmptyLines());\n+        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\n+\n+        assertNull(csvFormatTwo.getEscapeCharacter());\n+        assertFalse(csvFormatTwo.getTrim());\n+\n+        assertFalse(csvFormatTwo.isEscapeCharacterSet());\n+        assertTrue(csvFormatTwo.isQuoteCharacterSet());\n+\n+        assertFalse(csvFormatTwo.getSkipHeaderRecord());\n+        assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\n+\n+        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\n+        assertNull(csvFormatTwo.getNullString());\n+\n+        assertFalse(csvFormatTwo.isNullStringSet());\n+        assertFalse(csvFormatTwo.getTrailingDelimiter());\n+\n+        assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\n+        assertEquals(',', csvFormatTwo.getDelimiter());\n+\n+        assertNull(csvFormatTwo.getCommentMarker());\n+        assertFalse(csvFormatTwo.isCommentMarkerSet());\n+\n+        assertNotSame(csvFormat, csvFormatTwo);\n+        assertNotSame(csvFormatTwo, csvFormat);\n+\n+        assertNotNull(string);\n+        Assertions.assertNotEquals(csvFormat, csvFormatTwo); // CSV-244 - should not be equal\n+\n+        Assertions.assertNotEquals(csvFormatTwo, csvFormat); // CSV-244 - should not be equal\n+        assertEquals(\",,,,,,,\", string);\n+\n+    }\n+\n+    @Test\n+    public void testWithHeaderEnum() {\n+        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(Header.class);\n+        assertArrayEquals(new String[] { \"Name\", \"Email\", \"Phone\" }, formatWithHeader.getHeader());\n+    }\n+\n+    @Test\n+    public void testWithHeaderEnumNull() {\n+        final CSVFormat format = CSVFormat.DEFAULT;\n+        final Class<Enum<?>> simpleName = null;\n+        format.withHeader(simpleName);\n+    }\n+\n+    @Test\n+    public void testWithHeaderResultSetNull() throws SQLException {\n+        final CSVFormat format = CSVFormat.DEFAULT;\n+        final ResultSet resultSet = null;\n+        format.withHeader(resultSet);\n+    }\n+\n+    @Test\n+    public void testWithIgnoreEmptyLines() {\n+        assertFalse(CSVFormat.DEFAULT.withIgnoreEmptyLines(false).getIgnoreEmptyLines());\n+        assertTrue(CSVFormat.DEFAULT.withIgnoreEmptyLines().getIgnoreEmptyLines());\n+    }\n+\n+    @Test\n+    public void testWithIgnoreSurround() {\n+        assertFalse(CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(false).getIgnoreSurroundingSpaces());\n+        assertTrue(CSVFormat.DEFAULT.withIgnoreSurroundingSpaces().getIgnoreSurroundingSpaces());\n+    }\n+\n+    @Test\n+    public void testWithNullString() {\n+        final CSVFormat formatWithNullString = CSVFormat.DEFAULT.withNullString(\"null\");\n+        assertEquals(\"null\", formatWithNullString.getNullString());\n+    }\n+\n+    @Test\n+    public void testWithQuoteChar() {\n+        final CSVFormat formatWithQuoteChar = CSVFormat.DEFAULT.withQuote('\"');\n+        assertEquals(Character.valueOf('\"'), formatWithQuoteChar.getQuoteCharacter());\n+    }\n+\n+    @Test\n+    public void testWithQuoteLFThrowsException() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote(LF));\n+    }\n+\n+    @Test\n+    public void testWithQuotePolicy() {\n+        final CSVFormat formatWithQuotePolicy = CSVFormat.DEFAULT.withQuoteMode(QuoteMode.ALL);\n+        assertEquals(QuoteMode.ALL, formatWithQuotePolicy.getQuoteMode());\n+    }\n+\n+    @Test\n+    public void testWithRecordSeparatorCR() {\n+        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator(CR);\n+        assertEquals(String.valueOf(CR), formatWithRecordSeparator.getRecordSeparator());\n+    }\n+\n+    @Test\n+    public void testWithRecordSeparatorCRLF() {\n+        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator(CRLF);\n+        assertEquals(CRLF, formatWithRecordSeparator.getRecordSeparator());\n+    }\n+\n+    @Test\n+    public void testWithRecordSeparatorLF() {\n+        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator(LF);\n+        assertEquals(String.valueOf(LF), formatWithRecordSeparator.getRecordSeparator());\n+    }\n+\n+    @Test\n+    public void testWithSystemRecordSeparator() {\n+        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withSystemRecordSeparator();\n+        assertEquals(System.lineSeparator(), formatWithRecordSeparator.getRecordSeparator());\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/csv/CSVParserTest.java b/src/test/java/org/apache/commons/csv/CSVParserTest.java\nindex da49a78c..38d442e5 100644\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n@@ -1,1812 +1,1812 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv;\r\n-\r\n-import static org.apache.commons.csv.Constants.CR;\r\n-import static org.apache.commons.csv.Constants.CRLF;\r\n-import static org.apache.commons.csv.Constants.LF;\r\n-import static org.junit.jupiter.api.Assertions.assertArrayEquals;\r\n-import static org.junit.jupiter.api.Assertions.assertEquals;\r\n-import static org.junit.jupiter.api.Assertions.assertFalse;\r\n-import static org.junit.jupiter.api.Assertions.assertInstanceOf;\r\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\r\n-import static org.junit.jupiter.api.Assertions.assertNull;\r\n-import static org.junit.jupiter.api.Assertions.assertThrows;\r\n-import static org.junit.jupiter.api.Assertions.assertTrue;\r\n-\r\n-import java.io.File;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.PipedReader;\r\n-import java.io.PipedWriter;\r\n-import java.io.Reader;\r\n-import java.io.StringReader;\r\n-import java.io.StringWriter;\r\n-import java.io.UncheckedIOException;\r\n-import java.net.URL;\r\n-import java.nio.charset.Charset;\r\n-import java.nio.charset.StandardCharsets;\r\n-import java.nio.file.Files;\r\n-import java.nio.file.Path;\r\n-import java.nio.file.Paths;\r\n-import java.util.ArrayList;\r\n-import java.util.Arrays;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.NoSuchElementException;\r\n-import java.util.stream.Collectors;\r\n-import java.util.stream.Stream;\r\n-\r\n-import org.apache.commons.io.input.BOMInputStream;\r\n-import org.apache.commons.io.input.BrokenInputStream;\r\n-import org.junit.jupiter.api.Assertions;\r\n-import org.junit.jupiter.api.Disabled;\r\n-import org.junit.jupiter.api.Test;\r\n-import org.junit.jupiter.params.ParameterizedTest;\r\n-import org.junit.jupiter.params.provider.EnumSource;\r\n-\r\n-/**\r\n- * CSVParserTest\r\n- *\r\n- * The test are organized in three different sections: The 'setter/getter' section, the lexer section and finally the parser section. In case a test fails, you\r\n- * should follow a top-down approach for fixing a potential bug (its likely that the parser itself fails if the lexer has problems...).\r\n- */\r\n-public class CSVParserTest {\r\n-\r\n-    private static final CSVFormat EXCEL_WITH_HEADER = CSVFormat.EXCEL.withHeader();\r\n-\r\n-    private static final Charset UTF_8 = StandardCharsets.UTF_8;\r\n-\r\n-    private static final String UTF_8_NAME = UTF_8.name();\r\n-\r\n-    private static final String CSV_INPUT = \"a,b,c,d\\n\" + \" a , b , 1 2 \\n\" + \"\\\"foo baar\\\", b,\\n\" +\r\n-            // + \" \\\"foo\\n,,\\n\\\"\\\",,\\n\\\\\\\"\\\",d,e\\n\";\r\n-            \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\"\\\"\\\",d,e\\n\"; // changed to use standard CSV escaping\r\n-\r\n-    private static final String CSV_INPUT_1 = \"a,b,c,d\";\r\n-\r\n-    private static final String CSV_INPUT_2 = \"a,b,1 2\";\r\n-\r\n-    private static final String[][] RESULT = { { \"a\", \"b\", \"c\", \"d\" }, { \"a\", \"b\", \"1 2\" }, { \"foo baar\", \"b\", \"\" }, { \"foo\\n,,\\n\\\",,\\n\\\"\", \"d\", \"e\" } };\r\n-\r\n-    // CSV with no header comments\r\n-    private static final String CSV_INPUT_NO_COMMENT = \"A,B\" + CRLF + \"1,2\" + CRLF;\r\n-\r\n-    // CSV with a header comment\r\n-    private static final String CSV_INPUT_HEADER_COMMENT = \"# header comment\" + CRLF + \"A,B\" + CRLF + \"1,2\" + CRLF;\r\n-\r\n-    // CSV with a single line header and trailer comment\r\n-    private static final String CSV_INPUT_HEADER_TRAILER_COMMENT = \"# header comment\" + CRLF + \"A,B\" + CRLF + \"1,2\" + CRLF + \"# comment\";\r\n-\r\n-    // CSV with a multi-line header and trailer comment\r\n-    private static final String CSV_INPUT_MULTILINE_HEADER_TRAILER_COMMENT = \"# multi-line\" + CRLF + \"# header comment\" + CRLF + \"A,B\" + CRLF + \"1,2\" + CRLF +\r\n-            \"# multi-line\" + CRLF + \"# comment\";\r\n-\r\n-    // Format with auto-detected header\r\n-    private static final CSVFormat FORMAT_AUTO_HEADER = CSVFormat.Builder.create(CSVFormat.DEFAULT).setCommentMarker('#').setHeader().get();\r\n-\r\n-    // Format with explicit header\r\n-    // @formatter:off\r\n-    private static final CSVFormat FORMAT_EXPLICIT_HEADER = CSVFormat.Builder.create(CSVFormat.DEFAULT)\r\n-            .setSkipHeaderRecord(true)\r\n-            .setCommentMarker('#')\r\n-            .setHeader(\"A\", \"B\")\r\n-            .get();\r\n-    // @formatter:on\r\n-\r\n-    // Format with explicit header that does not skip the header line\r\n-    // @formatter:off\r\n-    CSVFormat FORMAT_EXPLICIT_HEADER_NOSKIP = CSVFormat.Builder.create(CSVFormat.DEFAULT)\r\n-            .setCommentMarker('#')\r\n-            .setHeader(\"A\", \"B\")\r\n-            .get();\r\n-    // @formatter:on\r\n-\r\n-    @SuppressWarnings(\"resource\") // caller releases\r\n-    private BOMInputStream createBOMInputStream(final String resource) throws IOException {\r\n-        return new BOMInputStream(ClassLoader.getSystemClassLoader().getResource(resource).openStream());\r\n-    }\r\n-\r\n-    CSVRecord parse(final CSVParser parser, final int failParseRecordNo) throws IOException {\r\n-        if (parser.getRecordNumber() + 1 == failParseRecordNo) {\r\n-            assertThrows(IOException.class, () -> parser.nextRecord());\r\n-            return null;\r\n-        }\r\n-        return parser.nextRecord();\r\n-    }\r\n-\r\n-    private void parseFully(final CSVParser parser) {\r\n-        parser.forEach(Assertions::assertNotNull);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testBackslashEscaping() throws IOException {\r\n-        // To avoid confusion over the need for escaping chars in java code,\r\n-        // We will test with a forward slash as the escape char, and a single\r\n-        // quote as the encapsulator.\r\n-\r\n-        // @formatter:off\r\n-        final String code = \"one,two,three\\n\" + // 0\r\n-            \"'',''\\n\" + // 1) empty encapsulators\r\n-            \"/',/'\\n\" + // 2) single encapsulators\r\n-            \"'/'','/''\\n\" + // 3) single encapsulators encapsulated via escape\r\n-            \"'''',''''\\n\" + // 4) single encapsulators encapsulated via doubling\r\n-            \"/,,/,\\n\" + // 5) separator escaped\r\n-            \"//,//\\n\" + // 6) escape escaped\r\n-            \"'//','//'\\n\" + // 7) escape escaped in encapsulation\r\n-            \"   8   ,   \\\"quoted \\\"\\\" /\\\" // string\\\"   \\n\" + // don't eat spaces\r\n-            \"9,   /\\n   \\n\" + // escaped newline\r\n-            \"\";\r\n-        final String[][] res = {{\"one\", \"two\", \"three\"}, // 0\r\n-            {\"\", \"\"}, // 1\r\n-            {\"'\", \"'\"}, // 2\r\n-            {\"'\", \"'\"}, // 3\r\n-            {\"'\", \"'\"}, // 4\r\n-            {\",\", \",\"}, // 5\r\n-            {\"/\", \"/\"}, // 6\r\n-            {\"/\", \"/\"}, // 7\r\n-            {\"   8   \", \"   \\\"quoted \\\"\\\" /\\\" / string\\\"   \"}, {\"9\", \"   \\n   \"} };\r\n-        // @formatter:on\r\n-        final CSVFormat format = CSVFormat.newFormat(',').withQuote('\\'').withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines();\r\n-        try (CSVParser parser = CSVParser.parse(code, format)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertFalse(records.isEmpty());\r\n-            Utils.compare(\"Records do not match expected result\", res, records);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testBackslashEscaping2() throws IOException {\r\n-        // To avoid confusion over the need for escaping chars in java code,\r\n-        // We will test with a forward slash as the escape char, and a single\r\n-        // quote as the encapsulator.\r\n-        // @formatter:off\r\n-        final String code = \"\" + \" , , \\n\" + // 1)\r\n-            \" \\t ,  , \\n\" + // 2)\r\n-            \" // , /, , /,\\n\" + // 3)\r\n-            \"\";\r\n-        final String[][] res = {{\" \", \" \", \" \"}, // 1\r\n-            {\" \\t \", \"  \", \" \"}, // 2\r\n-            {\" / \", \" , \", \" ,\"}, // 3\r\n-        };\r\n-        // @formatter:on\r\n-        final CSVFormat format = CSVFormat.newFormat(',').withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines();\r\n-        try (CSVParser parser = CSVParser.parse(code, format)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertFalse(records.isEmpty());\r\n-            Utils.compare(\"\", res, records);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testBackslashEscapingOld() throws IOException {\r\n-        final String code = \"one,two,three\\n\" + \"on\\\\\\\"e,two\\n\" + \"on\\\"e,two\\n\" + \"one,\\\"tw\\\\\\\"o\\\"\\n\" + \"one,\\\"t\\\\,wo\\\"\\n\" + \"one,two,\\\"th,ree\\\"\\n\" +\r\n-                \"\\\"a\\\\\\\\\\\"\\n\" + \"a\\\\,b\\n\" + \"\\\"a\\\\\\\\,b\\\"\";\r\n-        final String[][] res = { { \"one\", \"two\", \"three\" }, { \"on\\\\\\\"e\", \"two\" }, { \"on\\\"e\", \"two\" }, { \"one\", \"tw\\\"o\" }, { \"one\", \"t\\\\,wo\" }, // backslash in\r\n-                                                                                                                                               // quotes only\r\n-                                                                                                                                               // escapes a\r\n-                                                                                                                                               // delimiter\r\n-                                                                                                                                               // (\",\")\r\n-                { \"one\", \"two\", \"th,ree\" }, { \"a\\\\\\\\\" }, // backslash in quotes only escapes a delimiter (\",\")\r\n-                { \"a\\\\\", \"b\" }, // a backslash must be returned\r\n-                { \"a\\\\\\\\,b\" } // backslash in quotes only escapes a delimiter (\",\")\r\n-        };\r\n-        try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(res.length, records.size());\r\n-            assertFalse(records.isEmpty());\r\n-            for (int i = 0; i < res.length; i++) {\r\n-                assertArrayEquals(res[i], records.get(i).values());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled(\"CSV-107\")\r\n-    public void testBOM() throws IOException {\r\n-        final URL url = ClassLoader.getSystemClassLoader().getResource(\"org/apache/commons/csv/CSVFileParser/bom.csv\");\r\n-        try (CSVParser parser = CSVParser.parse(url, StandardCharsets.UTF_8, EXCEL_WITH_HEADER)) {\r\n-            parser.forEach(record -> assertNotNull(record.get(\"Date\")));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testBOMInputStreamParserWithInputStream() throws IOException {\r\n-        try (BOMInputStream inputStream = createBOMInputStream(\"org/apache/commons/csv/CSVFileParser/bom.csv\");\r\n-                CSVParser parser = CSVParser.parse(inputStream, UTF_8, EXCEL_WITH_HEADER)) {\r\n-            parser.forEach(record -> assertNotNull(record.get(\"Date\")));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testBOMInputStreamParserWithReader() throws IOException {\r\n-        try (Reader reader = new InputStreamReader(createBOMInputStream(\"org/apache/commons/csv/CSVFileParser/bom.csv\"), UTF_8_NAME);\r\n-                CSVParser parser = CSVParser.builder()\r\n-                        .setReader(reader)\r\n-                        .setFormat(EXCEL_WITH_HEADER)\r\n-                        .get()) {\r\n-            parser.forEach(record -> assertNotNull(record.get(\"Date\")));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testBOMInputStreamParseWithReader() throws IOException {\r\n-        try (Reader reader = new InputStreamReader(createBOMInputStream(\"org/apache/commons/csv/CSVFileParser/bom.csv\"), UTF_8_NAME);\r\n-                CSVParser parser = CSVParser.builder()\r\n-                        .setReader(reader)\r\n-                        .setFormat(EXCEL_WITH_HEADER)\r\n-                        .get()) {\r\n-            parser.forEach(record -> assertNotNull(record.get(\"Date\")));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCarriageReturnEndings() throws IOException {\r\n-        final String string = \"foo\\rbaar,\\rhello,world\\r,kanu\";\r\n-        try (CSVParser parser = CSVParser.builder().setCharSequence(string).get()) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(4, records.size());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCarriageReturnLineFeedEndings() throws IOException {\r\n-        final String string = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\r\n-        try (CSVParser parser = CSVParser.builder().setCharSequence(string).get()) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(4, records.size());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testClose() throws Exception {\r\n-        final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\r\n-        final Iterator<CSVRecord> records;\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withCommentMarker('#').withHeader().parse(in)) {\r\n-            records = parser.iterator();\r\n-            assertTrue(records.hasNext());\r\n-        }\r\n-        assertFalse(records.hasNext());\r\n-        assertThrows(NoSuchElementException.class, records::next);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV141CSVFormat_DEFAULT() throws Exception {\r\n-        testCSV141Failure(CSVFormat.DEFAULT, 3);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV141CSVFormat_INFORMIX_UNLOAD() throws Exception {\r\n-        testCSV141Failure(CSVFormat.INFORMIX_UNLOAD, 1);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV141CSVFormat_INFORMIX_UNLOAD_CSV() throws Exception {\r\n-        testCSV141Failure(CSVFormat.INFORMIX_UNLOAD_CSV, 3);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV141CSVFormat_ORACLE() throws Exception {\r\n-        testCSV141Failure(CSVFormat.ORACLE, 2);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV141CSVFormat_POSTGRESQL_CSV() throws Exception {\r\n-        testCSV141Failure(CSVFormat.POSTGRESQL_CSV, 3);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV141Excel() throws Exception {\r\n-        testCSV141Ok(CSVFormat.EXCEL);\r\n-    }\r\n-\r\n-    private void testCSV141Failure(final CSVFormat format, final int failParseRecordNo) throws IOException {\r\n-        final Path path = Paths.get(\"src/test/resources/org/apache/commons/csv/CSV-141/csv-141.csv\");\r\n-        try (CSVParser parser = CSVParser.parse(path, StandardCharsets.UTF_8, format)) {\r\n-            // row 1\r\n-            CSVRecord record = parse(parser, failParseRecordNo);\r\n-            if (record == null) {\r\n-                return; // expected failure\r\n-            }\r\n-            assertEquals(\"1414770317901\", record.get(0));\r\n-            assertEquals(\"android.widget.EditText\", record.get(1));\r\n-            assertEquals(\"pass sem1 _84*|*\", record.get(2));\r\n-            assertEquals(\"0\", record.get(3));\r\n-            assertEquals(\"pass sem1 _8\", record.get(4));\r\n-            assertEquals(5, record.size());\r\n-            // row 2\r\n-            record = parse(parser, failParseRecordNo);\r\n-            if (record == null) {\r\n-                return; // expected failure\r\n-            }\r\n-            assertEquals(\"1414770318470\", record.get(0));\r\n-            assertEquals(\"android.widget.EditText\", record.get(1));\r\n-            assertEquals(\"pass sem1 _84:|\", record.get(2));\r\n-            assertEquals(\"0\", record.get(3));\r\n-            assertEquals(\"pass sem1 _84:\\\\\", record.get(4));\r\n-            assertEquals(5, record.size());\r\n-            // row 3: Fail for certain\r\n-            assertThrows(IOException.class, () -> parser.nextRecord());\r\n-        }\r\n-    }\r\n-\r\n-    private void testCSV141Ok(final CSVFormat format) throws IOException {\r\n-        final Path path = Paths.get(\"src/test/resources/org/apache/commons/csv/CSV-141/csv-141.csv\");\r\n-        try (CSVParser parser = CSVParser.parse(path, StandardCharsets.UTF_8, format)) {\r\n-            // row 1\r\n-            CSVRecord record = parser.nextRecord();\r\n-            assertEquals(\"1414770317901\", record.get(0));\r\n-            assertEquals(\"android.widget.EditText\", record.get(1));\r\n-            assertEquals(\"pass sem1 _84*|*\", record.get(2));\r\n-            assertEquals(\"0\", record.get(3));\r\n-            assertEquals(\"pass sem1 _8\", record.get(4));\r\n-            assertEquals(5, record.size());\r\n-            // row 2\r\n-            record = parser.nextRecord();\r\n-            assertEquals(\"1414770318470\", record.get(0));\r\n-            assertEquals(\"android.widget.EditText\", record.get(1));\r\n-            assertEquals(\"pass sem1 _84:|\", record.get(2));\r\n-            assertEquals(\"0\", record.get(3));\r\n-            assertEquals(\"pass sem1 _84:\\\\\", record.get(4));\r\n-            assertEquals(5, record.size());\r\n-            // row 3\r\n-            record = parser.nextRecord();\r\n-            assertEquals(\"1414770318327\", record.get(0));\r\n-            assertEquals(\"android.widget.EditText\", record.get(1));\r\n-            assertEquals(\"pass sem1\\n1414770318628\\\"\", record.get(2));\r\n-            assertEquals(\"android.widget.EditText\", record.get(3));\r\n-            assertEquals(\"pass sem1 _84*|*\", record.get(4));\r\n-            assertEquals(\"0\", record.get(5));\r\n-            assertEquals(\"pass sem1\\n\", record.get(6));\r\n-            assertEquals(7, record.size());\r\n-            // EOF\r\n-            record = parser.nextRecord();\r\n-            assertNull(record);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV141RFC4180() throws Exception {\r\n-        testCSV141Failure(CSVFormat.RFC4180, 3);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV235() throws IOException {\r\n-        final String dqString = \"\\\"aaa\\\",\\\"b\\\"\\\"bb\\\",\\\"ccc\\\"\"; // \"aaa\",\"b\"\"bb\",\"ccc\"\r\n-        try (CSVParser parser = CSVFormat.RFC4180.parse(new StringReader(dqString))) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            assertFalse(records.hasNext());\r\n-            assertEquals(3, record.size());\r\n-            assertEquals(\"aaa\", record.get(0));\r\n-            assertEquals(\"b\\\"bb\", record.get(1));\r\n-            assertEquals(\"ccc\", record.get(2));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV57() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT)) {\r\n-            final List<CSVRecord> list = parser.getRecords();\r\n-            assertNotNull(list);\r\n-            assertEquals(0, list.size());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDefaultFormat() throws IOException {\r\n-        // @formatter:off\r\n-        final String code = \"\" + \"a,b#\\n\" + // 1)\r\n-            \"\\\"\\n\\\",\\\" \\\",#\\n\" +            // 2)\r\n-            \"#,\\\"\\\"\\n\" +                    // 3)\r\n-            \"# Final comment\\n\"             // 4)\r\n-        ;\r\n-        // @formatter:on\r\n-        final String[][] res = { { \"a\", \"b#\" }, { \"\\n\", \" \", \"#\" }, { \"#\", \"\" }, { \"# Final comment\" } };\r\n-        CSVFormat format = CSVFormat.DEFAULT;\r\n-        assertFalse(format.isCommentMarkerSet());\r\n-        final String[][] resComments = { { \"a\", \"b#\" }, { \"\\n\", \" \", \"#\" } };\r\n-        try (CSVParser parser = CSVParser.parse(code, format)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertFalse(records.isEmpty());\r\n-            Utils.compare(\"Failed to parse without comments\", res, records);\r\n-            format = CSVFormat.DEFAULT.withCommentMarker('#');\r\n-        }\r\n-        try (CSVParser parser = CSVParser.parse(code, format)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            Utils.compare(\"Failed to parse with comments\", resComments, records);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDuplicateHeadersAllowedByDefault() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"a,b,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader())) {\r\n-            // noop\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDuplicateHeadersNotAllowed() {\r\n-        assertThrows(IllegalArgumentException.class,\r\n-                () -> CSVParser.parse(\"a,b,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader().withAllowDuplicateHeaderNames(false)));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEmptyFile() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(Paths.get(\"src/test/resources/org/apache/commons/csv/empty.txt\"), StandardCharsets.UTF_8,\r\n-                CSVFormat.DEFAULT)) {\r\n-            assertNull(parser.nextRecord());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEmptyFileHeaderParsing() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT.withFirstRecordAsHeader())) {\r\n-            assertNull(parser.nextRecord());\r\n-            assertTrue(parser.getHeaderNames().isEmpty());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEmptyLineBehaviorCSV() throws Exception {\r\n-        final String[] codes = { \"hello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\r\n-        final String[][] res = { { \"hello\", \"\" } // CSV format ignores empty lines\r\n-        };\r\n-        for (final String code : codes) {\r\n-            try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\r\n-                final List<CSVRecord> records = parser.getRecords();\r\n-                assertEquals(res.length, records.size());\r\n-                assertFalse(records.isEmpty());\r\n-                for (int i = 0; i < res.length; i++) {\r\n-                    assertArrayEquals(res[i], records.get(i).values());\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEmptyLineBehaviorExcel() throws Exception {\r\n-        final String[] codes = { \"hello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\r\n-        final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\r\n-                { \"\" } };\r\n-        for (final String code : codes) {\r\n-            try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\r\n-                final List<CSVRecord> records = parser.getRecords();\r\n-                assertEquals(res.length, records.size());\r\n-                assertFalse(records.isEmpty());\r\n-                for (int i = 0; i < res.length; i++) {\r\n-                    assertArrayEquals(res[i], records.get(i).values());\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEmptyString() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT)) {\r\n-            assertNull(parser.nextRecord());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEndOfFileBehaviorCSV() throws Exception {\r\n-        final String[] codes = { \"hello,\\r\\n\\r\\nworld,\\r\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\r\n-                \"hello,\\r\\n\\r\\nworld,\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\" };\r\n-        final String[][] res = { { \"hello\", \"\" }, // CSV format ignores empty lines\r\n-                { \"world\", \"\" } };\r\n-        for (final String code : codes) {\r\n-            try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\r\n-                final List<CSVRecord> records = parser.getRecords();\r\n-                assertEquals(res.length, records.size());\r\n-                assertFalse(records.isEmpty());\r\n-                for (int i = 0; i < res.length; i++) {\r\n-                    assertArrayEquals(res[i], records.get(i).values());\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEndOfFileBehaviorExcel() throws Exception {\r\n-        final String[] codes = { \"hello,\\r\\n\\r\\nworld,\\r\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\r\n-                \"hello,\\r\\n\\r\\nworld,\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\" };\r\n-        final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\r\n-                { \"world\", \"\" } };\r\n-\r\n-        for (final String code : codes) {\r\n-            try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\r\n-                final List<CSVRecord> records = parser.getRecords();\r\n-                assertEquals(res.length, records.size());\r\n-                assertFalse(records.isEmpty());\r\n-                for (int i = 0; i < res.length; i++) {\r\n-                    assertArrayEquals(res[i], records.get(i).values());\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelFormat1() throws IOException {\r\n-        final String code = \"value1,value2,value3,value4\\r\\na,b,c,d\\r\\n  x,,,\" + \"\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\",\\\"  \\\"\\\"world\\\"\\\"\\\",\\\"abc\\ndef\\\",\\r\\n\";\r\n-        final String[][] res = { { \"value1\", \"value2\", \"value3\", \"value4\" }, { \"a\", \"b\", \"c\", \"d\" }, { \"  x\", \"\", \"\", \"\" }, { \"\" },\r\n-                { \"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\" } };\r\n-        try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(res.length, records.size());\r\n-            assertFalse(records.isEmpty());\r\n-            for (int i = 0; i < res.length; i++) {\r\n-                assertArrayEquals(res[i], records.get(i).values());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelFormat2() throws Exception {\r\n-        final String code = \"foo,baar\\r\\n\\r\\nhello,\\r\\n\\r\\nworld,\\r\\n\";\r\n-        final String[][] res = { { \"foo\", \"baar\" }, { \"\" }, { \"hello\", \"\" }, { \"\" }, { \"world\", \"\" } };\r\n-        try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(res.length, records.size());\r\n-            assertFalse(records.isEmpty());\r\n-            for (int i = 0; i < res.length; i++) {\r\n-                assertArrayEquals(res[i], records.get(i).values());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Tests an exported Excel worksheet with a header row and rows that have more columns than the headers\r\n-     */\r\n-    @Test\r\n-    public void testExcelHeaderCountLessThanData() throws Exception {\r\n-        final String code = \"A,B,C,,\\r\\na,b,c,d,e\\r\\n\";\r\n-        try (CSVParser parser = CSVParser.parse(code, EXCEL_WITH_HEADER)) {\r\n-            parser.getRecords().forEach(record -> {\r\n-                assertEquals(\"a\", record.get(\"A\"));\r\n-                assertEquals(\"b\", record.get(\"B\"));\r\n-                assertEquals(\"c\", record.get(\"C\"));\r\n-            });\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testFirstEndOfLineCr() throws IOException {\r\n-        final String data = \"foo\\rbaar,\\rhello,world\\r,kanu\";\r\n-        try (CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(4, records.size());\r\n-            assertEquals(\"\\r\", parser.getFirstEndOfLine());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testFirstEndOfLineCrLf() throws IOException {\r\n-        final String data = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\r\n-        try (CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(4, records.size());\r\n-            assertEquals(\"\\r\\n\", parser.getFirstEndOfLine());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testFirstEndOfLineLf() throws IOException {\r\n-        final String data = \"foo\\nbaar,\\nhello,world\\n,kanu\";\r\n-        try (CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(4, records.size());\r\n-            assertEquals(\"\\n\", parser.getFirstEndOfLine());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testForEach() throws Exception {\r\n-        try (Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-                CSVParser parser = CSVFormat.DEFAULT.parse(in)) {\r\n-            final List<CSVRecord> records = new ArrayList<>();\r\n-            for (final CSVRecord record : parser) {\r\n-                records.add(record);\r\n-            }\r\n-            assertEquals(3, records.size());\r\n-            assertArrayEquals(new String[] { \"a\", \"b\", \"c\" }, records.get(0).values());\r\n-            assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, records.get(1).values());\r\n-            assertArrayEquals(new String[] { \"x\", \"y\", \"z\" }, records.get(2).values());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderComment_HeaderComment1() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_AUTO_HEADER)) {\r\n-            parser.getRecords();\r\n-            // Expect a header comment\r\n-            assertTrue(parser.hasHeaderComment());\r\n-            assertEquals(\"header comment\", parser.getHeaderComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderComment_HeaderComment2() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER)) {\r\n-            parser.getRecords();\r\n-            // Expect a header comment\r\n-            assertTrue(parser.hasHeaderComment());\r\n-            assertEquals(\"header comment\", parser.getHeaderComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderComment_HeaderComment3() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\r\n-            parser.getRecords();\r\n-            // Expect no header comment - the text \"comment\" is attached to the first record\r\n-            assertFalse(parser.hasHeaderComment());\r\n-            assertNull(parser.getHeaderComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderComment_HeaderTrailerComment() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_MULTILINE_HEADER_TRAILER_COMMENT, FORMAT_AUTO_HEADER)) {\r\n-            parser.getRecords();\r\n-            // Expect a header comment\r\n-            assertTrue(parser.hasHeaderComment());\r\n-            assertEquals(\"multi-line\" + LF + \"header comment\", parser.getHeaderComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderComment_NoComment1() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_NO_COMMENT, FORMAT_AUTO_HEADER)) {\r\n-            parser.getRecords();\r\n-            // Expect no header comment\r\n-            assertFalse(parser.hasHeaderComment());\r\n-            assertNull(parser.getHeaderComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderComment_NoComment2() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_NO_COMMENT, FORMAT_EXPLICIT_HEADER)) {\r\n-            parser.getRecords();\r\n-            // Expect no header comment\r\n-            assertFalse(parser.hasHeaderComment());\r\n-            assertNull(parser.getHeaderComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderComment_NoComment3() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_NO_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\r\n-            parser.getRecords();\r\n-            // Expect no header comment\r\n-            assertFalse(parser.hasHeaderComment());\r\n-            assertNull(parser.getHeaderComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderMap() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\r\n-            final Map<String, Integer> headerMap = parser.getHeaderMap();\r\n-            final Iterator<String> columnNames = headerMap.keySet().iterator();\r\n-            // Headers are iterated in column order.\r\n-            assertEquals(\"A\", columnNames.next());\r\n-            assertEquals(\"B\", columnNames.next());\r\n-            assertEquals(\"C\", columnNames.next());\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-\r\n-            // Parse to make sure getHeaderMap did not have a side-effect.\r\n-            for (int i = 0; i < 3; i++) {\r\n-                assertTrue(records.hasNext());\r\n-                final CSVRecord record = records.next();\r\n-                assertEquals(record.get(0), record.get(\"A\"));\r\n-                assertEquals(record.get(1), record.get(\"B\"));\r\n-                assertEquals(record.get(2), record.get(\"C\"));\r\n-            }\r\n-\r\n-            assertFalse(records.hasNext());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderNames() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\r\n-            final Map<String, Integer> nameIndexMap = parser.getHeaderMap();\r\n-            final List<String> headerNames = parser.getHeaderNames();\r\n-            assertNotNull(headerNames);\r\n-            assertEquals(nameIndexMap.size(), headerNames.size());\r\n-            for (int i = 0; i < headerNames.size(); i++) {\r\n-                final String name = headerNames.get(i);\r\n-                assertEquals(i, nameIndexMap.get(name).intValue());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderNamesReadOnly() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\r\n-            final List<String> headerNames = parser.getHeaderNames();\r\n-            assertNotNull(headerNames);\r\n-            assertThrows(UnsupportedOperationException.class, () -> headerNames.add(\"This is a read-only list.\"));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetLine() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\r\n-            for (final String[] re : RESULT) {\r\n-                assertArrayEquals(re, parser.nextRecord().values());\r\n-            }\r\n-\r\n-            assertNull(parser.nextRecord());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetLineNumberWithCR() throws Exception {\r\n-        validateLineNumbers(String.valueOf(CR));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetLineNumberWithCRLF() throws Exception {\r\n-        validateLineNumbers(CRLF);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetLineNumberWithLF() throws Exception {\r\n-        validateLineNumbers(String.valueOf(LF));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetOneLine() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_1, CSVFormat.DEFAULT)) {\r\n-            final CSVRecord record = parser.getRecords().get(0);\r\n-            assertArrayEquals(RESULT[0], record.values());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Tests reusing a parser to process new string records one at a time as they are being discovered. See [CSV-110].\r\n-     *\r\n-     * @throws IOException when an I/O error occurs.\r\n-     */\r\n-    @Test\r\n-    public void testGetOneLineOneParser() throws IOException {\r\n-        final CSVFormat format = CSVFormat.DEFAULT;\r\n-        try (PipedWriter writer = new PipedWriter();\r\n-                CSVParser parser = CSVParser.builder()\r\n-                        .setReader(new PipedReader(writer))\r\n-                        .setFormat(format)\r\n-                        .get()) {\r\n-            writer.append(CSV_INPUT_1);\r\n-            writer.append(format.getRecordSeparator());\r\n-            final CSVRecord record1 = parser.nextRecord();\r\n-            assertArrayEquals(RESULT[0], record1.values());\r\n-            writer.append(CSV_INPUT_2);\r\n-            writer.append(format.getRecordSeparator());\r\n-            final CSVRecord record2 = parser.nextRecord();\r\n-            assertArrayEquals(RESULT[1], record2.values());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordFourBytesRead() throws Exception {\r\n-        final String code = \"id,a,b,c\\n\" +\r\n-            \"1,,,\\n\" +\r\n-            \"2,,,\\n\" +\r\n-            \"3,,,\\n\";\r\n-        final CSVFormat format = CSVFormat.Builder.create()\r\n-            .setDelimiter(',')\r\n-            .setQuote('\\'')\r\n-            .get();\r\n-        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setTrackBytes(true).get()) {\r\n-            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n-\r\n-            assertEquals(0, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(1, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n-\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(2, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), 26);\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(4, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), 43);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordNumberWithCR() throws Exception {\r\n-        validateRecordNumbers(String.valueOf(CR));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordNumberWithCRLF() throws Exception {\r\n-        validateRecordNumbers(CRLF);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordNumberWithLF() throws Exception {\r\n-        validateRecordNumbers(String.valueOf(LF));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordPositionWithCRLF() throws Exception {\r\n-        validateRecordPosition(CRLF);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordPositionWithLF() throws Exception {\r\n-        validateRecordPosition(String.valueOf(LF));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecords() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(RESULT.length, records.size());\r\n-            assertFalse(records.isEmpty());\r\n-            for (int i = 0; i < RESULT.length; i++) {\r\n-                assertArrayEquals(RESULT[i], records.get(i).values());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordsFromBrokenInputStream() throws IOException {\r\n-        @SuppressWarnings(\"resource\") // We also get an exception on close, which is OK but can't assert in a try.\r\n-        final CSVParser parser = CSVParser.parse(new BrokenInputStream(), UTF_8, CSVFormat.DEFAULT);\r\n-        assertThrows(UncheckedIOException.class, parser::getRecords);\r\n-\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordThreeBytesRead() throws Exception {\r\n-        final String code = \"id,date,val5,val4\\n\" +\r\n-            \"11111111111111,'4017-09-01',,v4\\n\" +\r\n-            \"22222222222222,'4017-01-01',,v4\\n\" +\r\n-            \"33333333333333,'4017-01-01',,v4\\n\";\r\n-        final CSVFormat format = CSVFormat.Builder.create()\r\n-            .setDelimiter(',')\r\n-            .setQuote('\\'')\r\n-            .get();\r\n-        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setTrackBytes(true).get()) {\r\n-            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n-\r\n-            assertEquals(0, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(1, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n-\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(2, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n-\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), 95);\r\n-\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(4, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), 154);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordWithMultiLineValues() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF + \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\",\r\n-                CSVFormat.DEFAULT.withRecordSeparator(CRLF))) {\r\n-            CSVRecord record;\r\n-            assertEquals(0, parser.getRecordNumber());\r\n-            assertEquals(0, parser.getCurrentLineNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(3, parser.getCurrentLineNumber());\r\n-            assertEquals(1, record.getRecordNumber());\r\n-            assertEquals(1, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(6, parser.getCurrentLineNumber());\r\n-            assertEquals(2, record.getRecordNumber());\r\n-            assertEquals(2, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(9, parser.getCurrentLineNumber());\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(3, parser.getRecordNumber());\r\n-            assertNull(record = parser.nextRecord());\r\n-            assertEquals(9, parser.getCurrentLineNumber());\r\n-            assertEquals(3, parser.getRecordNumber());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetTrailerComment_HeaderComment1() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_AUTO_HEADER)) {\r\n-            parser.getRecords();\r\n-            assertFalse(parser.hasTrailerComment());\r\n-            assertNull(parser.getTrailerComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetTrailerComment_HeaderComment2() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER)) {\r\n-            parser.getRecords();\r\n-            assertFalse(parser.hasTrailerComment());\r\n-            assertNull(parser.getTrailerComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetTrailerComment_HeaderComment3() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\r\n-            parser.getRecords();\r\n-            assertFalse(parser.hasTrailerComment());\r\n-            assertNull(parser.getTrailerComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetTrailerComment_HeaderTrailerComment1() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_TRAILER_COMMENT, FORMAT_AUTO_HEADER)) {\r\n-            parser.getRecords();\r\n-            assertTrue(parser.hasTrailerComment());\r\n-            assertEquals(\"comment\", parser.getTrailerComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetTrailerComment_HeaderTrailerComment2() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_TRAILER_COMMENT, FORMAT_EXPLICIT_HEADER)) {\r\n-            parser.getRecords();\r\n-            assertTrue(parser.hasTrailerComment());\r\n-            assertEquals(\"comment\", parser.getTrailerComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetTrailerComment_HeaderTrailerComment3() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_TRAILER_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\r\n-            parser.getRecords();\r\n-            assertTrue(parser.hasTrailerComment());\r\n-            assertEquals(\"comment\", parser.getTrailerComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetTrailerComment_MultilineComment() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_MULTILINE_HEADER_TRAILER_COMMENT, FORMAT_AUTO_HEADER)) {\r\n-            parser.getRecords();\r\n-            assertTrue(parser.hasTrailerComment());\r\n-            assertEquals(\"multi-line\" + LF + \"comment\", parser.getTrailerComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeader() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-\r\n-            for (int i = 0; i < 2; i++) {\r\n-                assertTrue(records.hasNext());\r\n-                final CSVRecord record = records.next();\r\n-                assertEquals(record.get(0), record.get(\"a\"));\r\n-                assertEquals(record.get(1), record.get(\"b\"));\r\n-                assertEquals(record.get(2), record.get(\"c\"));\r\n-            }\r\n-\r\n-            assertFalse(records.hasNext());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeaderComment() throws Exception {\r\n-        final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withCommentMarker('#').withHeader().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            for (int i = 0; i < 2; i++) {\r\n-                assertTrue(records.hasNext());\r\n-                final CSVRecord record = records.next();\r\n-                assertEquals(record.get(0), record.get(\"a\"));\r\n-                assertEquals(record.get(1), record.get(\"b\"));\r\n-                assertEquals(record.get(2), record.get(\"c\"));\r\n-            }\r\n-            assertFalse(records.hasNext());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeaderMissing() throws Exception {\r\n-        final Reader in = new StringReader(\"a,,c\\n1,2,3\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            for (int i = 0; i < 2; i++) {\r\n-                assertTrue(records.hasNext());\r\n-                final CSVRecord record = records.next();\r\n-                assertEquals(record.get(0), record.get(\"a\"));\r\n-                assertEquals(record.get(2), record.get(\"c\"));\r\n-            }\r\n-            assertFalse(records.hasNext());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeaderMissingWithNull() throws Exception {\r\n-        final Reader in = new StringReader(\"a,,c,,e\\n1,2,3,4,5\\nv,w,x,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().withNullString(\"\").withAllowMissingColumnNames().parse(in)) {\r\n-            parser.iterator();\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeadersMissing() throws Exception {\r\n-        try (Reader in = new StringReader(\"a,,c,,e\\n1,2,3,4,5\\nv,w,x,y,z\");\r\n-                CSVParser parser = CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames().parse(in)) {\r\n-            parser.iterator();\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeadersMissingException() {\r\n-        final Reader in = new StringReader(\"a,,c,,e\\n1,2,3,4,5\\nv,w,x,y,z\");\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withHeader().parse(in).iterator());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeadersMissingOneColumnException() {\r\n-        final Reader in = new StringReader(\"a,,c,d,e\\n1,2,3,4,5\\nv,w,x,y,z\");\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withHeader().parse(in).iterator());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeadersWithNullColumnName() throws IOException {\r\n-        final Reader in = new StringReader(\"header1,null,header3\\n1,2,3\\n4,5,6\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().withNullString(\"null\").withAllowMissingColumnNames().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            // Expect the null header to be missing\r\n-            @SuppressWarnings(\"resource\")\r\n-            final CSVParser recordParser = record.getParser();\r\n-            assertEquals(Arrays.asList(\"header1\", \"header3\"), recordParser.getHeaderNames());\r\n-            assertEquals(2, recordParser.getHeaderMap().size());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testIgnoreCaseHeaderMapping() throws Exception {\r\n-        final Reader reader = new StringReader(\"1,2,3\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"One\", \"TWO\", \"three\").withIgnoreHeaderCase().parse(reader)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            assertEquals(\"1\", record.get(\"one\"));\r\n-            assertEquals(\"2\", record.get(\"two\"));\r\n-            assertEquals(\"3\", record.get(\"THREE\"));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testIgnoreEmptyLines() throws IOException {\r\n-        final String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\r\n-        // String code = \"world\\r\\n\\n\";\r\n-        // String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\r\n-        try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(3, records.size());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testInvalidFormat() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter(CR));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testIterator() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.parse(in)) {\r\n-            final Iterator<CSVRecord> iterator = parser.iterator();\r\n-            assertTrue(iterator.hasNext());\r\n-            assertThrows(UnsupportedOperationException.class, iterator::remove);\r\n-            assertArrayEquals(new String[] { \"a\", \"b\", \"c\" }, iterator.next().values());\r\n-            assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, iterator.next().values());\r\n-            assertTrue(iterator.hasNext());\r\n-            assertTrue(iterator.hasNext());\r\n-            assertTrue(iterator.hasNext());\r\n-            assertArrayEquals(new String[] { \"x\", \"y\", \"z\" }, iterator.next().values());\r\n-            assertFalse(iterator.hasNext());\r\n-            assertThrows(NoSuchElementException.class, iterator::next);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testIteratorSequenceBreaking() throws IOException {\r\n-        final String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\r\n-        // Iterator hasNext() shouldn't break sequence\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows))) {\r\n-            final Iterator<CSVRecord> iter = parser.iterator();\r\n-            int recordNumber = 0;\r\n-            while (iter.hasNext()) {\r\n-                final CSVRecord record = iter.next();\r\n-                recordNumber++;\r\n-                assertEquals(String.valueOf(recordNumber), record.get(0));\r\n-                if (recordNumber >= 2) {\r\n-                    break;\r\n-                }\r\n-            }\r\n-            iter.hasNext();\r\n-            while (iter.hasNext()) {\r\n-                final CSVRecord record = iter.next();\r\n-                recordNumber++;\r\n-                assertEquals(String.valueOf(recordNumber), record.get(0));\r\n-            }\r\n-        }\r\n-        // Consecutive enhanced for loops shouldn't break sequence\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows))) {\r\n-            int recordNumber = 0;\r\n-            for (final CSVRecord record : parser) {\r\n-                recordNumber++;\r\n-                assertEquals(String.valueOf(recordNumber), record.get(0));\r\n-                if (recordNumber >= 2) {\r\n-                    break;\r\n-                }\r\n-            }\r\n-            for (final CSVRecord record : parser) {\r\n-                recordNumber++;\r\n-                assertEquals(String.valueOf(recordNumber), record.get(0));\r\n-            }\r\n-        }\r\n-        // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows))) {\r\n-            int recordNumber = 0;\r\n-            for (final CSVRecord record : parser) {\r\n-                recordNumber++;\r\n-                assertEquals(String.valueOf(recordNumber), record.get(0));\r\n-                if (recordNumber >= 2) {\r\n-                    break;\r\n-                }\r\n-            }\r\n-            parser.iterator().hasNext();\r\n-            for (final CSVRecord record : parser) {\r\n-                recordNumber++;\r\n-                assertEquals(String.valueOf(recordNumber), record.get(0));\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testLineFeedEndings() throws IOException {\r\n-        final String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\r\n-        try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(4, records.size());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").withSkipHeaderRecord().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            CSVRecord record;\r\n-            // 1st record\r\n-            record = records.next();\r\n-            assertTrue(record.isMapped(\"A\"));\r\n-            assertTrue(record.isMapped(\"B\"));\r\n-            assertTrue(record.isMapped(\"C\"));\r\n-            assertTrue(record.isSet(\"A\"));\r\n-            assertTrue(record.isSet(\"B\"));\r\n-            assertFalse(record.isSet(\"C\"));\r\n-            assertEquals(\"1\", record.get(\"A\"));\r\n-            assertEquals(\"2\", record.get(\"B\"));\r\n-            assertFalse(record.isConsistent());\r\n-            // 2nd record\r\n-            record = records.next();\r\n-            assertTrue(record.isMapped(\"A\"));\r\n-            assertTrue(record.isMapped(\"B\"));\r\n-            assertTrue(record.isMapped(\"C\"));\r\n-            assertTrue(record.isSet(\"A\"));\r\n-            assertTrue(record.isSet(\"B\"));\r\n-            assertTrue(record.isSet(\"C\"));\r\n-            assertEquals(\"x\", record.get(\"A\"));\r\n-            assertEquals(\"y\", record.get(\"B\"));\r\n-            assertEquals(\"z\", record.get(\"C\"));\r\n-            assertTrue(record.isConsistent());\r\n-            // end\r\n-            assertFalse(records.hasNext());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testMongoDbCsv() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"\\\"a a\\\",b,c\" + LF + \"d,e,f\", CSVFormat.MONGODB_CSV)) {\r\n-            final Iterator<CSVRecord> itr1 = parser.iterator();\r\n-            final Iterator<CSVRecord> itr2 = parser.iterator();\r\n-\r\n-            final CSVRecord first = itr1.next();\r\n-            assertEquals(\"a a\", first.get(0));\r\n-            assertEquals(\"b\", first.get(1));\r\n-            assertEquals(\"c\", first.get(2));\r\n-\r\n-            final CSVRecord second = itr2.next();\r\n-            assertEquals(\"d\", second.get(0));\r\n-            assertEquals(\"e\", second.get(1));\r\n-            assertEquals(\"f\", second.get(2));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // TODO this may lead to strange behavior, throw an exception if iterator() has already been called?\r\n-    public void testMultipleIterators() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"a,b,c\" + CRLF + \"d,e,f\", CSVFormat.DEFAULT)) {\r\n-            final Iterator<CSVRecord> itr1 = parser.iterator();\r\n-\r\n-            final CSVRecord first = itr1.next();\r\n-            assertEquals(\"a\", first.get(0));\r\n-            assertEquals(\"b\", first.get(1));\r\n-            assertEquals(\"c\", first.get(2));\r\n-\r\n-            final CSVRecord second = itr1.next();\r\n-            assertEquals(\"d\", second.get(0));\r\n-            assertEquals(\"e\", second.get(1));\r\n-            assertEquals(\"f\", second.get(2));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNewCSVParserNullReaderFormat() {\r\n-        assertThrows(NullPointerException.class, () -> new CSVParser(null, CSVFormat.DEFAULT));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNewCSVParserReaderNullFormat() {\r\n-        assertThrows(NullPointerException.class, () -> new CSVParser(new StringReader(\"\"), null));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNoHeaderMap() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT)) {\r\n-            assertNull(parser.getHeaderMap());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNotValueCSV() throws IOException {\r\n-        final String source = \"#\";\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT.withCommentMarker('#');\r\n-        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n-            final CSVRecord csvRecord = csvParser.nextRecord();\r\n-            assertNull(csvRecord);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParse() throws Exception {\r\n-        final ClassLoader loader = ClassLoader.getSystemClassLoader();\r\n-        final URL url = loader.getResource(\"org/apache/commons/csv/CSVFileParser/test.csv\");\r\n-        final CSVFormat format = CSVFormat.DEFAULT.builder().setHeader(\"A\", \"B\", \"C\", \"D\").get();\r\n-        final Charset charset = StandardCharsets.UTF_8;\r\n-        // Reader\r\n-        try (CSVParser parser = CSVParser.parse(new InputStreamReader(url.openStream(), charset), format)) {\r\n-            parseFully(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.builder().setReader(new InputStreamReader(url.openStream(), charset)).setFormat(format).get()) {\r\n-            parseFully(parser);\r\n-        }\r\n-        // String\r\n-        final Path path = Paths.get(url.toURI());\r\n-        final String string = new String(Files.readAllBytes(path), charset);\r\n-        try (CSVParser parser = CSVParser.parse(string, format)) {\r\n-            parseFully(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.builder().setCharSequence(string).setFormat(format).get()) {\r\n-            parseFully(parser);\r\n-        }\r\n-        // File\r\n-        final File file = new File(url.toURI());\r\n-        try (CSVParser parser = CSVParser.parse(file, charset, format)) {\r\n-            parseFully(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.builder().setFile(file).setCharset(charset).setFormat(format).get()) {\r\n-            parseFully(parser);\r\n-        }\r\n-        // InputStream\r\n-        try (CSVParser parser = CSVParser.parse(url.openStream(), charset, format)) {\r\n-            parseFully(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.builder().setInputStream(url.openStream()).setCharset(charset).setFormat(format).get()) {\r\n-            parseFully(parser);\r\n-        }\r\n-        // Path\r\n-        try (CSVParser parser = CSVParser.parse(path, charset, format)) {\r\n-            parseFully(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.builder().setPath(path).setCharset(charset).setFormat(format).get()) {\r\n-            parseFully(parser);\r\n-        }\r\n-        // URL\r\n-        try (CSVParser parser = CSVParser.parse(url, charset, format)) {\r\n-            parseFully(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.builder().setURI(url.toURI()).setCharset(charset).setFormat(format).get()) {\r\n-            parseFully(parser);\r\n-        }\r\n-        // InputStreamReader\r\n-        try (CSVParser parser = new CSVParser(new InputStreamReader(url.openStream(), charset), format)) {\r\n-            parseFully(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.builder().setReader(new InputStreamReader(url.openStream(), charset)).setFormat(format).get()) {\r\n-            parseFully(parser);\r\n-        }\r\n-        // InputStreamReader with longs\r\n-        try (CSVParser parser = new CSVParser(new InputStreamReader(url.openStream(), charset), format, /* characterOffset= */0, /* recordNumber= */1)) {\r\n-            parseFully(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.builder().setReader(new InputStreamReader(url.openStream(), charset)).setFormat(format).setCharacterOffset(0)\r\n-                .setRecordNumber(0).get()) {\r\n-            parseFully(parser);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseFileNullFormat() {\r\n-        assertThrows(NullPointerException.class, () -> CSVParser.parse(new File(\"CSVFileParser/test.csv\"), Charset.defaultCharset(), null));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseNullFileFormat() {\r\n-        assertThrows(NullPointerException.class, () -> CSVParser.parse((File) null, Charset.defaultCharset(), CSVFormat.DEFAULT));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseNullPathFormat() {\r\n-        assertThrows(NullPointerException.class, () -> CSVParser.parse((Path) null, Charset.defaultCharset(), CSVFormat.DEFAULT));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseNullStringFormat() {\r\n-        assertThrows(NullPointerException.class, () -> CSVParser.parse((String) null, CSVFormat.DEFAULT));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseNullUrlCharsetFormat() {\r\n-        assertThrows(NullPointerException.class, () -> CSVParser.parse((URL) null, Charset.defaultCharset(), CSVFormat.DEFAULT));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParserUrlNullCharsetFormat() {\r\n-        assertThrows(NullPointerException.class, () -> CSVParser.parse(new URL(\"https://commons.apache.org\"), null, CSVFormat.DEFAULT));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseStringNullFormat() {\r\n-        assertThrows(NullPointerException.class, () -> CSVParser.parse(\"csv data\", (CSVFormat) null));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseUrlCharsetNullFormat() {\r\n-        assertThrows(NullPointerException.class, () -> CSVParser.parse(new URL(\"https://commons.apache.org\"), Charset.defaultCharset(), null));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseWithDelimiterStringWithEscape() throws IOException {\r\n-        final String source = \"a![!|!]b![|]c[|]xyz\\r\\nabc[abc][|]xyz\";\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setEscape('!').get();\r\n-        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n-            CSVRecord csvRecord = csvParser.nextRecord();\r\n-            assertEquals(\"a[|]b![|]c\", csvRecord.get(0));\r\n-            assertEquals(\"xyz\", csvRecord.get(1));\r\n-            csvRecord = csvParser.nextRecord();\r\n-            assertEquals(\"abc[abc]\", csvRecord.get(0));\r\n-            assertEquals(\"xyz\", csvRecord.get(1));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseWithDelimiterStringWithQuote() throws IOException {\r\n-        final String source = \"'a[|]b[|]c'[|]xyz\\r\\nabc[abc][|]xyz\";\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setQuote('\\'').get();\r\n-        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n-            CSVRecord csvRecord = csvParser.nextRecord();\r\n-            assertEquals(\"a[|]b[|]c\", csvRecord.get(0));\r\n-            assertEquals(\"xyz\", csvRecord.get(1));\r\n-            csvRecord = csvParser.nextRecord();\r\n-            assertEquals(\"abc[abc]\", csvRecord.get(0));\r\n-            assertEquals(\"xyz\", csvRecord.get(1));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseWithDelimiterWithEscape() throws IOException {\r\n-        final String source = \"a!,b!,c,xyz\";\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT.withEscape('!');\r\n-        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n-            final CSVRecord csvRecord = csvParser.nextRecord();\r\n-            assertEquals(\"a,b,c\", csvRecord.get(0));\r\n-            assertEquals(\"xyz\", csvRecord.get(1));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseWithDelimiterWithQuote() throws IOException {\r\n-        final String source = \"'a,b,c',xyz\";\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT.withQuote('\\'');\r\n-        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n-            final CSVRecord csvRecord = csvParser.nextRecord();\r\n-            assertEquals(\"a,b,c\", csvRecord.get(0));\r\n-            assertEquals(\"xyz\", csvRecord.get(1));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseWithQuoteThrowsException() {\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT.withQuote('\\'');\r\n-        assertThrows(IOException.class, () -> csvFormat.parse(new StringReader(\"'a,b,c','\")).nextRecord());\r\n-        assertThrows(IOException.class, () -> csvFormat.parse(new StringReader(\"'a,b,c'abc,xyz\")).nextRecord());\r\n-        assertThrows(IOException.class, () -> csvFormat.parse(new StringReader(\"'abc'a,b,c',xyz\")).nextRecord());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseWithQuoteWithEscape() throws IOException {\r\n-        final String source = \"'a?,b?,c?d',xyz\";\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT.withQuote('\\'').withEscape('?');\r\n-        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n-            final CSVRecord csvRecord = csvParser.nextRecord();\r\n-            assertEquals(\"a,b,c?d\", csvRecord.get(0));\r\n-            assertEquals(\"xyz\", csvRecord.get(1));\r\n-        }\r\n-    }\r\n-\r\n-    @ParameterizedTest\r\n-    @EnumSource(CSVFormat.Predefined.class)\r\n-    public void testParsingPrintedEmptyFirstColumn(final CSVFormat.Predefined format) throws Exception {\r\n-        final String[][] lines = { { \"a\", \"b\" }, { \"\", \"x\" } };\r\n-        final StringWriter buf = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(buf, format.getFormat())) {\r\n-            printer.printRecords(Stream.of(lines));\r\n-        }\r\n-        try (CSVParser csvRecords = CSVParser.builder()\r\n-                .setReader(new StringReader(buf.toString()))\r\n-                .setFormat(format.getFormat())\r\n-                .get()) {\r\n-            for (final String[] line : lines) {\r\n-                assertArrayEquals(line, csvRecords.nextRecord().values());\r\n-            }\r\n-            assertNull(csvRecords.nextRecord());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testProvidedHeader() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-\r\n-            for (int i = 0; i < 3; i++) {\r\n-                assertTrue(records.hasNext());\r\n-                final CSVRecord record = records.next();\r\n-                assertTrue(record.isMapped(\"A\"));\r\n-                assertTrue(record.isMapped(\"B\"));\r\n-                assertTrue(record.isMapped(\"C\"));\r\n-                assertFalse(record.isMapped(\"NOT MAPPED\"));\r\n-                assertEquals(record.get(0), record.get(\"A\"));\r\n-                assertEquals(record.get(1), record.get(\"B\"));\r\n-                assertEquals(record.get(2), record.get(\"C\"));\r\n-            }\r\n-\r\n-            assertFalse(records.hasNext());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testProvidedHeaderAuto() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-\r\n-            for (int i = 0; i < 2; i++) {\r\n-                assertTrue(records.hasNext());\r\n-                final CSVRecord record = records.next();\r\n-                assertTrue(record.isMapped(\"a\"));\r\n-                assertTrue(record.isMapped(\"b\"));\r\n-                assertTrue(record.isMapped(\"c\"));\r\n-                assertFalse(record.isMapped(\"NOT MAPPED\"));\r\n-                assertEquals(record.get(0), record.get(\"a\"));\r\n-                assertEquals(record.get(1), record.get(\"b\"));\r\n-                assertEquals(record.get(2), record.get(\"c\"));\r\n-            }\r\n-\r\n-            assertFalse(records.hasNext());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRepeatedHeadersAreReturnedInCSVRecordHeaderNames() throws IOException {\r\n-        final Reader in = new StringReader(\"header1,header2,header1\\n1,2,3\\n4,5,6\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withFirstRecordAsHeader().withTrim().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            @SuppressWarnings(\"resource\")\r\n-            final CSVParser recordParser = record.getParser();\r\n-            assertEquals(Arrays.asList(\"header1\", \"header2\", \"header1\"), recordParser.getHeaderNames());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRoundtrip() throws Exception {\r\n-        final StringWriter out = new StringWriter();\r\n-        final String data = \"a,b,c\\r\\n1,2,3\\r\\nx,y,z\\r\\n\";\r\n-        try (CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT);\r\n-                CSVParser parse = CSVParser.parse(data, CSVFormat.DEFAULT)) {\r\n-            for (final CSVRecord record : parse) {\r\n-                printer.printRecord(record);\r\n-            }\r\n-            assertEquals(data, out.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testSkipAutoHeader() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            assertEquals(\"1\", record.get(\"a\"));\r\n-            assertEquals(\"2\", record.get(\"b\"));\r\n-            assertEquals(\"3\", record.get(\"c\"));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testSkipHeaderOverrideDuplicateHeaders() throws Exception {\r\n-        final Reader in = new StringReader(\"a,a,a\\n1,2,3\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            assertEquals(\"1\", record.get(\"X\"));\r\n-            assertEquals(\"2\", record.get(\"Y\"));\r\n-            assertEquals(\"3\", record.get(\"Z\"));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testSkipSetAltHeaders() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            assertEquals(\"1\", record.get(\"X\"));\r\n-            assertEquals(\"2\", record.get(\"Y\"));\r\n-            assertEquals(\"3\", record.get(\"Z\"));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testSkipSetHeader() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"a\", \"b\", \"c\").withSkipHeaderRecord().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            assertEquals(\"1\", record.get(\"a\"));\r\n-            assertEquals(\"2\", record.get(\"b\"));\r\n-            assertEquals(\"3\", record.get(\"c\"));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testStartWithEmptyLinesThenHeaders() throws Exception {\r\n-        final String[] codes = { \"\\r\\n\\r\\n\\r\\nhello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\r\n-        final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\r\n-                { \"\" } };\r\n-        for (final String code : codes) {\r\n-            try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\r\n-                final List<CSVRecord> records = parser.getRecords();\r\n-                assertEquals(res.length, records.size());\r\n-                assertFalse(records.isEmpty());\r\n-                for (int i = 0; i < res.length; i++) {\r\n-                    assertArrayEquals(res[i], records.get(i).values());\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testStream() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.parse(in)) {\r\n-            final List<CSVRecord> list = parser.stream().collect(Collectors.toList());\r\n-            assertFalse(list.isEmpty());\r\n-            assertArrayEquals(new String[] { \"a\", \"b\", \"c\" }, list.get(0).values());\r\n-            assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, list.get(1).values());\r\n-            assertArrayEquals(new String[] { \"x\", \"y\", \"z\" }, list.get(2).values());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testThrowExceptionWithLineAndPosition() throws IOException {\r\n-        final String csvContent = \"col1,col2,col3,col4,col5,col6,col7,col8,col9,col10\\nrec1,rec2,rec3,rec4,rec5,rec6,rec7,rec8,\\\"\\\"rec9\\\"\\\",rec10\";\r\n-        final StringReader stringReader = new StringReader(csvContent);\r\n-        // @formatter:off\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT.builder()\r\n-                .setHeader()\r\n-                .setSkipHeaderRecord(true)\r\n-                .get();\r\n-        // @formatter:on\r\n-        try (CSVParser csvParser = csvFormat.parse(stringReader)) {\r\n-            final UncheckedIOException exception = assertThrows(UncheckedIOException.class, csvParser::getRecords);\r\n-            assertInstanceOf(CSVException.class, exception.getCause());\r\n-            assertTrue(exception.getMessage().contains(\"Invalid character between encapsulated token and delimiter at line: 2, position: 94\"),\r\n-                    exception::getMessage);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testTrailingDelimiter() throws Exception {\r\n-        final Reader in = new StringReader(\"a,a,a,\\n\\\"1\\\",\\\"2\\\",\\\"3\\\",\\nx,y,z,\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrailingDelimiter().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            assertEquals(\"1\", record.get(\"X\"));\r\n-            assertEquals(\"2\", record.get(\"Y\"));\r\n-            assertEquals(\"3\", record.get(\"Z\"));\r\n-            assertEquals(3, record.size());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testTrim() throws Exception {\r\n-        final Reader in = new StringReader(\"a,a,a\\n\\\" 1 \\\",\\\" 2 \\\",\\\" 3 \\\"\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrim().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            assertEquals(\"1\", record.get(\"X\"));\r\n-            assertEquals(\"2\", record.get(\"Y\"));\r\n-            assertEquals(\"3\", record.get(\"Z\"));\r\n-            assertEquals(3, record.size());\r\n-        }\r\n-    }\r\n-\r\n-    private void validateLineNumbers(final String lineSeparator) throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator))) {\r\n-            assertEquals(0, parser.getCurrentLineNumber());\r\n-            assertNotNull(parser.nextRecord());\r\n-            assertEquals(1, parser.getCurrentLineNumber());\r\n-            assertNotNull(parser.nextRecord());\r\n-            assertEquals(2, parser.getCurrentLineNumber());\r\n-            assertNotNull(parser.nextRecord());\r\n-            // Read EOF without EOL should 3\r\n-            assertEquals(3, parser.getCurrentLineNumber());\r\n-            assertNull(parser.nextRecord());\r\n-            // Read EOF without EOL should 3\r\n-            assertEquals(3, parser.getCurrentLineNumber());\r\n-        }\r\n-    }\r\n-\r\n-    private void validateRecordNumbers(final String lineSeparator) throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator))) {\r\n-            CSVRecord record;\r\n-            assertEquals(0, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(1, record.getRecordNumber());\r\n-            assertEquals(1, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(2, record.getRecordNumber());\r\n-            assertEquals(2, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(3, parser.getRecordNumber());\r\n-            assertNull(record = parser.nextRecord());\r\n-            assertEquals(3, parser.getRecordNumber());\r\n-        }\r\n-    }\r\n-\r\n-    private void validateRecordPosition(final String lineSeparator) throws IOException {\r\n-        final String nl = lineSeparator; // used as linebreak in values for better distinction\r\n-        final String code = \"a,b,c\" + lineSeparator + \"1,2,3\" + lineSeparator +\r\n-                // to see if recordPosition correctly points to the enclosing quote\r\n-                \"'A\" + nl + \"A','B\" + nl + \"B',CC\" + lineSeparator +\r\n-                // unicode test... not very relevant while operating on strings instead of bytes, but for\r\n-                // completeness...\r\n-                \"\\u00c4,\\u00d6,\\u00dc\" + lineSeparator + \"EOF,EOF,EOF\";\r\n-        final CSVFormat format = CSVFormat.newFormat(',').withQuote('\\'').withRecordSeparator(lineSeparator);\r\n-        final long positionRecord3;\r\n-        try (CSVParser parser = CSVParser.parse(code, format)) {\r\n-            CSVRecord record;\r\n-            assertEquals(0, parser.getRecordNumber());\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(1, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('a'), record.getCharacterPosition());\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(2, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            positionRecord3 = record.getCharacterPosition();\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(code.indexOf(\"'A\"), record.getCharacterPosition());\r\n-            assertEquals(\"A\" + lineSeparator + \"A\", record.get(0));\r\n-            assertEquals(\"B\" + lineSeparator + \"B\", record.get(1));\r\n-            assertEquals(\"CC\", record.get(2));\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(4, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('\\u00c4'), record.getCharacterPosition());\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(5, record.getRecordNumber());\r\n-            assertEquals(code.indexOf(\"EOF\"), record.getCharacterPosition());\r\n-        }\r\n-        // now try to read starting at record 3\r\n-        try (CSVParser parser = CSVParser.builder()\r\n-                .setReader(new StringReader(code.substring((int) positionRecord3)))\r\n-                .setFormat(format)\r\n-                .setCharacterOffset(positionRecord3)\r\n-                .setRecordNumber(3)\r\n-                .get()) {\r\n-            CSVRecord record;\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(code.indexOf(\"'A\"), record.getCharacterPosition());\r\n-            assertEquals(\"A\" + lineSeparator + \"A\", record.get(0));\r\n-            assertEquals(\"B\" + lineSeparator + \"B\", record.get(1));\r\n-            assertEquals(\"CC\", record.get(2));\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(4, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('\\u00c4'), record.getCharacterPosition());\r\n-            assertEquals(\"\\u00c4\", record.get(0));\r\n-        } // again with ctor\r\n-        try (CSVParser parser = new CSVParser(new StringReader(code.substring((int) positionRecord3)), format, positionRecord3, 3)) {\r\n-            CSVRecord record;\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(code.indexOf(\"'A\"), record.getCharacterPosition());\r\n-            assertEquals(\"A\" + lineSeparator + \"A\", record.get(0));\r\n-            assertEquals(\"B\" + lineSeparator + \"B\", record.get(1));\r\n-            assertEquals(\"CC\", record.get(2));\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(4, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('\\u00c4'), record.getCharacterPosition());\r\n-            assertEquals(\"\\u00c4\", record.get(0));\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import static org.apache.commons.csv.Constants.CR;\n+import static org.apache.commons.csv.Constants.CRLF;\n+import static org.apache.commons.csv.Constants.LF;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PipedReader;\n+import java.io.PipedWriter;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.input.BOMInputStream;\n+import org.apache.commons.io.input.BrokenInputStream;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+/**\n+ * CSVParserTest\n+ *\n+ * The test are organized in three different sections: The 'setter/getter' section, the lexer section and finally the parser section. In case a test fails, you\n+ * should follow a top-down approach for fixing a potential bug (its likely that the parser itself fails if the lexer has problems...).\n+ */\n+public class CSVParserTest {\n+\n+    private static final CSVFormat EXCEL_WITH_HEADER = CSVFormat.EXCEL.withHeader();\n+\n+    private static final Charset UTF_8 = StandardCharsets.UTF_8;\n+\n+    private static final String UTF_8_NAME = UTF_8.name();\n+\n+    private static final String CSV_INPUT = \"a,b,c,d\\n\" + \" a , b , 1 2 \\n\" + \"\\\"foo baar\\\", b,\\n\" +\n+            // + \" \\\"foo\\n,,\\n\\\"\\\",,\\n\\\\\\\"\\\",d,e\\n\";\n+            \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\"\\\"\\\",d,e\\n\"; // changed to use standard CSV escaping\n+\n+    private static final String CSV_INPUT_1 = \"a,b,c,d\";\n+\n+    private static final String CSV_INPUT_2 = \"a,b,1 2\";\n+\n+    private static final String[][] RESULT = { { \"a\", \"b\", \"c\", \"d\" }, { \"a\", \"b\", \"1 2\" }, { \"foo baar\", \"b\", \"\" }, { \"foo\\n,,\\n\\\",,\\n\\\"\", \"d\", \"e\" } };\n+\n+    // CSV with no header comments\n+    private static final String CSV_INPUT_NO_COMMENT = \"A,B\" + CRLF + \"1,2\" + CRLF;\n+\n+    // CSV with a header comment\n+    private static final String CSV_INPUT_HEADER_COMMENT = \"# header comment\" + CRLF + \"A,B\" + CRLF + \"1,2\" + CRLF;\n+\n+    // CSV with a single line header and trailer comment\n+    private static final String CSV_INPUT_HEADER_TRAILER_COMMENT = \"# header comment\" + CRLF + \"A,B\" + CRLF + \"1,2\" + CRLF + \"# comment\";\n+\n+    // CSV with a multi-line header and trailer comment\n+    private static final String CSV_INPUT_MULTILINE_HEADER_TRAILER_COMMENT = \"# multi-line\" + CRLF + \"# header comment\" + CRLF + \"A,B\" + CRLF + \"1,2\" + CRLF +\n+            \"# multi-line\" + CRLF + \"# comment\";\n+\n+    // Format with auto-detected header\n+    private static final CSVFormat FORMAT_AUTO_HEADER = CSVFormat.Builder.create(CSVFormat.DEFAULT).setCommentMarker('#').setHeader().get();\n+\n+    // Format with explicit header\n+    // @formatter:off\n+    private static final CSVFormat FORMAT_EXPLICIT_HEADER = CSVFormat.Builder.create(CSVFormat.DEFAULT)\n+            .setSkipHeaderRecord(true)\n+            .setCommentMarker('#')\n+            .setHeader(\"A\", \"B\")\n+            .get();\n+    // @formatter:on\n+\n+    // Format with explicit header that does not skip the header line\n+    // @formatter:off\n+    CSVFormat FORMAT_EXPLICIT_HEADER_NOSKIP = CSVFormat.Builder.create(CSVFormat.DEFAULT)\n+            .setCommentMarker('#')\n+            .setHeader(\"A\", \"B\")\n+            .get();\n+    // @formatter:on\n+\n+    @SuppressWarnings(\"resource\") // caller releases\n+    private BOMInputStream createBOMInputStream(final String resource) throws IOException {\n+        return new BOMInputStream(ClassLoader.getSystemClassLoader().getResource(resource).openStream());\n+    }\n+\n+    CSVRecord parse(final CSVParser parser, final int failParseRecordNo) throws IOException {\n+        if (parser.getRecordNumber() + 1 == failParseRecordNo) {\n+            assertThrows(IOException.class, () -> parser.nextRecord());\n+            return null;\n+        }\n+        return parser.nextRecord();\n+    }\n+\n+    private void parseFully(final CSVParser parser) {\n+        parser.forEach(Assertions::assertNotNull);\n+    }\n+\n+    @Test\n+    public void testBackslashEscaping() throws IOException {\n+        // To avoid confusion over the need for escaping chars in java code,\n+        // We will test with a forward slash as the escape char, and a single\n+        // quote as the encapsulator.\n+\n+        // @formatter:off\n+        final String code = \"one,two,three\\n\" + // 0\n+            \"'',''\\n\" + // 1) empty encapsulators\n+            \"/',/'\\n\" + // 2) single encapsulators\n+            \"'/'','/''\\n\" + // 3) single encapsulators encapsulated via escape\n+            \"'''',''''\\n\" + // 4) single encapsulators encapsulated via doubling\n+            \"/,,/,\\n\" + // 5) separator escaped\n+            \"//,//\\n\" + // 6) escape escaped\n+            \"'//','//'\\n\" + // 7) escape escaped in encapsulation\n+            \"   8   ,   \\\"quoted \\\"\\\" /\\\" // string\\\"   \\n\" + // don't eat spaces\n+            \"9,   /\\n   \\n\" + // escaped newline\n+            \"\";\n+        final String[][] res = {{\"one\", \"two\", \"three\"}, // 0\n+            {\"\", \"\"}, // 1\n+            {\"'\", \"'\"}, // 2\n+            {\"'\", \"'\"}, // 3\n+            {\"'\", \"'\"}, // 4\n+            {\",\", \",\"}, // 5\n+            {\"/\", \"/\"}, // 6\n+            {\"/\", \"/\"}, // 7\n+            {\"   8   \", \"   \\\"quoted \\\"\\\" /\\\" / string\\\"   \"}, {\"9\", \"   \\n   \"} };\n+        // @formatter:on\n+        final CSVFormat format = CSVFormat.newFormat(',').withQuote('\\'').withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines();\n+        try (CSVParser parser = CSVParser.parse(code, format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertFalse(records.isEmpty());\n+            Utils.compare(\"Records do not match expected result\", res, records);\n+        }\n+    }\n+\n+    @Test\n+    public void testBackslashEscaping2() throws IOException {\n+        // To avoid confusion over the need for escaping chars in java code,\n+        // We will test with a forward slash as the escape char, and a single\n+        // quote as the encapsulator.\n+        // @formatter:off\n+        final String code = \"\" + \" , , \\n\" + // 1)\n+            \" \\t ,  , \\n\" + // 2)\n+            \" // , /, , /,\\n\" + // 3)\n+            \"\";\n+        final String[][] res = {{\" \", \" \", \" \"}, // 1\n+            {\" \\t \", \"  \", \" \"}, // 2\n+            {\" / \", \" , \", \" ,\"}, // 3\n+        };\n+        // @formatter:on\n+        final CSVFormat format = CSVFormat.newFormat(',').withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines();\n+        try (CSVParser parser = CSVParser.parse(code, format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertFalse(records.isEmpty());\n+            Utils.compare(\"\", res, records);\n+        }\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testBackslashEscapingOld() throws IOException {\n+        final String code = \"one,two,three\\n\" + \"on\\\\\\\"e,two\\n\" + \"on\\\"e,two\\n\" + \"one,\\\"tw\\\\\\\"o\\\"\\n\" + \"one,\\\"t\\\\,wo\\\"\\n\" + \"one,two,\\\"th,ree\\\"\\n\" +\n+                \"\\\"a\\\\\\\\\\\"\\n\" + \"a\\\\,b\\n\" + \"\\\"a\\\\\\\\,b\\\"\";\n+        final String[][] res = { { \"one\", \"two\", \"three\" }, { \"on\\\\\\\"e\", \"two\" }, { \"on\\\"e\", \"two\" }, { \"one\", \"tw\\\"o\" }, { \"one\", \"t\\\\,wo\" }, // backslash in\n+                                                                                                                                               // quotes only\n+                                                                                                                                               // escapes a\n+                                                                                                                                               // delimiter\n+                                                                                                                                               // (\",\")\n+                { \"one\", \"two\", \"th,ree\" }, { \"a\\\\\\\\\" }, // backslash in quotes only escapes a delimiter (\",\")\n+                { \"a\\\\\", \"b\" }, // a backslash must be returned\n+                { \"a\\\\\\\\,b\" } // backslash in quotes only escapes a delimiter (\",\")\n+        };\n+        try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(res.length, records.size());\n+            assertFalse(records.isEmpty());\n+            for (int i = 0; i < res.length; i++) {\n+                assertArrayEquals(res[i], records.get(i).values());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Disabled(\"CSV-107\")\n+    public void testBOM() throws IOException {\n+        final URL url = ClassLoader.getSystemClassLoader().getResource(\"org/apache/commons/csv/CSVFileParser/bom.csv\");\n+        try (CSVParser parser = CSVParser.parse(url, StandardCharsets.UTF_8, EXCEL_WITH_HEADER)) {\n+            parser.forEach(record -> assertNotNull(record.get(\"Date\")));\n+        }\n+    }\n+\n+    @Test\n+    public void testBOMInputStreamParserWithInputStream() throws IOException {\n+        try (BOMInputStream inputStream = createBOMInputStream(\"org/apache/commons/csv/CSVFileParser/bom.csv\");\n+                CSVParser parser = CSVParser.parse(inputStream, UTF_8, EXCEL_WITH_HEADER)) {\n+            parser.forEach(record -> assertNotNull(record.get(\"Date\")));\n+        }\n+    }\n+\n+    @Test\n+    public void testBOMInputStreamParserWithReader() throws IOException {\n+        try (Reader reader = new InputStreamReader(createBOMInputStream(\"org/apache/commons/csv/CSVFileParser/bom.csv\"), UTF_8_NAME);\n+                CSVParser parser = CSVParser.builder()\n+                        .setReader(reader)\n+                        .setFormat(EXCEL_WITH_HEADER)\n+                        .get()) {\n+            parser.forEach(record -> assertNotNull(record.get(\"Date\")));\n+        }\n+    }\n+\n+    @Test\n+    public void testBOMInputStreamParseWithReader() throws IOException {\n+        try (Reader reader = new InputStreamReader(createBOMInputStream(\"org/apache/commons/csv/CSVFileParser/bom.csv\"), UTF_8_NAME);\n+                CSVParser parser = CSVParser.builder()\n+                        .setReader(reader)\n+                        .setFormat(EXCEL_WITH_HEADER)\n+                        .get()) {\n+            parser.forEach(record -> assertNotNull(record.get(\"Date\")));\n+        }\n+    }\n+\n+    @Test\n+    public void testCarriageReturnEndings() throws IOException {\n+        final String string = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n+        try (CSVParser parser = CSVParser.builder().setCharSequence(string).get()) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testCarriageReturnLineFeedEndings() throws IOException {\n+        final String string = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n+        try (CSVParser parser = CSVParser.builder().setCharSequence(string).get()) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testClose() throws Exception {\n+        final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n+        final Iterator<CSVRecord> records;\n+        try (CSVParser parser = CSVFormat.DEFAULT.withCommentMarker('#').withHeader().parse(in)) {\n+            records = parser.iterator();\n+            assertTrue(records.hasNext());\n+        }\n+        assertFalse(records.hasNext());\n+        assertThrows(NoSuchElementException.class, records::next);\n+    }\n+\n+    @Test\n+    public void testCSV141CSVFormat_DEFAULT() throws Exception {\n+        testCSV141Failure(CSVFormat.DEFAULT, 3);\n+    }\n+\n+    @Test\n+    public void testCSV141CSVFormat_INFORMIX_UNLOAD() throws Exception {\n+        testCSV141Failure(CSVFormat.INFORMIX_UNLOAD, 1);\n+    }\n+\n+    @Test\n+    public void testCSV141CSVFormat_INFORMIX_UNLOAD_CSV() throws Exception {\n+        testCSV141Failure(CSVFormat.INFORMIX_UNLOAD_CSV, 3);\n+    }\n+\n+    @Test\n+    public void testCSV141CSVFormat_ORACLE() throws Exception {\n+        testCSV141Failure(CSVFormat.ORACLE, 2);\n+    }\n+\n+    @Test\n+    public void testCSV141CSVFormat_POSTGRESQL_CSV() throws Exception {\n+        testCSV141Failure(CSVFormat.POSTGRESQL_CSV, 3);\n+    }\n+\n+    @Test\n+    public void testCSV141Excel() throws Exception {\n+        testCSV141Ok(CSVFormat.EXCEL);\n+    }\n+\n+    private void testCSV141Failure(final CSVFormat format, final int failParseRecordNo) throws IOException {\n+        final Path path = Paths.get(\"src/test/resources/org/apache/commons/csv/CSV-141/csv-141.csv\");\n+        try (CSVParser parser = CSVParser.parse(path, StandardCharsets.UTF_8, format)) {\n+            // row 1\n+            CSVRecord record = parse(parser, failParseRecordNo);\n+            if (record == null) {\n+                return; // expected failure\n+            }\n+            assertEquals(\"1414770317901\", record.get(0));\n+            assertEquals(\"android.widget.EditText\", record.get(1));\n+            assertEquals(\"pass sem1 _84*|*\", record.get(2));\n+            assertEquals(\"0\", record.get(3));\n+            assertEquals(\"pass sem1 _8\", record.get(4));\n+            assertEquals(5, record.size());\n+            // row 2\n+            record = parse(parser, failParseRecordNo);\n+            if (record == null) {\n+                return; // expected failure\n+            }\n+            assertEquals(\"1414770318470\", record.get(0));\n+            assertEquals(\"android.widget.EditText\", record.get(1));\n+            assertEquals(\"pass sem1 _84:|\", record.get(2));\n+            assertEquals(\"0\", record.get(3));\n+            assertEquals(\"pass sem1 _84:\\\\\", record.get(4));\n+            assertEquals(5, record.size());\n+            // row 3: Fail for certain\n+            assertThrows(IOException.class, () -> parser.nextRecord());\n+        }\n+    }\n+\n+    private void testCSV141Ok(final CSVFormat format) throws IOException {\n+        final Path path = Paths.get(\"src/test/resources/org/apache/commons/csv/CSV-141/csv-141.csv\");\n+        try (CSVParser parser = CSVParser.parse(path, StandardCharsets.UTF_8, format)) {\n+            // row 1\n+            CSVRecord record = parser.nextRecord();\n+            assertEquals(\"1414770317901\", record.get(0));\n+            assertEquals(\"android.widget.EditText\", record.get(1));\n+            assertEquals(\"pass sem1 _84*|*\", record.get(2));\n+            assertEquals(\"0\", record.get(3));\n+            assertEquals(\"pass sem1 _8\", record.get(4));\n+            assertEquals(5, record.size());\n+            // row 2\n+            record = parser.nextRecord();\n+            assertEquals(\"1414770318470\", record.get(0));\n+            assertEquals(\"android.widget.EditText\", record.get(1));\n+            assertEquals(\"pass sem1 _84:|\", record.get(2));\n+            assertEquals(\"0\", record.get(3));\n+            assertEquals(\"pass sem1 _84:\\\\\", record.get(4));\n+            assertEquals(5, record.size());\n+            // row 3\n+            record = parser.nextRecord();\n+            assertEquals(\"1414770318327\", record.get(0));\n+            assertEquals(\"android.widget.EditText\", record.get(1));\n+            assertEquals(\"pass sem1\\n1414770318628\\\"\", record.get(2));\n+            assertEquals(\"android.widget.EditText\", record.get(3));\n+            assertEquals(\"pass sem1 _84*|*\", record.get(4));\n+            assertEquals(\"0\", record.get(5));\n+            assertEquals(\"pass sem1\\n\", record.get(6));\n+            assertEquals(7, record.size());\n+            // EOF\n+            record = parser.nextRecord();\n+            assertNull(record);\n+        }\n+    }\n+\n+    @Test\n+    public void testCSV141RFC4180() throws Exception {\n+        testCSV141Failure(CSVFormat.RFC4180, 3);\n+    }\n+\n+    @Test\n+    public void testCSV235() throws IOException {\n+        final String dqString = \"\\\"aaa\\\",\\\"b\\\"\\\"bb\\\",\\\"ccc\\\"\"; // \"aaa\",\"b\"\"bb\",\"ccc\"\n+        try (CSVParser parser = CSVFormat.RFC4180.parse(new StringReader(dqString))) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            assertFalse(records.hasNext());\n+            assertEquals(3, record.size());\n+            assertEquals(\"aaa\", record.get(0));\n+            assertEquals(\"b\\\"bb\", record.get(1));\n+            assertEquals(\"ccc\", record.get(2));\n+        }\n+    }\n+\n+    @Test\n+    public void testCSV57() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> list = parser.getRecords();\n+            assertNotNull(list);\n+            assertEquals(0, list.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testDefaultFormat() throws IOException {\n+        // @formatter:off\n+        final String code = \"\" + \"a,b#\\n\" + // 1)\n+            \"\\\"\\n\\\",\\\" \\\",#\\n\" +            // 2)\n+            \"#,\\\"\\\"\\n\" +                    // 3)\n+            \"# Final comment\\n\"             // 4)\n+        ;\n+        // @formatter:on\n+        final String[][] res = { { \"a\", \"b#\" }, { \"\\n\", \" \", \"#\" }, { \"#\", \"\" }, { \"# Final comment\" } };\n+        CSVFormat format = CSVFormat.DEFAULT;\n+        assertFalse(format.isCommentMarkerSet());\n+        final String[][] resComments = { { \"a\", \"b#\" }, { \"\\n\", \" \", \"#\" } };\n+        try (CSVParser parser = CSVParser.parse(code, format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertFalse(records.isEmpty());\n+            Utils.compare(\"Failed to parse without comments\", res, records);\n+            format = CSVFormat.DEFAULT.withCommentMarker('#');\n+        }\n+        try (CSVParser parser = CSVParser.parse(code, format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            Utils.compare(\"Failed to parse with comments\", resComments, records);\n+        }\n+    }\n+\n+    @Test\n+    public void testDuplicateHeadersAllowedByDefault() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"a,b,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader())) {\n+            // noop\n+        }\n+    }\n+\n+    @Test\n+    public void testDuplicateHeadersNotAllowed() {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> CSVParser.parse(\"a,b,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader().withAllowDuplicateHeaderNames(false)));\n+    }\n+\n+    @Test\n+    public void testEmptyFile() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(Paths.get(\"src/test/resources/org/apache/commons/csv/empty.txt\"), StandardCharsets.UTF_8,\n+                CSVFormat.DEFAULT)) {\n+            assertNull(parser.nextRecord());\n+        }\n+    }\n+\n+    @Test\n+    public void testEmptyFileHeaderParsing() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT.withFirstRecordAsHeader())) {\n+            assertNull(parser.nextRecord());\n+            assertTrue(parser.getHeaderNames().isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    public void testEmptyLineBehaviorCSV() throws Exception {\n+        final String[] codes = { \"hello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\n+        final String[][] res = { { \"hello\", \"\" } // CSV format ignores empty lines\n+        };\n+        for (final String code : codes) {\n+            try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n+                final List<CSVRecord> records = parser.getRecords();\n+                assertEquals(res.length, records.size());\n+                assertFalse(records.isEmpty());\n+                for (int i = 0; i < res.length; i++) {\n+                    assertArrayEquals(res[i], records.get(i).values());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testEmptyLineBehaviorExcel() throws Exception {\n+        final String[] codes = { \"hello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\n+        final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\n+                { \"\" } };\n+        for (final String code : codes) {\n+            try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\n+                final List<CSVRecord> records = parser.getRecords();\n+                assertEquals(res.length, records.size());\n+                assertFalse(records.isEmpty());\n+                for (int i = 0; i < res.length; i++) {\n+                    assertArrayEquals(res[i], records.get(i).values());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testEmptyString() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT)) {\n+            assertNull(parser.nextRecord());\n+        }\n+    }\n+\n+    @Test\n+    public void testEndOfFileBehaviorCSV() throws Exception {\n+        final String[] codes = { \"hello,\\r\\n\\r\\nworld,\\r\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\n+                \"hello,\\r\\n\\r\\nworld,\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\" };\n+        final String[][] res = { { \"hello\", \"\" }, // CSV format ignores empty lines\n+                { \"world\", \"\" } };\n+        for (final String code : codes) {\n+            try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n+                final List<CSVRecord> records = parser.getRecords();\n+                assertEquals(res.length, records.size());\n+                assertFalse(records.isEmpty());\n+                for (int i = 0; i < res.length; i++) {\n+                    assertArrayEquals(res[i], records.get(i).values());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testEndOfFileBehaviorExcel() throws Exception {\n+        final String[] codes = { \"hello,\\r\\n\\r\\nworld,\\r\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\n+                \"hello,\\r\\n\\r\\nworld,\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\" };\n+        final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\n+                { \"world\", \"\" } };\n+\n+        for (final String code : codes) {\n+            try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\n+                final List<CSVRecord> records = parser.getRecords();\n+                assertEquals(res.length, records.size());\n+                assertFalse(records.isEmpty());\n+                for (int i = 0; i < res.length; i++) {\n+                    assertArrayEquals(res[i], records.get(i).values());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelFormat1() throws IOException {\n+        final String code = \"value1,value2,value3,value4\\r\\na,b,c,d\\r\\n  x,,,\" + \"\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\",\\\"  \\\"\\\"world\\\"\\\"\\\",\\\"abc\\ndef\\\",\\r\\n\";\n+        final String[][] res = { { \"value1\", \"value2\", \"value3\", \"value4\" }, { \"a\", \"b\", \"c\", \"d\" }, { \"  x\", \"\", \"\", \"\" }, { \"\" },\n+                { \"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\" } };\n+        try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(res.length, records.size());\n+            assertFalse(records.isEmpty());\n+            for (int i = 0; i < res.length; i++) {\n+                assertArrayEquals(res[i], records.get(i).values());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelFormat2() throws Exception {\n+        final String code = \"foo,baar\\r\\n\\r\\nhello,\\r\\n\\r\\nworld,\\r\\n\";\n+        final String[][] res = { { \"foo\", \"baar\" }, { \"\" }, { \"hello\", \"\" }, { \"\" }, { \"world\", \"\" } };\n+        try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(res.length, records.size());\n+            assertFalse(records.isEmpty());\n+            for (int i = 0; i < res.length; i++) {\n+                assertArrayEquals(res[i], records.get(i).values());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests an exported Excel worksheet with a header row and rows that have more columns than the headers\n+     */\n+    @Test\n+    public void testExcelHeaderCountLessThanData() throws Exception {\n+        final String code = \"A,B,C,,\\r\\na,b,c,d,e\\r\\n\";\n+        try (CSVParser parser = CSVParser.parse(code, EXCEL_WITH_HEADER)) {\n+            parser.getRecords().forEach(record -> {\n+                assertEquals(\"a\", record.get(\"A\"));\n+                assertEquals(\"b\", record.get(\"B\"));\n+                assertEquals(\"c\", record.get(\"C\"));\n+            });\n+        }\n+    }\n+\n+    @Test\n+    public void testFirstEndOfLineCr() throws IOException {\n+        final String data = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n+        try (CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+            assertEquals(\"\\r\", parser.getFirstEndOfLine());\n+        }\n+    }\n+\n+    @Test\n+    public void testFirstEndOfLineCrLf() throws IOException {\n+        final String data = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n+        try (CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+            assertEquals(\"\\r\\n\", parser.getFirstEndOfLine());\n+        }\n+    }\n+\n+    @Test\n+    public void testFirstEndOfLineLf() throws IOException {\n+        final String data = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n+        try (CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+            assertEquals(\"\\n\", parser.getFirstEndOfLine());\n+        }\n+    }\n+\n+    @Test\n+    public void testForEach() throws Exception {\n+        try (Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+                CSVParser parser = CSVFormat.DEFAULT.parse(in)) {\n+            final List<CSVRecord> records = new ArrayList<>();\n+            for (final CSVRecord record : parser) {\n+                records.add(record);\n+            }\n+            assertEquals(3, records.size());\n+            assertArrayEquals(new String[] { \"a\", \"b\", \"c\" }, records.get(0).values());\n+            assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, records.get(1).values());\n+            assertArrayEquals(new String[] { \"x\", \"y\", \"z\" }, records.get(2).values());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderComment_HeaderComment1() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_AUTO_HEADER)) {\n+            parser.getRecords();\n+            // Expect a header comment\n+            assertTrue(parser.hasHeaderComment());\n+            assertEquals(\"header comment\", parser.getHeaderComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderComment_HeaderComment2() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER)) {\n+            parser.getRecords();\n+            // Expect a header comment\n+            assertTrue(parser.hasHeaderComment());\n+            assertEquals(\"header comment\", parser.getHeaderComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderComment_HeaderComment3() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\n+            parser.getRecords();\n+            // Expect no header comment - the text \"comment\" is attached to the first record\n+            assertFalse(parser.hasHeaderComment());\n+            assertNull(parser.getHeaderComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderComment_HeaderTrailerComment() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_MULTILINE_HEADER_TRAILER_COMMENT, FORMAT_AUTO_HEADER)) {\n+            parser.getRecords();\n+            // Expect a header comment\n+            assertTrue(parser.hasHeaderComment());\n+            assertEquals(\"multi-line\" + LF + \"header comment\", parser.getHeaderComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderComment_NoComment1() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_NO_COMMENT, FORMAT_AUTO_HEADER)) {\n+            parser.getRecords();\n+            // Expect no header comment\n+            assertFalse(parser.hasHeaderComment());\n+            assertNull(parser.getHeaderComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderComment_NoComment2() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_NO_COMMENT, FORMAT_EXPLICIT_HEADER)) {\n+            parser.getRecords();\n+            // Expect no header comment\n+            assertFalse(parser.hasHeaderComment());\n+            assertNull(parser.getHeaderComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderComment_NoComment3() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_NO_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\n+            parser.getRecords();\n+            // Expect no header comment\n+            assertFalse(parser.hasHeaderComment());\n+            assertNull(parser.getHeaderComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderMap() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\n+            final Map<String, Integer> headerMap = parser.getHeaderMap();\n+            final Iterator<String> columnNames = headerMap.keySet().iterator();\n+            // Headers are iterated in column order.\n+            assertEquals(\"A\", columnNames.next());\n+            assertEquals(\"B\", columnNames.next());\n+            assertEquals(\"C\", columnNames.next());\n+            final Iterator<CSVRecord> records = parser.iterator();\n+\n+            // Parse to make sure getHeaderMap did not have a side-effect.\n+            for (int i = 0; i < 3; i++) {\n+                assertTrue(records.hasNext());\n+                final CSVRecord record = records.next();\n+                assertEquals(record.get(0), record.get(\"A\"));\n+                assertEquals(record.get(1), record.get(\"B\"));\n+                assertEquals(record.get(2), record.get(\"C\"));\n+            }\n+\n+            assertFalse(records.hasNext());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderNames() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\n+            final Map<String, Integer> nameIndexMap = parser.getHeaderMap();\n+            final List<String> headerNames = parser.getHeaderNames();\n+            assertNotNull(headerNames);\n+            assertEquals(nameIndexMap.size(), headerNames.size());\n+            for (int i = 0; i < headerNames.size(); i++) {\n+                final String name = headerNames.get(i);\n+                assertEquals(i, nameIndexMap.get(name).intValue());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderNamesReadOnly() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\n+            final List<String> headerNames = parser.getHeaderNames();\n+            assertNotNull(headerNames);\n+            assertThrows(UnsupportedOperationException.class, () -> headerNames.add(\"This is a read-only list.\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testGetLine() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\n+            for (final String[] re : RESULT) {\n+                assertArrayEquals(re, parser.nextRecord().values());\n+            }\n+\n+            assertNull(parser.nextRecord());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetLineNumberWithCR() throws Exception {\n+        validateLineNumbers(String.valueOf(CR));\n+    }\n+\n+    @Test\n+    public void testGetLineNumberWithCRLF() throws Exception {\n+        validateLineNumbers(CRLF);\n+    }\n+\n+    @Test\n+    public void testGetLineNumberWithLF() throws Exception {\n+        validateLineNumbers(String.valueOf(LF));\n+    }\n+\n+    @Test\n+    public void testGetOneLine() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_1, CSVFormat.DEFAULT)) {\n+            final CSVRecord record = parser.getRecords().get(0);\n+            assertArrayEquals(RESULT[0], record.values());\n+        }\n+    }\n+\n+    /**\n+     * Tests reusing a parser to process new string records one at a time as they are being discovered. See [CSV-110].\n+     *\n+     * @throws IOException when an I/O error occurs.\n+     */\n+    @Test\n+    public void testGetOneLineOneParser() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT;\n+        try (PipedWriter writer = new PipedWriter();\n+                CSVParser parser = CSVParser.builder()\n+                        .setReader(new PipedReader(writer))\n+                        .setFormat(format)\n+                        .get()) {\n+            writer.append(CSV_INPUT_1);\n+            writer.append(format.getRecordSeparator());\n+            final CSVRecord record1 = parser.nextRecord();\n+            assertArrayEquals(RESULT[0], record1.values());\n+            writer.append(CSV_INPUT_2);\n+            writer.append(format.getRecordSeparator());\n+            final CSVRecord record2 = parser.nextRecord();\n+            assertArrayEquals(RESULT[1], record2.values());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetRecordFourBytesRead() throws Exception {\n+        final String code = \"id,a,b,c\\n\" +\n+            \"1,,,\\n\" +\n+            \"2,,,\\n\" +\n+            \"3,,,\\n\";\n+        final CSVFormat format = CSVFormat.Builder.create()\n+            .setDelimiter(',')\n+            .setQuote('\\'')\n+            .get();\n+        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setTrackBytes(true).get()) {\n+            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\n+\n+            assertEquals(0, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(1, record.getRecordNumber());\n+            assertEquals(code.indexOf('i'), record.getCharacterPosition());\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\n+\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(2, record.getRecordNumber());\n+            assertEquals(code.indexOf('1'), record.getCharacterPosition());\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(3, record.getRecordNumber());\n+            assertEquals(code.indexOf('2'), record.getCharacterPosition());\n+            assertEquals(record.getBytePosition(), 26);\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(4, record.getRecordNumber());\n+            assertEquals(code.indexOf('3'), record.getCharacterPosition());\n+            assertEquals(record.getBytePosition(), 43);\n+        }\n+    }\n+\n+    @Test\n+    public void testGetRecordNumberWithCR() throws Exception {\n+        validateRecordNumbers(String.valueOf(CR));\n+    }\n+\n+    @Test\n+    public void testGetRecordNumberWithCRLF() throws Exception {\n+        validateRecordNumbers(CRLF);\n+    }\n+\n+    @Test\n+    public void testGetRecordNumberWithLF() throws Exception {\n+        validateRecordNumbers(String.valueOf(LF));\n+    }\n+\n+    @Test\n+    public void testGetRecordPositionWithCRLF() throws Exception {\n+        validateRecordPosition(CRLF);\n+    }\n+\n+    @Test\n+    public void testGetRecordPositionWithLF() throws Exception {\n+        validateRecordPosition(String.valueOf(LF));\n+    }\n+\n+    @Test\n+    public void testGetRecords() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(RESULT.length, records.size());\n+            assertFalse(records.isEmpty());\n+            for (int i = 0; i < RESULT.length; i++) {\n+                assertArrayEquals(RESULT[i], records.get(i).values());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testGetRecordsFromBrokenInputStream() throws IOException {\n+        @SuppressWarnings(\"resource\") // We also get an exception on close, which is OK but can't assert in a try.\n+        final CSVParser parser = CSVParser.parse(new BrokenInputStream(), UTF_8, CSVFormat.DEFAULT);\n+        assertThrows(UncheckedIOException.class, parser::getRecords);\n+\n+    }\n+\n+    @Test\n+    public void testGetRecordThreeBytesRead() throws Exception {\n+        final String code = \"id,date,val5,val4\\n\" +\n+            \"11111111111111,'4017-09-01',,v4\\n\" +\n+            \"22222222222222,'4017-01-01',,v4\\n\" +\n+            \"33333333333333,'4017-01-01',,v4\\n\";\n+        final CSVFormat format = CSVFormat.Builder.create()\n+            .setDelimiter(',')\n+            .setQuote('\\'')\n+            .get();\n+        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setTrackBytes(true).get()) {\n+            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\n+\n+            assertEquals(0, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(1, record.getRecordNumber());\n+            assertEquals(code.indexOf('i'), record.getCharacterPosition());\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\n+\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(2, record.getRecordNumber());\n+            assertEquals(code.indexOf('1'), record.getCharacterPosition());\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\n+\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(3, record.getRecordNumber());\n+            assertEquals(code.indexOf('2'), record.getCharacterPosition());\n+            assertEquals(record.getBytePosition(), 95);\n+\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(4, record.getRecordNumber());\n+            assertEquals(code.indexOf('3'), record.getCharacterPosition());\n+            assertEquals(record.getBytePosition(), 154);\n+        }\n+    }\n+\n+    @Test\n+    public void testGetRecordWithMultiLineValues() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF + \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\",\n+                CSVFormat.DEFAULT.withRecordSeparator(CRLF))) {\n+            CSVRecord record;\n+            assertEquals(0, parser.getRecordNumber());\n+            assertEquals(0, parser.getCurrentLineNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(3, parser.getCurrentLineNumber());\n+            assertEquals(1, record.getRecordNumber());\n+            assertEquals(1, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(6, parser.getCurrentLineNumber());\n+            assertEquals(2, record.getRecordNumber());\n+            assertEquals(2, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(9, parser.getCurrentLineNumber());\n+            assertEquals(3, record.getRecordNumber());\n+            assertEquals(3, parser.getRecordNumber());\n+            assertNull(record = parser.nextRecord());\n+            assertEquals(9, parser.getCurrentLineNumber());\n+            assertEquals(3, parser.getRecordNumber());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetTrailerComment_HeaderComment1() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_AUTO_HEADER)) {\n+            parser.getRecords();\n+            assertFalse(parser.hasTrailerComment());\n+            assertNull(parser.getTrailerComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetTrailerComment_HeaderComment2() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER)) {\n+            parser.getRecords();\n+            assertFalse(parser.hasTrailerComment());\n+            assertNull(parser.getTrailerComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetTrailerComment_HeaderComment3() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\n+            parser.getRecords();\n+            assertFalse(parser.hasTrailerComment());\n+            assertNull(parser.getTrailerComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetTrailerComment_HeaderTrailerComment1() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_TRAILER_COMMENT, FORMAT_AUTO_HEADER)) {\n+            parser.getRecords();\n+            assertTrue(parser.hasTrailerComment());\n+            assertEquals(\"comment\", parser.getTrailerComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetTrailerComment_HeaderTrailerComment2() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_TRAILER_COMMENT, FORMAT_EXPLICIT_HEADER)) {\n+            parser.getRecords();\n+            assertTrue(parser.hasTrailerComment());\n+            assertEquals(\"comment\", parser.getTrailerComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetTrailerComment_HeaderTrailerComment3() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_TRAILER_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\n+            parser.getRecords();\n+            assertTrue(parser.hasTrailerComment());\n+            assertEquals(\"comment\", parser.getTrailerComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetTrailerComment_MultilineComment() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_MULTILINE_HEADER_TRAILER_COMMENT, FORMAT_AUTO_HEADER)) {\n+            parser.getRecords();\n+            assertTrue(parser.hasTrailerComment());\n+            assertEquals(\"multi-line\" + LF + \"comment\", parser.getTrailerComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testHeader() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+\n+            for (int i = 0; i < 2; i++) {\n+                assertTrue(records.hasNext());\n+                final CSVRecord record = records.next();\n+                assertEquals(record.get(0), record.get(\"a\"));\n+                assertEquals(record.get(1), record.get(\"b\"));\n+                assertEquals(record.get(2), record.get(\"c\"));\n+            }\n+\n+            assertFalse(records.hasNext());\n+        }\n+    }\n+\n+    @Test\n+    public void testHeaderComment() throws Exception {\n+        final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withCommentMarker('#').withHeader().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            for (int i = 0; i < 2; i++) {\n+                assertTrue(records.hasNext());\n+                final CSVRecord record = records.next();\n+                assertEquals(record.get(0), record.get(\"a\"));\n+                assertEquals(record.get(1), record.get(\"b\"));\n+                assertEquals(record.get(2), record.get(\"c\"));\n+            }\n+            assertFalse(records.hasNext());\n+        }\n+    }\n+\n+    @Test\n+    public void testHeaderMissing() throws Exception {\n+        final Reader in = new StringReader(\"a,,c\\n1,2,3\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            for (int i = 0; i < 2; i++) {\n+                assertTrue(records.hasNext());\n+                final CSVRecord record = records.next();\n+                assertEquals(record.get(0), record.get(\"a\"));\n+                assertEquals(record.get(2), record.get(\"c\"));\n+            }\n+            assertFalse(records.hasNext());\n+        }\n+    }\n+\n+    @Test\n+    public void testHeaderMissingWithNull() throws Exception {\n+        final Reader in = new StringReader(\"a,,c,,e\\n1,2,3,4,5\\nv,w,x,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().withNullString(\"\").withAllowMissingColumnNames().parse(in)) {\n+            parser.iterator();\n+        }\n+    }\n+\n+    @Test\n+    public void testHeadersMissing() throws Exception {\n+        try (Reader in = new StringReader(\"a,,c,,e\\n1,2,3,4,5\\nv,w,x,y,z\");\n+                CSVParser parser = CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames().parse(in)) {\n+            parser.iterator();\n+        }\n+    }\n+\n+    @Test\n+    public void testHeadersMissingException() {\n+        final Reader in = new StringReader(\"a,,c,,e\\n1,2,3,4,5\\nv,w,x,y,z\");\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withHeader().parse(in).iterator());\n+    }\n+\n+    @Test\n+    public void testHeadersMissingOneColumnException() {\n+        final Reader in = new StringReader(\"a,,c,d,e\\n1,2,3,4,5\\nv,w,x,y,z\");\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withHeader().parse(in).iterator());\n+    }\n+\n+    @Test\n+    public void testHeadersWithNullColumnName() throws IOException {\n+        final Reader in = new StringReader(\"header1,null,header3\\n1,2,3\\n4,5,6\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().withNullString(\"null\").withAllowMissingColumnNames().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            // Expect the null header to be missing\n+            @SuppressWarnings(\"resource\")\n+            final CSVParser recordParser = record.getParser();\n+            assertEquals(Arrays.asList(\"header1\", \"header3\"), recordParser.getHeaderNames());\n+            assertEquals(2, recordParser.getHeaderMap().size());\n+        }\n+    }\n+\n+    @Test\n+    public void testIgnoreCaseHeaderMapping() throws Exception {\n+        final Reader reader = new StringReader(\"1,2,3\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"One\", \"TWO\", \"three\").withIgnoreHeaderCase().parse(reader)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            assertEquals(\"1\", record.get(\"one\"));\n+            assertEquals(\"2\", record.get(\"two\"));\n+            assertEquals(\"3\", record.get(\"THREE\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testIgnoreEmptyLines() throws IOException {\n+        final String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n+        // String code = \"world\\r\\n\\n\";\n+        // String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\n+        try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(3, records.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testInvalidFormat() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter(CR));\n+    }\n+\n+    @Test\n+    public void testIterator() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.parse(in)) {\n+            final Iterator<CSVRecord> iterator = parser.iterator();\n+            assertTrue(iterator.hasNext());\n+            assertThrows(UnsupportedOperationException.class, iterator::remove);\n+            assertArrayEquals(new String[] { \"a\", \"b\", \"c\" }, iterator.next().values());\n+            assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, iterator.next().values());\n+            assertTrue(iterator.hasNext());\n+            assertTrue(iterator.hasNext());\n+            assertTrue(iterator.hasNext());\n+            assertArrayEquals(new String[] { \"x\", \"y\", \"z\" }, iterator.next().values());\n+            assertFalse(iterator.hasNext());\n+            assertThrows(NoSuchElementException.class, iterator::next);\n+        }\n+    }\n+\n+    @Test\n+    public void testIteratorSequenceBreaking() throws IOException {\n+        final String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\n+        // Iterator hasNext() shouldn't break sequence\n+        try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows))) {\n+            final Iterator<CSVRecord> iter = parser.iterator();\n+            int recordNumber = 0;\n+            while (iter.hasNext()) {\n+                final CSVRecord record = iter.next();\n+                recordNumber++;\n+                assertEquals(String.valueOf(recordNumber), record.get(0));\n+                if (recordNumber >= 2) {\n+                    break;\n+                }\n+            }\n+            iter.hasNext();\n+            while (iter.hasNext()) {\n+                final CSVRecord record = iter.next();\n+                recordNumber++;\n+                assertEquals(String.valueOf(recordNumber), record.get(0));\n+            }\n+        }\n+        // Consecutive enhanced for loops shouldn't break sequence\n+        try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows))) {\n+            int recordNumber = 0;\n+            for (final CSVRecord record : parser) {\n+                recordNumber++;\n+                assertEquals(String.valueOf(recordNumber), record.get(0));\n+                if (recordNumber >= 2) {\n+                    break;\n+                }\n+            }\n+            for (final CSVRecord record : parser) {\n+                recordNumber++;\n+                assertEquals(String.valueOf(recordNumber), record.get(0));\n+            }\n+        }\n+        // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence\n+        try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows))) {\n+            int recordNumber = 0;\n+            for (final CSVRecord record : parser) {\n+                recordNumber++;\n+                assertEquals(String.valueOf(recordNumber), record.get(0));\n+                if (recordNumber >= 2) {\n+                    break;\n+                }\n+            }\n+            parser.iterator().hasNext();\n+            for (final CSVRecord record : parser) {\n+                recordNumber++;\n+                assertEquals(String.valueOf(recordNumber), record.get(0));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testLineFeedEndings() throws IOException {\n+        final String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n+        try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").withSkipHeaderRecord().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            CSVRecord record;\n+            // 1st record\n+            record = records.next();\n+            assertTrue(record.isMapped(\"A\"));\n+            assertTrue(record.isMapped(\"B\"));\n+            assertTrue(record.isMapped(\"C\"));\n+            assertTrue(record.isSet(\"A\"));\n+            assertTrue(record.isSet(\"B\"));\n+            assertFalse(record.isSet(\"C\"));\n+            assertEquals(\"1\", record.get(\"A\"));\n+            assertEquals(\"2\", record.get(\"B\"));\n+            assertFalse(record.isConsistent());\n+            // 2nd record\n+            record = records.next();\n+            assertTrue(record.isMapped(\"A\"));\n+            assertTrue(record.isMapped(\"B\"));\n+            assertTrue(record.isMapped(\"C\"));\n+            assertTrue(record.isSet(\"A\"));\n+            assertTrue(record.isSet(\"B\"));\n+            assertTrue(record.isSet(\"C\"));\n+            assertEquals(\"x\", record.get(\"A\"));\n+            assertEquals(\"y\", record.get(\"B\"));\n+            assertEquals(\"z\", record.get(\"C\"));\n+            assertTrue(record.isConsistent());\n+            // end\n+            assertFalse(records.hasNext());\n+        }\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testMongoDbCsv() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"\\\"a a\\\",b,c\" + LF + \"d,e,f\", CSVFormat.MONGODB_CSV)) {\n+            final Iterator<CSVRecord> itr1 = parser.iterator();\n+            final Iterator<CSVRecord> itr2 = parser.iterator();\n+\n+            final CSVRecord first = itr1.next();\n+            assertEquals(\"a a\", first.get(0));\n+            assertEquals(\"b\", first.get(1));\n+            assertEquals(\"c\", first.get(2));\n+\n+            final CSVRecord second = itr2.next();\n+            assertEquals(\"d\", second.get(0));\n+            assertEquals(\"e\", second.get(1));\n+            assertEquals(\"f\", second.get(2));\n+        }\n+    }\n+\n+    @Test\n+    // TODO this may lead to strange behavior, throw an exception if iterator() has already been called?\n+    public void testMultipleIterators() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"a,b,c\" + CRLF + \"d,e,f\", CSVFormat.DEFAULT)) {\n+            final Iterator<CSVRecord> itr1 = parser.iterator();\n+\n+            final CSVRecord first = itr1.next();\n+            assertEquals(\"a\", first.get(0));\n+            assertEquals(\"b\", first.get(1));\n+            assertEquals(\"c\", first.get(2));\n+\n+            final CSVRecord second = itr1.next();\n+            assertEquals(\"d\", second.get(0));\n+            assertEquals(\"e\", second.get(1));\n+            assertEquals(\"f\", second.get(2));\n+        }\n+    }\n+\n+    @Test\n+    public void testNewCSVParserNullReaderFormat() {\n+        assertThrows(NullPointerException.class, () -> new CSVParser(null, CSVFormat.DEFAULT));\n+    }\n+\n+    @Test\n+    public void testNewCSVParserReaderNullFormat() {\n+        assertThrows(NullPointerException.class, () -> new CSVParser(new StringReader(\"\"), null));\n+    }\n+\n+    @Test\n+    public void testNoHeaderMap() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT)) {\n+            assertNull(parser.getHeaderMap());\n+        }\n+    }\n+\n+    @Test\n+    public void testNotValueCSV() throws IOException {\n+        final String source = \"#\";\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT.withCommentMarker('#');\n+        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\n+            final CSVRecord csvRecord = csvParser.nextRecord();\n+            assertNull(csvRecord);\n+        }\n+    }\n+\n+    @Test\n+    public void testParse() throws Exception {\n+        final ClassLoader loader = ClassLoader.getSystemClassLoader();\n+        final URL url = loader.getResource(\"org/apache/commons/csv/CSVFileParser/test.csv\");\n+        final CSVFormat format = CSVFormat.DEFAULT.builder().setHeader(\"A\", \"B\", \"C\", \"D\").get();\n+        final Charset charset = StandardCharsets.UTF_8;\n+        // Reader\n+        try (CSVParser parser = CSVParser.parse(new InputStreamReader(url.openStream(), charset), format)) {\n+            parseFully(parser);\n+        }\n+        try (CSVParser parser = CSVParser.builder().setReader(new InputStreamReader(url.openStream(), charset)).setFormat(format).get()) {\n+            parseFully(parser);\n+        }\n+        // String\n+        final Path path = Paths.get(url.toURI());\n+        final String string = new String(Files.readAllBytes(path), charset);\n+        try (CSVParser parser = CSVParser.parse(string, format)) {\n+            parseFully(parser);\n+        }\n+        try (CSVParser parser = CSVParser.builder().setCharSequence(string).setFormat(format).get()) {\n+            parseFully(parser);\n+        }\n+        // File\n+        final File file = new File(url.toURI());\n+        try (CSVParser parser = CSVParser.parse(file, charset, format)) {\n+            parseFully(parser);\n+        }\n+        try (CSVParser parser = CSVParser.builder().setFile(file).setCharset(charset).setFormat(format).get()) {\n+            parseFully(parser);\n+        }\n+        // InputStream\n+        try (CSVParser parser = CSVParser.parse(url.openStream(), charset, format)) {\n+            parseFully(parser);\n+        }\n+        try (CSVParser parser = CSVParser.builder().setInputStream(url.openStream()).setCharset(charset).setFormat(format).get()) {\n+            parseFully(parser);\n+        }\n+        // Path\n+        try (CSVParser parser = CSVParser.parse(path, charset, format)) {\n+            parseFully(parser);\n+        }\n+        try (CSVParser parser = CSVParser.builder().setPath(path).setCharset(charset).setFormat(format).get()) {\n+            parseFully(parser);\n+        }\n+        // URL\n+        try (CSVParser parser = CSVParser.parse(url, charset, format)) {\n+            parseFully(parser);\n+        }\n+        try (CSVParser parser = CSVParser.builder().setURI(url.toURI()).setCharset(charset).setFormat(format).get()) {\n+            parseFully(parser);\n+        }\n+        // InputStreamReader\n+        try (CSVParser parser = new CSVParser(new InputStreamReader(url.openStream(), charset), format)) {\n+            parseFully(parser);\n+        }\n+        try (CSVParser parser = CSVParser.builder().setReader(new InputStreamReader(url.openStream(), charset)).setFormat(format).get()) {\n+            parseFully(parser);\n+        }\n+        // InputStreamReader with longs\n+        try (CSVParser parser = new CSVParser(new InputStreamReader(url.openStream(), charset), format, /* characterOffset= */0, /* recordNumber= */1)) {\n+            parseFully(parser);\n+        }\n+        try (CSVParser parser = CSVParser.builder().setReader(new InputStreamReader(url.openStream(), charset)).setFormat(format).setCharacterOffset(0)\n+                .setRecordNumber(0).get()) {\n+            parseFully(parser);\n+        }\n+    }\n+\n+    @Test\n+    public void testParseFileNullFormat() {\n+        assertThrows(NullPointerException.class, () -> CSVParser.parse(new File(\"CSVFileParser/test.csv\"), Charset.defaultCharset(), null));\n+    }\n+\n+    @Test\n+    public void testParseNullFileFormat() {\n+        assertThrows(NullPointerException.class, () -> CSVParser.parse((File) null, Charset.defaultCharset(), CSVFormat.DEFAULT));\n+    }\n+\n+    @Test\n+    public void testParseNullPathFormat() {\n+        assertThrows(NullPointerException.class, () -> CSVParser.parse((Path) null, Charset.defaultCharset(), CSVFormat.DEFAULT));\n+    }\n+\n+    @Test\n+    public void testParseNullStringFormat() {\n+        assertThrows(NullPointerException.class, () -> CSVParser.parse((String) null, CSVFormat.DEFAULT));\n+    }\n+\n+    @Test\n+    public void testParseNullUrlCharsetFormat() {\n+        assertThrows(NullPointerException.class, () -> CSVParser.parse((URL) null, Charset.defaultCharset(), CSVFormat.DEFAULT));\n+    }\n+\n+    @Test\n+    public void testParserUrlNullCharsetFormat() {\n+        assertThrows(NullPointerException.class, () -> CSVParser.parse(new URL(\"https://commons.apache.org\"), null, CSVFormat.DEFAULT));\n+    }\n+\n+    @Test\n+    public void testParseStringNullFormat() {\n+        assertThrows(NullPointerException.class, () -> CSVParser.parse(\"csv data\", (CSVFormat) null));\n+    }\n+\n+    @Test\n+    public void testParseUrlCharsetNullFormat() {\n+        assertThrows(NullPointerException.class, () -> CSVParser.parse(new URL(\"https://commons.apache.org\"), Charset.defaultCharset(), null));\n+    }\n+\n+    @Test\n+    public void testParseWithDelimiterStringWithEscape() throws IOException {\n+        final String source = \"a![!|!]b![|]c[|]xyz\\r\\nabc[abc][|]xyz\";\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setEscape('!').get();\n+        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\n+            CSVRecord csvRecord = csvParser.nextRecord();\n+            assertEquals(\"a[|]b![|]c\", csvRecord.get(0));\n+            assertEquals(\"xyz\", csvRecord.get(1));\n+            csvRecord = csvParser.nextRecord();\n+            assertEquals(\"abc[abc]\", csvRecord.get(0));\n+            assertEquals(\"xyz\", csvRecord.get(1));\n+        }\n+    }\n+\n+    @Test\n+    public void testParseWithDelimiterStringWithQuote() throws IOException {\n+        final String source = \"'a[|]b[|]c'[|]xyz\\r\\nabc[abc][|]xyz\";\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setQuote('\\'').get();\n+        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\n+            CSVRecord csvRecord = csvParser.nextRecord();\n+            assertEquals(\"a[|]b[|]c\", csvRecord.get(0));\n+            assertEquals(\"xyz\", csvRecord.get(1));\n+            csvRecord = csvParser.nextRecord();\n+            assertEquals(\"abc[abc]\", csvRecord.get(0));\n+            assertEquals(\"xyz\", csvRecord.get(1));\n+        }\n+    }\n+\n+    @Test\n+    public void testParseWithDelimiterWithEscape() throws IOException {\n+        final String source = \"a!,b!,c,xyz\";\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT.withEscape('!');\n+        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\n+            final CSVRecord csvRecord = csvParser.nextRecord();\n+            assertEquals(\"a,b,c\", csvRecord.get(0));\n+            assertEquals(\"xyz\", csvRecord.get(1));\n+        }\n+    }\n+\n+    @Test\n+    public void testParseWithDelimiterWithQuote() throws IOException {\n+        final String source = \"'a,b,c',xyz\";\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT.withQuote('\\'');\n+        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\n+            final CSVRecord csvRecord = csvParser.nextRecord();\n+            assertEquals(\"a,b,c\", csvRecord.get(0));\n+            assertEquals(\"xyz\", csvRecord.get(1));\n+        }\n+    }\n+\n+    @Test\n+    public void testParseWithQuoteThrowsException() {\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT.withQuote('\\'');\n+        assertThrows(IOException.class, () -> csvFormat.parse(new StringReader(\"'a,b,c','\")).nextRecord());\n+        assertThrows(IOException.class, () -> csvFormat.parse(new StringReader(\"'a,b,c'abc,xyz\")).nextRecord());\n+        assertThrows(IOException.class, () -> csvFormat.parse(new StringReader(\"'abc'a,b,c',xyz\")).nextRecord());\n+    }\n+\n+    @Test\n+    public void testParseWithQuoteWithEscape() throws IOException {\n+        final String source = \"'a?,b?,c?d',xyz\";\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT.withQuote('\\'').withEscape('?');\n+        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\n+            final CSVRecord csvRecord = csvParser.nextRecord();\n+            assertEquals(\"a,b,c?d\", csvRecord.get(0));\n+            assertEquals(\"xyz\", csvRecord.get(1));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(CSVFormat.Predefined.class)\n+    public void testParsingPrintedEmptyFirstColumn(final CSVFormat.Predefined format) throws Exception {\n+        final String[][] lines = { { \"a\", \"b\" }, { \"\", \"x\" } };\n+        final StringWriter buf = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(buf, format.getFormat())) {\n+            printer.printRecords(Stream.of(lines));\n+        }\n+        try (CSVParser csvRecords = CSVParser.builder()\n+                .setReader(new StringReader(buf.toString()))\n+                .setFormat(format.getFormat())\n+                .get()) {\n+            for (final String[] line : lines) {\n+                assertArrayEquals(line, csvRecords.nextRecord().values());\n+            }\n+            assertNull(csvRecords.nextRecord());\n+        }\n+    }\n+\n+    @Test\n+    public void testProvidedHeader() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+\n+            for (int i = 0; i < 3; i++) {\n+                assertTrue(records.hasNext());\n+                final CSVRecord record = records.next();\n+                assertTrue(record.isMapped(\"A\"));\n+                assertTrue(record.isMapped(\"B\"));\n+                assertTrue(record.isMapped(\"C\"));\n+                assertFalse(record.isMapped(\"NOT MAPPED\"));\n+                assertEquals(record.get(0), record.get(\"A\"));\n+                assertEquals(record.get(1), record.get(\"B\"));\n+                assertEquals(record.get(2), record.get(\"C\"));\n+            }\n+\n+            assertFalse(records.hasNext());\n+        }\n+    }\n+\n+    @Test\n+    public void testProvidedHeaderAuto() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+\n+            for (int i = 0; i < 2; i++) {\n+                assertTrue(records.hasNext());\n+                final CSVRecord record = records.next();\n+                assertTrue(record.isMapped(\"a\"));\n+                assertTrue(record.isMapped(\"b\"));\n+                assertTrue(record.isMapped(\"c\"));\n+                assertFalse(record.isMapped(\"NOT MAPPED\"));\n+                assertEquals(record.get(0), record.get(\"a\"));\n+                assertEquals(record.get(1), record.get(\"b\"));\n+                assertEquals(record.get(2), record.get(\"c\"));\n+            }\n+\n+            assertFalse(records.hasNext());\n+        }\n+    }\n+\n+    @Test\n+    public void testRepeatedHeadersAreReturnedInCSVRecordHeaderNames() throws IOException {\n+        final Reader in = new StringReader(\"header1,header2,header1\\n1,2,3\\n4,5,6\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withFirstRecordAsHeader().withTrim().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            @SuppressWarnings(\"resource\")\n+            final CSVParser recordParser = record.getParser();\n+            assertEquals(Arrays.asList(\"header1\", \"header2\", \"header1\"), recordParser.getHeaderNames());\n+        }\n+    }\n+\n+    @Test\n+    public void testRoundtrip() throws Exception {\n+        final StringWriter out = new StringWriter();\n+        final String data = \"a,b,c\\r\\n1,2,3\\r\\nx,y,z\\r\\n\";\n+        try (CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT);\n+                CSVParser parse = CSVParser.parse(data, CSVFormat.DEFAULT)) {\n+            for (final CSVRecord record : parse) {\n+                printer.printRecord(record);\n+            }\n+            assertEquals(data, out.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testSkipAutoHeader() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            assertEquals(\"1\", record.get(\"a\"));\n+            assertEquals(\"2\", record.get(\"b\"));\n+            assertEquals(\"3\", record.get(\"c\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testSkipHeaderOverrideDuplicateHeaders() throws Exception {\n+        final Reader in = new StringReader(\"a,a,a\\n1,2,3\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            assertEquals(\"1\", record.get(\"X\"));\n+            assertEquals(\"2\", record.get(\"Y\"));\n+            assertEquals(\"3\", record.get(\"Z\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testSkipSetAltHeaders() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            assertEquals(\"1\", record.get(\"X\"));\n+            assertEquals(\"2\", record.get(\"Y\"));\n+            assertEquals(\"3\", record.get(\"Z\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testSkipSetHeader() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"a\", \"b\", \"c\").withSkipHeaderRecord().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            assertEquals(\"1\", record.get(\"a\"));\n+            assertEquals(\"2\", record.get(\"b\"));\n+            assertEquals(\"3\", record.get(\"c\"));\n+        }\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testStartWithEmptyLinesThenHeaders() throws Exception {\n+        final String[] codes = { \"\\r\\n\\r\\n\\r\\nhello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\n+        final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\n+                { \"\" } };\n+        for (final String code : codes) {\n+            try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\n+                final List<CSVRecord> records = parser.getRecords();\n+                assertEquals(res.length, records.size());\n+                assertFalse(records.isEmpty());\n+                for (int i = 0; i < res.length; i++) {\n+                    assertArrayEquals(res[i], records.get(i).values());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testStream() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.parse(in)) {\n+            final List<CSVRecord> list = parser.stream().collect(Collectors.toList());\n+            assertFalse(list.isEmpty());\n+            assertArrayEquals(new String[] { \"a\", \"b\", \"c\" }, list.get(0).values());\n+            assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, list.get(1).values());\n+            assertArrayEquals(new String[] { \"x\", \"y\", \"z\" }, list.get(2).values());\n+        }\n+    }\n+\n+    @Test\n+    public void testThrowExceptionWithLineAndPosition() throws IOException {\n+        final String csvContent = \"col1,col2,col3,col4,col5,col6,col7,col8,col9,col10\\nrec1,rec2,rec3,rec4,rec5,rec6,rec7,rec8,\\\"\\\"rec9\\\"\\\",rec10\";\n+        final StringReader stringReader = new StringReader(csvContent);\n+        // @formatter:off\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT.builder()\n+                .setHeader()\n+                .setSkipHeaderRecord(true)\n+                .get();\n+        // @formatter:on\n+        try (CSVParser csvParser = csvFormat.parse(stringReader)) {\n+            final UncheckedIOException exception = assertThrows(UncheckedIOException.class, csvParser::getRecords);\n+            assertInstanceOf(CSVException.class, exception.getCause());\n+            assertTrue(exception.getMessage().contains(\"Invalid character between encapsulated token and delimiter at line: 2, position: 94\"),\n+                    exception::getMessage);\n+        }\n+    }\n+\n+    @Test\n+    public void testTrailingDelimiter() throws Exception {\n+        final Reader in = new StringReader(\"a,a,a,\\n\\\"1\\\",\\\"2\\\",\\\"3\\\",\\nx,y,z,\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrailingDelimiter().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            assertEquals(\"1\", record.get(\"X\"));\n+            assertEquals(\"2\", record.get(\"Y\"));\n+            assertEquals(\"3\", record.get(\"Z\"));\n+            assertEquals(3, record.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testTrim() throws Exception {\n+        final Reader in = new StringReader(\"a,a,a\\n\\\" 1 \\\",\\\" 2 \\\",\\\" 3 \\\"\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrim().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            assertEquals(\"1\", record.get(\"X\"));\n+            assertEquals(\"2\", record.get(\"Y\"));\n+            assertEquals(\"3\", record.get(\"Z\"));\n+            assertEquals(3, record.size());\n+        }\n+    }\n+\n+    private void validateLineNumbers(final String lineSeparator) throws IOException {\n+        try (CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator))) {\n+            assertEquals(0, parser.getCurrentLineNumber());\n+            assertNotNull(parser.nextRecord());\n+            assertEquals(1, parser.getCurrentLineNumber());\n+            assertNotNull(parser.nextRecord());\n+            assertEquals(2, parser.getCurrentLineNumber());\n+            assertNotNull(parser.nextRecord());\n+            // Read EOF without EOL should 3\n+            assertEquals(3, parser.getCurrentLineNumber());\n+            assertNull(parser.nextRecord());\n+            // Read EOF without EOL should 3\n+            assertEquals(3, parser.getCurrentLineNumber());\n+        }\n+    }\n+\n+    private void validateRecordNumbers(final String lineSeparator) throws IOException {\n+        try (CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator))) {\n+            CSVRecord record;\n+            assertEquals(0, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(1, record.getRecordNumber());\n+            assertEquals(1, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(2, record.getRecordNumber());\n+            assertEquals(2, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(3, record.getRecordNumber());\n+            assertEquals(3, parser.getRecordNumber());\n+            assertNull(record = parser.nextRecord());\n+            assertEquals(3, parser.getRecordNumber());\n+        }\n+    }\n+\n+    private void validateRecordPosition(final String lineSeparator) throws IOException {\n+        final String nl = lineSeparator; // used as linebreak in values for better distinction\n+        final String code = \"a,b,c\" + lineSeparator + \"1,2,3\" + lineSeparator +\n+                // to see if recordPosition correctly points to the enclosing quote\n+                \"'A\" + nl + \"A','B\" + nl + \"B',CC\" + lineSeparator +\n+                // unicode test... not very relevant while operating on strings instead of bytes, but for\n+                // completeness...\n+                \"\\u00c4,\\u00d6,\\u00dc\" + lineSeparator + \"EOF,EOF,EOF\";\n+        final CSVFormat format = CSVFormat.newFormat(',').withQuote('\\'').withRecordSeparator(lineSeparator);\n+        final long positionRecord3;\n+        try (CSVParser parser = CSVParser.parse(code, format)) {\n+            CSVRecord record;\n+            assertEquals(0, parser.getRecordNumber());\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(1, record.getRecordNumber());\n+            assertEquals(code.indexOf('a'), record.getCharacterPosition());\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(2, record.getRecordNumber());\n+            assertEquals(code.indexOf('1'), record.getCharacterPosition());\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            positionRecord3 = record.getCharacterPosition();\n+            assertEquals(3, record.getRecordNumber());\n+            assertEquals(code.indexOf(\"'A\"), record.getCharacterPosition());\n+            assertEquals(\"A\" + lineSeparator + \"A\", record.get(0));\n+            assertEquals(\"B\" + lineSeparator + \"B\", record.get(1));\n+            assertEquals(\"CC\", record.get(2));\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(4, record.getRecordNumber());\n+            assertEquals(code.indexOf('\\u00c4'), record.getCharacterPosition());\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(5, record.getRecordNumber());\n+            assertEquals(code.indexOf(\"EOF\"), record.getCharacterPosition());\n+        }\n+        // now try to read starting at record 3\n+        try (CSVParser parser = CSVParser.builder()\n+                .setReader(new StringReader(code.substring((int) positionRecord3)))\n+                .setFormat(format)\n+                .setCharacterOffset(positionRecord3)\n+                .setRecordNumber(3)\n+                .get()) {\n+            CSVRecord record;\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(3, record.getRecordNumber());\n+            assertEquals(code.indexOf(\"'A\"), record.getCharacterPosition());\n+            assertEquals(\"A\" + lineSeparator + \"A\", record.get(0));\n+            assertEquals(\"B\" + lineSeparator + \"B\", record.get(1));\n+            assertEquals(\"CC\", record.get(2));\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(4, record.getRecordNumber());\n+            assertEquals(code.indexOf('\\u00c4'), record.getCharacterPosition());\n+            assertEquals(\"\\u00c4\", record.get(0));\n+        } // again with ctor\n+        try (CSVParser parser = new CSVParser(new StringReader(code.substring((int) positionRecord3)), format, positionRecord3, 3)) {\n+            CSVRecord record;\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(3, record.getRecordNumber());\n+            assertEquals(code.indexOf(\"'A\"), record.getCharacterPosition());\n+            assertEquals(\"A\" + lineSeparator + \"A\", record.get(0));\n+            assertEquals(\"B\" + lineSeparator + \"B\", record.get(1));\n+            assertEquals(\"CC\", record.get(2));\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(4, record.getRecordNumber());\n+            assertEquals(code.indexOf('\\u00c4'), record.getCharacterPosition());\n+            assertEquals(\"\\u00c4\", record.get(0));\n+        }\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\nindex b4b560a1..f457460c 100644\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n@@ -1,1926 +1,1926 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv;\r\n-\r\n-import static org.apache.commons.csv.Constants.BACKSLASH;\r\n-import static org.apache.commons.csv.Constants.CR;\r\n-import static org.junit.jupiter.api.Assertions.assertArrayEquals;\r\n-import static org.junit.jupiter.api.Assertions.assertEquals;\r\n-import static org.junit.jupiter.api.Assertions.assertFalse;\r\n-import static org.junit.jupiter.api.Assertions.assertNotEquals;\r\n-import static org.junit.jupiter.api.Assertions.assertNull;\r\n-import static org.junit.jupiter.api.Assertions.assertThrows;\r\n-import static org.mockito.Mockito.mock;\r\n-import static org.mockito.Mockito.never;\r\n-import static org.mockito.Mockito.times;\r\n-import static org.mockito.Mockito.verify;\r\n-\r\n-import java.io.CharArrayWriter;\r\n-import java.io.File;\r\n-import java.io.FileReader;\r\n-import java.io.IOException;\r\n-import java.io.PrintStream;\r\n-import java.io.Reader;\r\n-import java.io.StringReader;\r\n-import java.io.StringWriter;\r\n-import java.io.Writer;\r\n-import java.nio.charset.Charset;\r\n-import java.nio.charset.StandardCharsets;\r\n-import java.nio.file.Files;\r\n-import java.nio.file.Path;\r\n-import java.sql.BatchUpdateException;\r\n-import java.sql.Connection;\r\n-import java.sql.DriverManager;\r\n-import java.sql.ResultSet;\r\n-import java.sql.SQLException;\r\n-import java.sql.Statement;\r\n-import java.util.Arrays;\r\n-import java.util.Date;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.Objects;\r\n-import java.util.Random;\r\n-import java.util.Vector;\r\n-import java.util.stream.Stream;\r\n-\r\n-import org.apache.commons.io.FileUtils;\r\n-import org.apache.commons.io.IOUtils;\r\n-import org.apache.commons.io.output.NullOutputStream;\r\n-import org.apache.commons.lang3.StringUtils;\r\n-import org.h2.tools.SimpleResultSet;\r\n-import org.junit.jupiter.api.Disabled;\r\n-import org.junit.jupiter.api.Test;\r\n-\r\n-/**\r\n- * Tests {@link CSVPrinter}.\r\n- */\r\n-public class CSVPrinterTest {\r\n-\r\n-    private static final int TABLE_RECORD_COUNT = 2;\r\n-    private static final char DQUOTE_CHAR = '\"';\r\n-    private static final char EURO_CH = '\\u20AC';\r\n-    private static final int ITERATIONS_FOR_RANDOM_TEST = 50000;\r\n-    private static final char QUOTE_CH = '\\'';\r\n-\r\n-    private static String printable(final String s) {\r\n-        final StringBuilder sb = new StringBuilder();\r\n-        for (int i = 0; i < s.length(); i++) {\r\n-            final char ch = s.charAt(i);\r\n-            if (ch <= ' ' || ch >= 128) {\r\n-                sb.append(\"(\").append((int) ch).append(\")\");\r\n-            } else {\r\n-                sb.append(ch);\r\n-            }\r\n-        }\r\n-        return sb.toString();\r\n-    }\r\n-\r\n-    private String longText2;\r\n-\r\n-    private final String recordSeparator = CSVFormat.DEFAULT.getRecordSeparator();\r\n-\r\n-    private void assertInitialState(final CSVPrinter printer) {\r\n-        assertEquals(0, printer.getRecordCount());\r\n-    }\r\n-\r\n-    private File createTempFile() throws IOException {\r\n-        return createTempPath().toFile();\r\n-    }\r\n-\r\n-    private Path createTempPath() throws IOException {\r\n-        return Files.createTempFile(getClass().getName(), \".csv\");\r\n-    }\r\n-\r\n-    private void doOneRandom(final CSVFormat format) throws Exception {\r\n-        final Random r = new Random();\r\n-\r\n-        final int nLines = r.nextInt(4) + 1;\r\n-        final int nCol = r.nextInt(3) + 1;\r\n-        // nLines=1;nCol=2;\r\n-        final String[][] lines = generateLines(nLines, nCol);\r\n-\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n-\r\n-            for (int i = 0; i < nLines; i++) {\r\n-                // for (int j=0; j<lines[i].length; j++) System.out.println(\"### VALUE=:\" + printable(lines[i][j]));\r\n-                printer.printRecord((Object[]) lines[i]);\r\n-            }\r\n-\r\n-            printer.flush();\r\n-        }\r\n-        final String result = sw.toString();\r\n-        // System.out.println(\"### :\" + printable(result));\r\n-\r\n-        try (CSVParser parser = CSVParser.parse(result, format)) {\r\n-            final List<CSVRecord> parseResult = parser.getRecords();\r\n-\r\n-            final String[][] expected = lines.clone();\r\n-            for (int i = 0; i < expected.length; i++) {\r\n-                expected[i] = expectNulls(expected[i], format);\r\n-            }\r\n-            Utils.compare(\"Printer output :\" + printable(result), expected, parseResult);\r\n-        }\r\n-    }\r\n-\r\n-    private void doRandom(final CSVFormat format, final int iter) throws Exception {\r\n-        for (int i = 0; i < iter; i++) {\r\n-            doOneRandom(format);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Converts an input CSV array into expected output values WRT NULLs. NULL strings are converted to null values because the parser will convert these\r\n-     * strings to null.\r\n-     */\r\n-    private <T> T[] expectNulls(final T[] original, final CSVFormat csvFormat) {\r\n-        final T[] fixed = original.clone();\r\n-        for (int i = 0; i < fixed.length; i++) {\r\n-            if (Objects.equals(csvFormat.getNullString(), fixed[i])) {\r\n-                fixed[i] = null;\r\n-            }\r\n-        }\r\n-        return fixed;\r\n-    }\r\n-\r\n-    private String[][] generateLines(final int nLines, final int nCol) {\r\n-        final String[][] lines = new String[nLines][];\r\n-        for (int i = 0; i < nLines; i++) {\r\n-            final String[] line = new String[nCol];\r\n-            lines[i] = line;\r\n-            for (int j = 0; j < nCol; j++) {\r\n-                line[j] = randStr();\r\n-            }\r\n-        }\r\n-        return lines;\r\n-    }\r\n-\r\n-    private Connection getH2Connection() throws SQLException, ClassNotFoundException {\r\n-        Class.forName(\"org.h2.Driver\");\r\n-        return DriverManager.getConnection(\"jdbc:h2:mem:my_test;\", \"sa\", \"\");\r\n-    }\r\n-\r\n-    private CSVPrinter printWithHeaderComments(final StringWriter sw, final Date now, final CSVFormat baseFormat) throws IOException {\r\n-        // Use withHeaderComments first to test CSV-145\r\n-        // @formatter:off\r\n-        final CSVFormat format = baseFormat.builder()\r\n-                .setHeaderComments((String[]) null) // don't blow up\r\n-                .setHeaderComments((Object[]) null) // don't blow up\r\n-                .setHeaderComments(\"Generated by Apache Commons CSV 1.1\", now)\r\n-                .setCommentMarker('#')\r\n-                .setHeader(\"Col1\", \"Col2\")\r\n-                .get();\r\n-        // @formatter:on\r\n-        final CSVPrinter printer = format.print(sw);\r\n-        printer.printRecord(\"A\", \"B\");\r\n-        printer.printRecord(\"C\", \"D\");\r\n-        printer.close();\r\n-        return printer;\r\n-    }\r\n-\r\n-    private String randStr() {\r\n-        final Random r = new Random();\r\n-        final int sz = r.nextInt(20);\r\n-        // sz = r.nextInt(3);\r\n-        final char[] buf = new char[sz];\r\n-        for (int i = 0; i < sz; i++) {\r\n-            // stick in special chars with greater frequency\r\n-            final char ch;\r\n-            final int what = r.nextInt(20);\r\n-            switch (what) {\r\n-            case 0:\r\n-                ch = '\\r';\r\n-                break;\r\n-            case 1:\r\n-                ch = '\\n';\r\n-                break;\r\n-            case 2:\r\n-                ch = '\\t';\r\n-                break;\r\n-            case 3:\r\n-                ch = '\\f';\r\n-                break;\r\n-            case 4:\r\n-                ch = ' ';\r\n-                break;\r\n-            case 5:\r\n-                ch = ',';\r\n-                break;\r\n-            case 6:\r\n-                ch = DQUOTE_CHAR;\r\n-                break;\r\n-            case 7:\r\n-                ch = '\\'';\r\n-                break;\r\n-            case 8:\r\n-                ch = BACKSLASH;\r\n-                break;\r\n-            default:\r\n-                ch = (char) r.nextInt(300);\r\n-                break;\r\n-            // default: ch = 'a'; break;\r\n-            }\r\n-            buf[i] = ch;\r\n-        }\r\n-        return new String(buf);\r\n-    }\r\n-\r\n-    private void setUpTable(final Connection connection) throws SQLException {\r\n-        try (Statement statement = connection.createStatement()) {\r\n-            statement.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255), TEXT CLOB, BIN_DATA BLOB)\");\r\n-            statement.execute(\"insert into TEST values(1, 'r1', 'long text 1', 'binary data 1')\");\r\n-            longText2 = StringUtils.repeat('a', IOUtils.DEFAULT_BUFFER_SIZE - 4);\r\n-            longText2 += \"\\\"\\r\\n\\\"b\\\"\";\r\n-            longText2 += StringUtils.repeat('c', IOUtils.DEFAULT_BUFFER_SIZE - 1);\r\n-            statement.execute(\"insert into TEST values(2, 'r2', '\" + longText2 + \"', 'binary data 2')\");\r\n-            longText2 = longText2.replace(\"\\\"\", \"\\\"\\\"\");\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCloseBackwardCompatibility() throws IOException {\r\n-        try (Writer writer = mock(Writer.class)) {\r\n-            final CSVFormat csvFormat = CSVFormat.DEFAULT;\r\n-            try (CSVPrinter printer = new CSVPrinter(writer, csvFormat)) {\r\n-                assertInitialState(printer);\r\n-            }\r\n-            verify(writer, never()).flush();\r\n-            verify(writer, times(1)).close();\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCloseWithCsvFormatAutoFlushOff() throws IOException {\r\n-        try (Writer writer = mock(Writer.class)) {\r\n-            final CSVFormat csvFormat = CSVFormat.DEFAULT.withAutoFlush(false);\r\n-            try (CSVPrinter printer = new CSVPrinter(writer, csvFormat)) {\r\n-                assertInitialState(printer);\r\n-            }\r\n-            verify(writer, never()).flush();\r\n-            verify(writer, times(1)).close();\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCloseWithCsvFormatAutoFlushOn() throws IOException {\r\n-        // System.out.println(\"start method\");\r\n-        try (Writer writer = mock(Writer.class)) {\r\n-            final CSVFormat csvFormat = CSVFormat.DEFAULT.withAutoFlush(true);\r\n-            try (CSVPrinter printer = new CSVPrinter(writer, csvFormat)) {\r\n-                assertInitialState(printer);\r\n-            }\r\n-            verify(writer, times(1)).flush();\r\n-            verify(writer, times(1)).close();\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCloseWithFlushOff() throws IOException {\r\n-        try (Writer writer = mock(Writer.class)) {\r\n-            final CSVFormat csvFormat = CSVFormat.DEFAULT;\r\n-            @SuppressWarnings(\"resource\")\r\n-            final CSVPrinter printer = new CSVPrinter(writer, csvFormat);\r\n-            assertInitialState(printer);\r\n-            printer.close(false);\r\n-            assertEquals(0, printer.getRecordCount());\r\n-            verify(writer, never()).flush();\r\n-            verify(writer, times(1)).close();\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCloseWithFlushOn() throws IOException {\r\n-        try (Writer writer = mock(Writer.class)) {\r\n-            @SuppressWarnings(\"resource\")\r\n-            final CSVPrinter printer = new CSVPrinter(writer, CSVFormat.DEFAULT);\r\n-            assertInitialState(printer);\r\n-            printer.close(true);\r\n-            assertEquals(0, printer.getRecordCount());\r\n-            verify(writer, times(1)).flush();\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCRComment() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        final Object value = \"abc\";\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(value);\r\n-            assertEquals(0, printer.getRecordCount());\r\n-            printer.printComment(\"This is a comment\\r\\non multiple lines\\rthis is next comment\\r\");\r\n-            assertEquals(\"abc\" + recordSeparator + \"# This is a comment\" + recordSeparator + \"# on multiple lines\" + recordSeparator +\r\n-                    \"# this is next comment\" + recordSeparator + \"# \" + recordSeparator, sw.toString());\r\n-            assertEquals(0, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV135() throws IOException {\r\n-        final List<String> list = new LinkedList<>();\r\n-        list.add(\"\\\"\\\"\"); // \"\"\r\n-        list.add(\"\\\\\\\\\"); // \\\\\r\n-        list.add(\"\\\\\\\"\\\\\"); // \\\"\\\r\n-        //\r\n-        // \"\",\\\\,\\\"\\ (unchanged)\r\n-        tryFormat(list, null, null, \"\\\"\\\",\\\\\\\\,\\\\\\\"\\\\\");\r\n-        //\r\n-        // \"\"\"\"\"\",\\\\,\"\\\"\"\\\" (quoted, and embedded DQ doubled)\r\n-        tryFormat(list, '\"', null, \"\\\"\\\"\\\"\\\"\\\"\\\",\\\\\\\\,\\\"\\\\\\\"\\\"\\\\\\\"\");\r\n-        //\r\n-        // \"\",\\\\\\\\,\\\\\"\\\\ (escapes escaped, not quoted)\r\n-        tryFormat(list, null, '\\\\', \"\\\"\\\",\\\\\\\\\\\\\\\\,\\\\\\\\\\\"\\\\\\\\\");\r\n-        //\r\n-        // \"\\\"\\\"\",\"\\\\\\\\\",\"\\\\\\\"\\\\\" (quoted, and embedded DQ & escape escaped)\r\n-        tryFormat(list, '\"', '\\\\', \"\\\"\\\\\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\\\\\\\\\",\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\"\");\r\n-        //\r\n-        // \"\"\"\"\"\",\\\\,\"\\\"\"\\\" (quoted, embedded DQ escaped)\r\n-        tryFormat(list, '\"', '\"', \"\\\"\\\"\\\"\\\"\\\"\\\",\\\\\\\\,\\\"\\\\\\\"\\\"\\\\\\\"\");\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV259() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (Reader reader = new FileReader(\"src/test/resources/org/apache/commons/csv/CSV-259/sample.txt\");\r\n-                CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(reader);\r\n-            assertEquals(\"x!,y!,z\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimeterQuoted() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a,b,c\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"'a,b,c',xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimeterQuoteNone() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        final CSVFormat format = CSVFormat.DEFAULT.withEscape('!').withQuoteMode(QuoteMode.NONE);\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a,b,c\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"a!,b!,c,xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimeterStringQuoted() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setQuote('\\'').get())) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a[|]b[|]c\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"'a[|]b[|]c'[|]xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimeterStringQuoteNone() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        final CSVFormat format = CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setEscape('!').setQuoteMode(QuoteMode.NONE).get();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a[|]b[|]c\");\r\n-            printer.print(\"xyz\");\r\n-            printer.print(\"a[xy]bc[]\");\r\n-            assertEquals(\"a![!|!]b![!|!]c[|]xyz[|]a[xy]bc[]\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimiterEscaped() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a,b,c\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"a!,b!,c,xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimiterPlain() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a,b,c\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"a,b,c,xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimiterStringEscaped() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.builder().setDelimiter(\"|||\").setEscape('!').setQuote(null).get())) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a|||b|||c\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"a!|!|!|b!|!|!|c|||xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDisabledComment() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printComment(\"This is a comment\");\r\n-            assertEquals(\"\", sw.toString());\r\n-            assertEquals(0, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDontQuoteEuroFirstChar() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(EURO_CH, \"Deux\");\r\n-            assertEquals(EURO_CH + \",Deux\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEolEscaped() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a\\rb\\nc\");\r\n-            printer.print(\"x\\fy\\bz\");\r\n-            assertEquals(\"a!rb!nc,x\\fy\\bz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEolPlain() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a\\rb\\nc\");\r\n-            printer.print(\"x\\fy\\bz\");\r\n-            assertEquals(\"a\\rb\\nc,x\\fy\\bz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEolQuoted() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a\\rb\\nc\");\r\n-            printer.print(\"x\\by\\fz\");\r\n-            assertEquals(\"'a\\rb\\nc',x\\by\\fz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"unlikely-arg-type\")\r\n-    @Test\r\n-    public void testEquals() throws IOException {\r\n-        // Don't use assertNotEquals here\r\n-        assertFalse(CSVFormat.DEFAULT.equals(null));\r\n-        // Don't use assertNotEquals here\r\n-        assertFalse(CSVFormat.DEFAULT.equals(\"\"));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeBackslash1() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"\\\\\");\r\n-        }\r\n-        assertEquals(\"\\\\\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeBackslash2() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"\\\\\\r\");\r\n-        }\r\n-        assertEquals(\"'\\\\\\r'\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeBackslash3() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"X\\\\\\r\");\r\n-        }\r\n-        assertEquals(\"'X\\\\\\r'\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeBackslash4() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"\\\\\\\\\");\r\n-        }\r\n-        assertEquals(\"\\\\\\\\\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeBackslash5() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"\\\\\\\\\");\r\n-        }\r\n-        assertEquals(\"\\\\\\\\\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeNull1() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"\\\\\");\r\n-        }\r\n-        assertEquals(\"\\\\\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeNull2() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"\\\\\\r\");\r\n-        }\r\n-        assertEquals(\"\\\"\\\\\\r\\\"\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeNull3() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"X\\\\\\r\");\r\n-        }\r\n-        assertEquals(\"\\\"X\\\\\\r\\\"\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeNull4() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"\\\\\\\\\");\r\n-        }\r\n-        assertEquals(\"\\\\\\\\\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeNull5() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"\\\\\\\\\");\r\n-        }\r\n-        assertEquals(\"\\\\\\\\\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllArrayOfArrays() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords((Object[]) new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } });\r\n-            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllArrayOfArraysWithFirstEmptyValue2() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords((Object[]) new String[][] { { \"\" } });\r\n-            assertEquals(\"\\\"\\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllArrayOfArraysWithFirstSpaceValue1() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords((Object[]) new String[][] { { \" \", \"r1c2\" } });\r\n-            assertEquals(\"\\\" \\\",r1c2\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllArrayOfArraysWithFirstTabValue1() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords((Object[]) new String[][] { { \"\\t\", \"r1c2\" } });\r\n-            assertEquals(\"\\\"\\t\\\",r1c2\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllArrayOfLists() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords((Object[]) new List[] { Arrays.asList(\"r1c1\", \"r1c2\"), Arrays.asList(\"r2c1\", \"r2c2\") });\r\n-            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllArrayOfListsWithFirstEmptyValue2() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords((Object[]) new List[] { Arrays.asList(\"\") });\r\n-            assertEquals(\"\\\"\\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllIterableOfArrays() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords(Arrays.asList(new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } }));\r\n-            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllIterableOfArraysWithFirstEmptyValue2() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords(Arrays.asList(new String[][] { { \"\" } }));\r\n-            assertEquals(\"\\\"\\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllIterableOfLists() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords(Arrays.asList(Arrays.asList(\"r1c1\", \"r1c2\"), Arrays.asList(\"r2c1\", \"r2c2\")));\r\n-            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllStreamOfArrays() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords(Stream.of(new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } }));\r\n-            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrinter1() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", \"b\");\r\n-            assertEquals(\"a,b\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrinter2() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a,b\", \"b\");\r\n-            assertEquals(\"\\\"a,b\\\",b\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeader() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\"))) {\r\n-            assertEquals(1, printer.getRecordCount());\r\n-            printer.printRecord(\"a\", \"b\", \"c\");\r\n-            printer.printRecord(\"x\", \"y\", \"z\");\r\n-            assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeaderCommentExcel() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        final Date now = new Date();\r\n-        final CSVFormat format = CSVFormat.EXCEL;\r\n-        try (CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format)) {\r\n-            assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1,Col2\\r\\nA,B\\r\\nC,D\\r\\n\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeaderCommentTdf() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        final Date now = new Date();\r\n-        final CSVFormat format = CSVFormat.TDF;\r\n-        try (CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format)) {\r\n-            assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1\\tCol2\\r\\nA\\tB\\r\\nC\\tD\\r\\n\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeaderNotSet() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", \"b\", \"c\");\r\n-            printer.printRecord(\"x\", \"y\", \"z\");\r\n-            assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testInvalidFormat() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter(CR));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testJdbcPrinter() throws IOException, ClassNotFoundException, SQLException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT;\r\n-        try (Connection connection = getH2Connection()) {\r\n-            setUpTable(connection);\r\n-            try (Statement stmt = connection.createStatement();\r\n-                    CSVPrinter printer = new CSVPrinter(sw, csvFormat);\r\n-                    ResultSet resultSet = stmt.executeQuery(\"select ID, NAME, TEXT, BIN_DATA from TEST\")) {\r\n-                assertInitialState(printer);\r\n-                printer.printRecords(resultSet);\r\n-                assertEquals(TABLE_RECORD_COUNT, printer.getRecordCount());\r\n-            }\r\n-        }\r\n-        final String csv = sw.toString();\r\n-        assertEquals(\"1,r1,\\\"long text 1\\\",\\\"YmluYXJ5IGRhdGEgMQ==\\r\\n\\\"\" + recordSeparator + \"2,r2,\\\"\" + longText2 + \"\\\",\\\"YmluYXJ5IGRhdGEgMg==\\r\\n\\\"\" +\r\n-                recordSeparator, csv);\r\n-        // Round trip the data\r\n-        try (StringReader reader = new StringReader(csv);\r\n-                CSVParser csvParser = csvFormat.parse(reader)) {\r\n-            // Row 1\r\n-            CSVRecord record = csvParser.nextRecord();\r\n-            assertEquals(\"1\", record.get(0));\r\n-            assertEquals(\"r1\", record.get(1));\r\n-            assertEquals(\"long text 1\", record.get(2));\r\n-            assertEquals(\"YmluYXJ5IGRhdGEgMQ==\\r\\n\", record.get(3));\r\n-            // Row 2\r\n-            record = csvParser.nextRecord();\r\n-            assertEquals(\"2\", record.get(0));\r\n-            assertEquals(\"r2\", record.get(1));\r\n-            assertEquals(\"YmluYXJ5IGRhdGEgMg==\\r\\n\", record.get(3));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testJdbcPrinterWithFirstEmptyValue2() throws IOException, ClassNotFoundException, SQLException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (Connection connection = getH2Connection()) {\r\n-            try (Statement stmt = connection.createStatement();\r\n-                    ResultSet resultSet = stmt.executeQuery(\"select '' AS EMPTYVALUE from DUAL\");\r\n-                    CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet).print(sw)) {\r\n-                printer.printRecords(resultSet);\r\n-            }\r\n-        }\r\n-        assertEquals(\"EMPTYVALUE\" + recordSeparator + \"\\\"\\\"\" + recordSeparator, sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testJdbcPrinterWithResultSet() throws IOException, ClassNotFoundException, SQLException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (Connection connection = getH2Connection()) {\r\n-            setUpTable(connection);\r\n-            try (Statement stmt = connection.createStatement();\r\n-                    ResultSet resultSet = stmt.executeQuery(\"select ID, NAME, TEXT from TEST\");\r\n-                    CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet).print(sw)) {\r\n-                printer.printRecords(resultSet);\r\n-            }\r\n-        }\r\n-        assertEquals(\"ID,NAME,TEXT\" + recordSeparator + \"1,r1,\\\"long text 1\\\"\" + recordSeparator + \"2,r2,\\\"\" + longText2 + \"\\\"\" + recordSeparator,\r\n-                sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testJdbcPrinterWithResultSetHeader() throws IOException, ClassNotFoundException, SQLException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (Connection connection = getH2Connection()) {\r\n-            setUpTable(connection);\r\n-            try (Statement stmt = connection.createStatement();\r\n-                    CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-                try (ResultSet resultSet = stmt.executeQuery(\"select ID, NAME from TEST\")) {\r\n-                    printer.printRecords(resultSet, true);\r\n-                    assertEquals(TABLE_RECORD_COUNT, printer.getRecordCount());\r\n-                    assertEquals(\"ID,NAME\" + recordSeparator + \"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator, sw.toString());\r\n-                }\r\n-                try (ResultSet resultSet = stmt.executeQuery(\"select ID, NAME from TEST\")) {\r\n-                    printer.printRecords(resultSet, false);\r\n-                    assertEquals(TABLE_RECORD_COUNT * 2, printer.getRecordCount());\r\n-                    assertNotEquals(\"ID,NAME\" + recordSeparator + \"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator, sw.toString());\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testJdbcPrinterWithResultSetMetaData() throws IOException, ClassNotFoundException, SQLException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (Connection connection = getH2Connection()) {\r\n-            setUpTable(connection);\r\n-            try (Statement stmt = connection.createStatement();\r\n-                    ResultSet resultSet = stmt.executeQuery(\"select ID, NAME, TEXT from TEST\");\r\n-                    CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet.getMetaData()).print(sw)) {\r\n-                // The header is the first record.\r\n-                assertEquals(1, printer.getRecordCount());\r\n-                printer.printRecords(resultSet);\r\n-                assertEquals(3, printer.getRecordCount());\r\n-                assertEquals(\"ID,NAME,TEXT\" + recordSeparator + \"1,r1,\\\"long text 1\\\"\" + recordSeparator + \"2,r2,\\\"\" + longText2 + \"\\\"\" + recordSeparator,\r\n-                        sw.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testJira135_part1() throws IOException {\r\n-        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\r\n-        final StringWriter sw = new StringWriter();\r\n-        final List<String> list = new LinkedList<>();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n-            list.add(\"\\\"\");\r\n-            printer.printRecord(list);\r\n-        }\r\n-        final String expected = \"\\\"\\\\\\\"\\\"\" + format.getRecordSeparator();\r\n-        assertEquals(expected, sw.toString());\r\n-        final String[] record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(list.toArray(), format), record0);\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testJira135_part2() throws IOException {\r\n-        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\r\n-        final StringWriter sw = new StringWriter();\r\n-        final List<String> list = new LinkedList<>();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n-            list.add(\"\\n\");\r\n-            printer.printRecord(list);\r\n-        }\r\n-        final String expected = \"\\\"\\\\n\\\"\" + format.getRecordSeparator();\r\n-        assertEquals(expected, sw.toString());\r\n-        final String[] record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(list.toArray(), format), record0);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testJira135_part3() throws IOException {\r\n-        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\r\n-        final StringWriter sw = new StringWriter();\r\n-        final List<String> list = new LinkedList<>();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n-            list.add(\"\\\\\");\r\n-            printer.printRecord(list);\r\n-        }\r\n-        final String expected = \"\\\"\\\\\\\\\\\"\" + format.getRecordSeparator();\r\n-        assertEquals(expected, sw.toString());\r\n-        final String[] record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(list.toArray(), format), record0);\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testJira135All() throws IOException {\r\n-        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\r\n-        final StringWriter sw = new StringWriter();\r\n-        final List<String> list = new LinkedList<>();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n-            list.add(\"\\\"\");\r\n-            list.add(\"\\n\");\r\n-            list.add(\"\\\\\");\r\n-            printer.printRecord(list);\r\n-        }\r\n-        final String expected = \"\\\"\\\\\\\"\\\",\\\"\\\\n\\\",\\\"\\\\\\\"\" + format.getRecordSeparator();\r\n-        assertEquals(expected, sw.toString());\r\n-        final String[] record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(list.toArray(), format), record0);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMongoDbCsvBasic() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\r\n-            printer.printRecord(\"a\", \"b\");\r\n-            assertEquals(\"a,b\" + recordSeparator, sw.toString());\r\n-            assertEquals(1, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMongoDbCsvCommaInValue() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\r\n-            printer.printRecord(\"a,b\", \"c\");\r\n-            assertEquals(\"\\\"a,b\\\",c\" + recordSeparator, sw.toString());\r\n-            assertEquals(1, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMongoDbCsvDoubleQuoteInValue() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\r\n-            printer.printRecord(\"a \\\"c\\\" b\", \"d\");\r\n-            assertEquals(\"\\\"a \\\"\\\"c\\\"\\\" b\\\",d\" + recordSeparator, sw.toString());\r\n-            assertEquals(1, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMongoDbCsvTabInValue() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\r\n-            printer.printRecord(\"a\\tb\", \"c\");\r\n-            assertEquals(\"a\\tb,c\" + recordSeparator, sw.toString());\r\n-            assertEquals(1, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMongoDbTsvBasic() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_TSV)) {\r\n-            printer.printRecord(\"a\", \"b\");\r\n-            assertEquals(\"a\\tb\" + recordSeparator, sw.toString());\r\n-            assertEquals(1, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMongoDbTsvCommaInValue() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_TSV)) {\r\n-            printer.printRecord(\"a,b\", \"c\");\r\n-            assertEquals(\"a,b\\tc\" + recordSeparator, sw.toString());\r\n-            assertEquals(1, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMongoDbTsvTabInValue() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_TSV)) {\r\n-            printer.printRecord(\"a\\tb\", \"c\");\r\n-            assertEquals(\"\\\"a\\tb\\\"\\tc\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMultiLineComment() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'))) {\r\n-            printer.printComment(\"This is a comment\\non multiple lines\");\r\n-            assertEquals(\"# This is a comment\" + recordSeparator + \"# on multiple lines\" + recordSeparator, sw.toString());\r\n-            assertEquals(0, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMySqlNullOutput() throws IOException {\r\n-        Object[] s = new String[] { \"NULL\", null };\r\n-        CSVFormat format = CSVFormat.MYSQL.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.NON_NUMERIC);\r\n-        StringWriter writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        String expected = \"\\\"NULL\\\"\\tNULL\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        String[] record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(s, record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", null };\r\n-        format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\t\\\\N\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", \"A\" };\r\n-        format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\tA\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\n\", \"A\" };\r\n-        format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\n\\tA\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\", null };\r\n-        format = CSVFormat.MYSQL.withNullString(\"NULL\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\tNULL\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\", null };\r\n-        format = CSVFormat.MYSQL;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\t\\\\N\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\r\n-        format = CSVFormat.MYSQL;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"NULL\", \"\\\\\\r\" };\r\n-        format = CSVFormat.MYSQL;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\\\r\" };\r\n-        format = CSVFormat.MYSQL;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMySqlNullStringDefault() {\r\n-        assertEquals(\"\\\\N\", CSVFormat.MYSQL.getNullString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNewCsvPrinterAppendableNullFormat() {\r\n-        assertThrows(NullPointerException.class, () -> new CSVPrinter(new StringWriter(), null));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNewCsvPrinterNullAppendableFormat() {\r\n-        assertThrows(NullPointerException.class, () -> new CSVPrinter(null, CSVFormat.DEFAULT));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNotFlushable() throws IOException {\r\n-        final Appendable out = new StringBuilder();\r\n-        try (CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT)) {\r\n-            printer.printRecord(\"a\", \"b\", \"c\");\r\n-            assertEquals(\"a,b,c\" + recordSeparator, out.toString());\r\n-            printer.flush();\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseCustomNullValues() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        final CSVFormat format = CSVFormat.DEFAULT.withNullString(\"NULL\");\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n-            printer.printRecord(\"a\", null, \"b\");\r\n-        }\r\n-        final String csvString = sw.toString();\r\n-        assertEquals(\"a,NULL,b\" + recordSeparator, csvString);\r\n-        try (CSVParser iterable = format.parse(new StringReader(csvString))) {\r\n-            final Iterator<CSVRecord> iterator = iterable.iterator();\r\n-            final CSVRecord record = iterator.next();\r\n-            assertEquals(\"a\", record.get(0));\r\n-            assertNull(record.get(1));\r\n-            assertEquals(\"b\", record.get(2));\r\n-            assertFalse(iterator.hasNext());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPlainEscaped() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'))) {\r\n-            printer.print(\"abc\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"abc,xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPlainPlain() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\r\n-            printer.print(\"abc\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"abc,xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPlainQuoted() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\r\n-            printer.print(\"abc\");\r\n-            assertEquals(\"abc\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testPostgreSqlCsvNullOutput() throws IOException {\r\n-        Object[] s = new String[] { \"NULL\", null };\r\n-        CSVFormat format = CSVFormat.POSTGRESQL_CSV.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.ALL_NON_NULL);\r\n-        StringWriter writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        String expected = \"\\\"NULL\\\",NULL\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        String[] record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(new Object[2], record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", null };\r\n-        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\t\\\\N\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", \"A\" };\r\n-        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\tA\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\n\", \"A\" };\r\n-        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\n\\tA\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\", null };\r\n-        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"NULL\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\tNULL\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\", null };\r\n-        format = CSVFormat.POSTGRESQL_CSV;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\t\\\\N\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\r\n-        format = CSVFormat.POSTGRESQL_CSV;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"NULL\", \"\\\\\\r\" };\r\n-        format = CSVFormat.POSTGRESQL_CSV;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\\\r\" };\r\n-        format = CSVFormat.POSTGRESQL_CSV;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testPostgreSqlCsvTextOutput() throws IOException {\r\n-        Object[] s = new String[] { \"NULL\", null };\r\n-        CSVFormat format = CSVFormat.POSTGRESQL_TEXT.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.ALL_NON_NULL);\r\n-        StringWriter writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        String expected = \"\\\"NULL\\\"\\tNULL\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        String[] record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(new Object[2], record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", null };\r\n-        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\t\\\\N\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", \"A\" };\r\n-        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\tA\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\n\", \"A\" };\r\n-        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\n\\tA\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\", null };\r\n-        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"NULL\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\tNULL\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\", null };\r\n-        format = CSVFormat.POSTGRESQL_TEXT;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\t\\\\N\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\r\n-        format = CSVFormat.POSTGRESQL_TEXT;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"NULL\", \"\\\\\\r\" };\r\n-        format = CSVFormat.POSTGRESQL_TEXT;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\\\r\" };\r\n-        format = CSVFormat.POSTGRESQL_TEXT;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPostgreSqlNullStringDefaultCsv() {\r\n-        assertEquals(\"\", CSVFormat.POSTGRESQL_CSV.getNullString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPostgreSqlNullStringDefaultText() {\r\n-        assertEquals(\"\\\\N\", CSVFormat.POSTGRESQL_TEXT.getNullString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrint() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = CSVFormat.DEFAULT.print(sw)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", \"b\\\\c\");\r\n-            assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintCSVParser() throws IOException {\r\n-        // @formatter:off\r\n-        final String code = \"a1,b1\\n\" + // 1)\r\n-                \"a2,b2\\n\" + // 2)\r\n-                \"a3,b3\\n\" + // 3)\r\n-                \"a4,b4\\n\";  // 4)\r\n-        // @formatter:on\r\n-        final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\r\n-        final CSVFormat format = CSVFormat.DEFAULT;\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = format.print(sw);\r\n-                CSVParser parser = CSVParser.parse(code, format)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertFalse(records.isEmpty());\r\n-            Utils.compare(\"Fail\", res, records);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintCSVRecord() throws IOException {\r\n-        // @formatter:off\r\n-        final String code = \"a1,b1\\n\" + // 1)\r\n-                \"a2,b2\\n\" +  // 2)\r\n-                \"a3,b3\\n\" +  // 3)\r\n-                \"a4,b4\\n\";   // 4)\r\n-        // @formatter:on\r\n-        final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\r\n-        final CSVFormat format = CSVFormat.DEFAULT;\r\n-        final StringWriter sw = new StringWriter();\r\n-        int row = 0;\r\n-        try (CSVPrinter printer = format.print(sw);\r\n-                CSVParser parser = CSVParser.parse(code, format)) {\r\n-            assertInitialState(printer);\r\n-            for (final CSVRecord record : parser) {\r\n-                printer.printRecord(record);\r\n-                assertEquals(++row, printer.getRecordCount());\r\n-            }\r\n-            assertEquals(row, printer.getRecordCount());\r\n-        }\r\n-        try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertFalse(records.isEmpty());\r\n-            Utils.compare(\"Fail\", res, records);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintCSVRecords() throws IOException {\r\n-        // @formatter:off\r\n-        final String code = \"a1,b1\\n\" + // 1)\r\n-                \"a2,b2\\n\" + // 2)\r\n-                \"a3,b3\\n\" + // 3)\r\n-                \"a4,b4\\n\";  // 4)\r\n-        // @formatter:on\r\n-        final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\r\n-        final CSVFormat format = CSVFormat.DEFAULT;\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = format.print(sw);\r\n-                CSVParser parser = CSVParser.parse(code, format)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords(parser.getRecords());\r\n-        }\r\n-        try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertFalse(records.isEmpty());\r\n-            Utils.compare(\"Fail\", res, records);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintCustomNullValues() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withNullString(\"NULL\"))) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", null, \"b\");\r\n-            assertEquals(\"a,NULL,b\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrinter1() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", \"b\");\r\n-            assertEquals(1, printer.getRecordCount());\r\n-            assertEquals(\"a,b\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrinter2() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a,b\", \"b\");\r\n-            assertEquals(\"\\\"a,b\\\",b\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrinter3() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a, b\", \"b \");\r\n-            assertEquals(\"\\\"a, b\\\",\\\"b \\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrinter4() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", \"b\\\"c\");\r\n-            assertEquals(\"a,\\\"b\\\"\\\"c\\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrinter5() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", \"b\\nc\");\r\n-            assertEquals(\"a,\\\"b\\nc\\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrinter6() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", \"b\\r\\nc\");\r\n-            assertEquals(\"a,\\\"b\\r\\nc\\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrinter7() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", \"b\\\\c\");\r\n-            assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintNullValues() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", null, \"b\");\r\n-            assertEquals(\"a,,b\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintOnePositiveInteger() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.MINIMAL))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(Integer.MAX_VALUE);\r\n-            assertEquals(String.valueOf(Integer.MAX_VALUE), sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Test to target the use of {@link IOUtils#copy(java.io.Reader, Appendable)} which directly buffers the value from the Reader to the Appendable.\r\n-     *\r\n-     * <p>\r\n-     * Requires the format to have no quote or escape character, value to be a {@link Reader Reader} and the output <em>MUST NOT</em> be a {@link Writer Writer}\r\n-     * but some other Appendable.\r\n-     * </p>\r\n-     *\r\n-     * @throws IOException Not expected to happen\r\n-     */\r\n-    @Test\r\n-    public void testPrintReaderWithoutQuoteToAppendable() throws IOException {\r\n-        final StringBuilder sb = new StringBuilder();\r\n-        final String content = \"testValue\";\r\n-        try (CSVPrinter printer = new CSVPrinter(sb, CSVFormat.DEFAULT.withQuote(null))) {\r\n-            assertInitialState(printer);\r\n-            final StringReader value = new StringReader(content);\r\n-            printer.print(value);\r\n-        }\r\n-        assertEquals(content, sb.toString());\r\n-    }\r\n-\r\n-    /**\r\n-     * Test to target the use of {@link IOUtils#copyLarge(java.io.Reader, Writer)} which directly buffers the value from the Reader to the Writer.\r\n-     *\r\n-     * <p>\r\n-     * Requires the format to have no quote or escape character, value to be a {@link Reader Reader} and the output <em>MUST</em> be a {@link Writer Writer}.\r\n-     * </p>\r\n-     *\r\n-     * @throws IOException Not expected to happen\r\n-     */\r\n-    @Test\r\n-    public void testPrintReaderWithoutQuoteToWriter() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        final String content = \"testValue\";\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\r\n-            final StringReader value = new StringReader(content);\r\n-            printer.print(value);\r\n-        }\r\n-        assertEquals(content, sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintRecordStream() throws IOException {\r\n-        // @formatter:off\r\n-        final String code = \"a1,b1\\n\" + // 1)\r\n-                \"a2,b2\\n\" + // 2)\r\n-                \"a3,b3\\n\" + // 3)\r\n-                \"a4,b4\\n\";  // 4)\r\n-        // @formatter:on\r\n-        final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\r\n-        final CSVFormat format = CSVFormat.DEFAULT;\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = format.print(sw);\r\n-                CSVParser parser = CSVParser.parse(code, format)) {\r\n-            long count = 0;\r\n-            for (final CSVRecord record : parser) {\r\n-                printer.printRecord(record.stream());\r\n-                assertEquals(++count, printer.getRecordCount());\r\n-            }\r\n-        }\r\n-        try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertFalse(records.isEmpty());\r\n-            Utils.compare(\"Fail\", res, records);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintRecordsWithCSVRecord() throws IOException {\r\n-        final String[] values = { \"A\", \"B\", \"C\" };\r\n-        final String rowData = StringUtils.join(values, ',');\r\n-        final CharArrayWriter charArrayWriter = new CharArrayWriter(0);\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(rowData));\r\n-                CSVPrinter printer = CSVFormat.INFORMIX_UNLOAD.print(charArrayWriter)) {\r\n-            long count = 0;\r\n-            for (final CSVRecord record : parser) {\r\n-                printer.printRecord(record);\r\n-                assertEquals(++count, printer.getRecordCount());\r\n-            }\r\n-        }\r\n-        assertEquals(6, charArrayWriter.size());\r\n-        assertEquals(\"A|B|C\" + CSVFormat.INFORMIX_UNLOAD.getRecordSeparator(), charArrayWriter.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintRecordsWithEmptyVector() throws IOException {\r\n-        final PrintStream out = System.out;\r\n-        try {\r\n-            System.setOut(new PrintStream(NullOutputStream.INSTANCE));\r\n-            try (CSVPrinter printer = CSVFormat.POSTGRESQL_TEXT.printer()) {\r\n-                final Vector<CSVFormatTest.EmptyEnum> vector = new Vector<>();\r\n-                final int expectedCapacity = 23;\r\n-                vector.setSize(expectedCapacity);\r\n-                printer.printRecords(vector);\r\n-                assertEquals(expectedCapacity, vector.capacity());\r\n-                assertEquals(expectedCapacity, printer.getRecordCount());\r\n-            }\r\n-        } finally {\r\n-            System.setOut(out);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintRecordsWithObjectArray() throws IOException {\r\n-        final CharArrayWriter charArrayWriter = new CharArrayWriter(0);\r\n-        final Object[] objectArray = new Object[6];\r\n-        try (CSVPrinter printer = CSVFormat.INFORMIX_UNLOAD.print(charArrayWriter)) {\r\n-            final HashSet<BatchUpdateException> hashSet = new HashSet<>();\r\n-            objectArray[3] = hashSet;\r\n-            printer.printRecords(objectArray);\r\n-            assertEquals(objectArray.length, printer.getRecordCount());\r\n-        }\r\n-        assertEquals(6, charArrayWriter.size());\r\n-        assertEquals(\"\\n\\n\\n\\n\\n\\n\", charArrayWriter.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintRecordsWithResultSetOneRow() throws IOException, SQLException {\r\n-        try (CSVPrinter printer = CSVFormat.MYSQL.printer()) {\r\n-            try (ResultSet resultSet = new SimpleResultSet()) {\r\n-                assertInitialState(printer);\r\n-                printer.printRecords(resultSet);\r\n-                assertInitialState(printer);\r\n-                assertEquals(0, resultSet.getRow());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintToFileWithCharsetUtf16Be() throws IOException {\r\n-        final File file = createTempFile();\r\n-        try (CSVPrinter printer = CSVFormat.DEFAULT.print(file, StandardCharsets.UTF_16BE)) {\r\n-            printer.printRecord(\"a\", \"b\\\\c\");\r\n-        }\r\n-        assertEquals(\"a,b\\\\c\" + recordSeparator, FileUtils.readFileToString(file, StandardCharsets.UTF_16BE));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintToFileWithDefaultCharset() throws IOException {\r\n-        final File file = createTempFile();\r\n-        try (CSVPrinter printer = CSVFormat.DEFAULT.print(file, Charset.defaultCharset())) {\r\n-            printer.printRecord(\"a\", \"b\\\\c\");\r\n-        }\r\n-        assertEquals(\"a,b\\\\c\" + recordSeparator, FileUtils.readFileToString(file, Charset.defaultCharset()));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintToPathWithDefaultCharset() throws IOException {\r\n-        final Path file = createTempPath();\r\n-        try (CSVPrinter printer = CSVFormat.DEFAULT.print(file, Charset.defaultCharset())) {\r\n-            printer.printRecord(\"a\", \"b\\\\c\");\r\n-        }\r\n-        assertEquals(\"a,b\\\\c\" + recordSeparator, new String(Files.readAllBytes(file), Charset.defaultCharset()));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testQuoteAll() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.ALL))) {\r\n-            printer.printRecord(\"a\", \"b\\nc\", \"d\");\r\n-            assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",\\\"d\\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testQuoteCommaFirstChar() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) {\r\n-            printer.printRecord(\",\");\r\n-            assertEquals(\"\\\",\\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testQuoteNonNumeric() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.NON_NUMERIC))) {\r\n-            printer.printRecord(\"a\", \"b\\nc\", Integer.valueOf(1));\r\n-            assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",1\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRandomDefault() throws Exception {\r\n-        doRandom(CSVFormat.DEFAULT, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRandomExcel() throws Exception {\r\n-        doRandom(CSVFormat.EXCEL, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testRandomMongoDbCsv() throws Exception {\r\n-        doRandom(CSVFormat.MONGODB_CSV, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRandomMySql() throws Exception {\r\n-        doRandom(CSVFormat.MYSQL, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testRandomOracle() throws Exception {\r\n-        doRandom(CSVFormat.ORACLE, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testRandomPostgreSqlCsv() throws Exception {\r\n-        doRandom(CSVFormat.POSTGRESQL_CSV, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRandomPostgreSqlText() throws Exception {\r\n-        doRandom(CSVFormat.POSTGRESQL_TEXT, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRandomRfc4180() throws Exception {\r\n-        doRandom(CSVFormat.RFC4180, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRandomTdf() throws Exception {\r\n-        doRandom(CSVFormat.TDF, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testSingleLineComment() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'))) {\r\n-            printer.printComment(\"This is a comment\");\r\n-            assertEquals(\"# This is a comment\" + recordSeparator, sw.toString());\r\n-            assertEquals(0, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testSingleQuoteQuoted() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\r\n-            printer.print(\"a'b'c\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"'a''b''c',xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testSkipHeaderRecordFalse() throws IOException {\r\n-        // functionally identical to testHeader, used to test CSV-153\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(false))) {\r\n-            printer.printRecord(\"a\", \"b\", \"c\");\r\n-            printer.printRecord(\"x\", \"y\", \"z\");\r\n-            assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testSkipHeaderRecordTrue() throws IOException {\r\n-        // functionally identical to testHeaderNotSet, used to test CSV-153\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(true))) {\r\n-            printer.printRecord(\"a\", \"b\", \"c\");\r\n-            printer.printRecord(\"x\", \"y\", \"z\");\r\n-            assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testTrailingDelimiterOnTwoColumns() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrailingDelimiter())) {\r\n-            printer.printRecord(\"A\", \"B\");\r\n-            assertEquals(\"A,B,\\r\\n\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testTrimOffOneColumn() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim(false))) {\r\n-            printer.print(\" A \");\r\n-            assertEquals(\"\\\" A \\\"\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testTrimOnOneColumn() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim())) {\r\n-            printer.print(\" A \");\r\n-            assertEquals(\"A\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testTrimOnTwoColumns() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim())) {\r\n-            printer.print(\" A \");\r\n-            printer.print(\" B \");\r\n-            assertEquals(\"A,B\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    private String[] toFirstRecordValues(final String expected, final CSVFormat format) throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(expected, format)) {\r\n-            return parser.getRecords().get(0).values();\r\n-        }\r\n-    }\r\n-\r\n-    private void tryFormat(final List<String> list, final Character quote, final Character escape, final String expected) throws IOException {\r\n-        final CSVFormat format = CSVFormat.DEFAULT.withQuote(quote).withEscape(escape).withRecordSeparator(null);\r\n-        final Appendable out = new StringBuilder();\r\n-        try (CSVPrinter printer = new CSVPrinter(out, format)) {\r\n-            printer.printRecord(list);\r\n-        }\r\n-        assertEquals(expected, out.toString());\r\n-    }\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import static org.apache.commons.csv.Constants.BACKSLASH;\n+import static org.apache.commons.csv.Constants.CR;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import java.io.CharArrayWriter;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.sql.BatchUpdateException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Vector;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.h2.tools.SimpleResultSet;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * Tests {@link CSVPrinter}.\n+ */\n+public class CSVPrinterTest {\n+\n+    private static final int TABLE_RECORD_COUNT = 2;\n+    private static final char DQUOTE_CHAR = '\"';\n+    private static final char EURO_CH = '\\u20AC';\n+    private static final int ITERATIONS_FOR_RANDOM_TEST = 50000;\n+    private static final char QUOTE_CH = '\\'';\n+\n+    private static String printable(final String s) {\n+        final StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < s.length(); i++) {\n+            final char ch = s.charAt(i);\n+            if (ch <= ' ' || ch >= 128) {\n+                sb.append(\"(\").append((int) ch).append(\")\");\n+            } else {\n+                sb.append(ch);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    private String longText2;\n+\n+    private final String recordSeparator = CSVFormat.DEFAULT.getRecordSeparator();\n+\n+    private void assertInitialState(final CSVPrinter printer) {\n+        assertEquals(0, printer.getRecordCount());\n+    }\n+\n+    private File createTempFile() throws IOException {\n+        return createTempPath().toFile();\n+    }\n+\n+    private Path createTempPath() throws IOException {\n+        return Files.createTempFile(getClass().getName(), \".csv\");\n+    }\n+\n+    private void doOneRandom(final CSVFormat format) throws Exception {\n+        final Random r = new Random();\n+\n+        final int nLines = r.nextInt(4) + 1;\n+        final int nCol = r.nextInt(3) + 1;\n+        // nLines=1;nCol=2;\n+        final String[][] lines = generateLines(nLines, nCol);\n+\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\n+\n+            for (int i = 0; i < nLines; i++) {\n+                // for (int j=0; j<lines[i].length; j++) System.out.println(\"### VALUE=:\" + printable(lines[i][j]));\n+                printer.printRecord((Object[]) lines[i]);\n+            }\n+\n+            printer.flush();\n+        }\n+        final String result = sw.toString();\n+        // System.out.println(\"### :\" + printable(result));\n+\n+        try (CSVParser parser = CSVParser.parse(result, format)) {\n+            final List<CSVRecord> parseResult = parser.getRecords();\n+\n+            final String[][] expected = lines.clone();\n+            for (int i = 0; i < expected.length; i++) {\n+                expected[i] = expectNulls(expected[i], format);\n+            }\n+            Utils.compare(\"Printer output :\" + printable(result), expected, parseResult);\n+        }\n+    }\n+\n+    private void doRandom(final CSVFormat format, final int iter) throws Exception {\n+        for (int i = 0; i < iter; i++) {\n+            doOneRandom(format);\n+        }\n+    }\n+\n+    /**\n+     * Converts an input CSV array into expected output values WRT NULLs. NULL strings are converted to null values because the parser will convert these\n+     * strings to null.\n+     */\n+    private <T> T[] expectNulls(final T[] original, final CSVFormat csvFormat) {\n+        final T[] fixed = original.clone();\n+        for (int i = 0; i < fixed.length; i++) {\n+            if (Objects.equals(csvFormat.getNullString(), fixed[i])) {\n+                fixed[i] = null;\n+            }\n+        }\n+        return fixed;\n+    }\n+\n+    private String[][] generateLines(final int nLines, final int nCol) {\n+        final String[][] lines = new String[nLines][];\n+        for (int i = 0; i < nLines; i++) {\n+            final String[] line = new String[nCol];\n+            lines[i] = line;\n+            for (int j = 0; j < nCol; j++) {\n+                line[j] = randStr();\n+            }\n+        }\n+        return lines;\n+    }\n+\n+    private Connection getH2Connection() throws SQLException, ClassNotFoundException {\n+        Class.forName(\"org.h2.Driver\");\n+        return DriverManager.getConnection(\"jdbc:h2:mem:my_test;\", \"sa\", \"\");\n+    }\n+\n+    private CSVPrinter printWithHeaderComments(final StringWriter sw, final Date now, final CSVFormat baseFormat) throws IOException {\n+        // Use withHeaderComments first to test CSV-145\n+        // @formatter:off\n+        final CSVFormat format = baseFormat.builder()\n+                .setHeaderComments((String[]) null) // don't blow up\n+                .setHeaderComments((Object[]) null) // don't blow up\n+                .setHeaderComments(\"Generated by Apache Commons CSV 1.1\", now)\n+                .setCommentMarker('#')\n+                .setHeader(\"Col1\", \"Col2\")\n+                .get();\n+        // @formatter:on\n+        final CSVPrinter printer = format.print(sw);\n+        printer.printRecord(\"A\", \"B\");\n+        printer.printRecord(\"C\", \"D\");\n+        printer.close();\n+        return printer;\n+    }\n+\n+    private String randStr() {\n+        final Random r = new Random();\n+        final int sz = r.nextInt(20);\n+        // sz = r.nextInt(3);\n+        final char[] buf = new char[sz];\n+        for (int i = 0; i < sz; i++) {\n+            // stick in special chars with greater frequency\n+            final char ch;\n+            final int what = r.nextInt(20);\n+            switch (what) {\n+            case 0:\n+                ch = '\\r';\n+                break;\n+            case 1:\n+                ch = '\\n';\n+                break;\n+            case 2:\n+                ch = '\\t';\n+                break;\n+            case 3:\n+                ch = '\\f';\n+                break;\n+            case 4:\n+                ch = ' ';\n+                break;\n+            case 5:\n+                ch = ',';\n+                break;\n+            case 6:\n+                ch = DQUOTE_CHAR;\n+                break;\n+            case 7:\n+                ch = '\\'';\n+                break;\n+            case 8:\n+                ch = BACKSLASH;\n+                break;\n+            default:\n+                ch = (char) r.nextInt(300);\n+                break;\n+            // default: ch = 'a'; break;\n+            }\n+            buf[i] = ch;\n+        }\n+        return new String(buf);\n+    }\n+\n+    private void setUpTable(final Connection connection) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            statement.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255), TEXT CLOB, BIN_DATA BLOB)\");\n+            statement.execute(\"insert into TEST values(1, 'r1', 'long text 1', 'binary data 1')\");\n+            longText2 = StringUtils.repeat('a', IOUtils.DEFAULT_BUFFER_SIZE - 4);\n+            longText2 += \"\\\"\\r\\n\\\"b\\\"\";\n+            longText2 += StringUtils.repeat('c', IOUtils.DEFAULT_BUFFER_SIZE - 1);\n+            statement.execute(\"insert into TEST values(2, 'r2', '\" + longText2 + \"', 'binary data 2')\");\n+            longText2 = longText2.replace(\"\\\"\", \"\\\"\\\"\");\n+        }\n+    }\n+\n+    @Test\n+    public void testCloseBackwardCompatibility() throws IOException {\n+        try (Writer writer = mock(Writer.class)) {\n+            final CSVFormat csvFormat = CSVFormat.DEFAULT;\n+            try (CSVPrinter printer = new CSVPrinter(writer, csvFormat)) {\n+                assertInitialState(printer);\n+            }\n+            verify(writer, never()).flush();\n+            verify(writer, times(1)).close();\n+        }\n+    }\n+\n+    @Test\n+    public void testCloseWithCsvFormatAutoFlushOff() throws IOException {\n+        try (Writer writer = mock(Writer.class)) {\n+            final CSVFormat csvFormat = CSVFormat.DEFAULT.withAutoFlush(false);\n+            try (CSVPrinter printer = new CSVPrinter(writer, csvFormat)) {\n+                assertInitialState(printer);\n+            }\n+            verify(writer, never()).flush();\n+            verify(writer, times(1)).close();\n+        }\n+    }\n+\n+    @Test\n+    public void testCloseWithCsvFormatAutoFlushOn() throws IOException {\n+        // System.out.println(\"start method\");\n+        try (Writer writer = mock(Writer.class)) {\n+            final CSVFormat csvFormat = CSVFormat.DEFAULT.withAutoFlush(true);\n+            try (CSVPrinter printer = new CSVPrinter(writer, csvFormat)) {\n+                assertInitialState(printer);\n+            }\n+            verify(writer, times(1)).flush();\n+            verify(writer, times(1)).close();\n+        }\n+    }\n+\n+    @Test\n+    public void testCloseWithFlushOff() throws IOException {\n+        try (Writer writer = mock(Writer.class)) {\n+            final CSVFormat csvFormat = CSVFormat.DEFAULT;\n+            @SuppressWarnings(\"resource\")\n+            final CSVPrinter printer = new CSVPrinter(writer, csvFormat);\n+            assertInitialState(printer);\n+            printer.close(false);\n+            assertEquals(0, printer.getRecordCount());\n+            verify(writer, never()).flush();\n+            verify(writer, times(1)).close();\n+        }\n+    }\n+\n+    @Test\n+    public void testCloseWithFlushOn() throws IOException {\n+        try (Writer writer = mock(Writer.class)) {\n+            @SuppressWarnings(\"resource\")\n+            final CSVPrinter printer = new CSVPrinter(writer, CSVFormat.DEFAULT);\n+            assertInitialState(printer);\n+            printer.close(true);\n+            assertEquals(0, printer.getRecordCount());\n+            verify(writer, times(1)).flush();\n+        }\n+    }\n+\n+    @Test\n+    public void testCRComment() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final Object value = \"abc\";\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'))) {\n+            assertInitialState(printer);\n+            printer.print(value);\n+            assertEquals(0, printer.getRecordCount());\n+            printer.printComment(\"This is a comment\\r\\non multiple lines\\rthis is next comment\\r\");\n+            assertEquals(\"abc\" + recordSeparator + \"# This is a comment\" + recordSeparator + \"# on multiple lines\" + recordSeparator +\n+                    \"# this is next comment\" + recordSeparator + \"# \" + recordSeparator, sw.toString());\n+            assertEquals(0, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testCSV135() throws IOException {\n+        final List<String> list = new LinkedList<>();\n+        list.add(\"\\\"\\\"\"); // \"\"\n+        list.add(\"\\\\\\\\\"); // \\\\\n+        list.add(\"\\\\\\\"\\\\\"); // \\\"\\\n+        //\n+        // \"\",\\\\,\\\"\\ (unchanged)\n+        tryFormat(list, null, null, \"\\\"\\\",\\\\\\\\,\\\\\\\"\\\\\");\n+        //\n+        // \"\"\"\"\"\",\\\\,\"\\\"\"\\\" (quoted, and embedded DQ doubled)\n+        tryFormat(list, '\"', null, \"\\\"\\\"\\\"\\\"\\\"\\\",\\\\\\\\,\\\"\\\\\\\"\\\"\\\\\\\"\");\n+        //\n+        // \"\",\\\\\\\\,\\\\\"\\\\ (escapes escaped, not quoted)\n+        tryFormat(list, null, '\\\\', \"\\\"\\\",\\\\\\\\\\\\\\\\,\\\\\\\\\\\"\\\\\\\\\");\n+        //\n+        // \"\\\"\\\"\",\"\\\\\\\\\",\"\\\\\\\"\\\\\" (quoted, and embedded DQ & escape escaped)\n+        tryFormat(list, '\"', '\\\\', \"\\\"\\\\\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\\\\\\\\\",\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\"\");\n+        //\n+        // \"\"\"\"\"\",\\\\,\"\\\"\"\\\" (quoted, embedded DQ escaped)\n+        tryFormat(list, '\"', '\"', \"\\\"\\\"\\\"\\\"\\\"\\\",\\\\\\\\,\\\"\\\\\\\"\\\"\\\\\\\"\");\n+    }\n+\n+    @Test\n+    public void testCSV259() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (Reader reader = new FileReader(\"src/test/resources/org/apache/commons/csv/CSV-259/sample.txt\");\n+                CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null))) {\n+            assertInitialState(printer);\n+            printer.print(reader);\n+            assertEquals(\"x!,y!,z\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDelimeterQuoted() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\n+            assertInitialState(printer);\n+            printer.print(\"a,b,c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"'a,b,c',xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDelimeterQuoteNone() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVFormat format = CSVFormat.DEFAULT.withEscape('!').withQuoteMode(QuoteMode.NONE);\n+        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            assertInitialState(printer);\n+            printer.print(\"a,b,c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"a!,b!,c,xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDelimeterStringQuoted() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setQuote('\\'').get())) {\n+            assertInitialState(printer);\n+            printer.print(\"a[|]b[|]c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"'a[|]b[|]c'[|]xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDelimeterStringQuoteNone() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVFormat format = CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setEscape('!').setQuoteMode(QuoteMode.NONE).get();\n+        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            assertInitialState(printer);\n+            printer.print(\"a[|]b[|]c\");\n+            printer.print(\"xyz\");\n+            printer.print(\"a[xy]bc[]\");\n+            assertEquals(\"a![!|!]b![!|!]c[|]xyz[|]a[xy]bc[]\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDelimiterEscaped() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null))) {\n+            assertInitialState(printer);\n+            printer.print(\"a,b,c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"a!,b!,c,xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDelimiterPlain() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\n+            assertInitialState(printer);\n+            printer.print(\"a,b,c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"a,b,c,xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDelimiterStringEscaped() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.builder().setDelimiter(\"|||\").setEscape('!').setQuote(null).get())) {\n+            assertInitialState(printer);\n+            printer.print(\"a|||b|||c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"a!|!|!|b!|!|!|c|||xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDisabledComment() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printComment(\"This is a comment\");\n+            assertEquals(\"\", sw.toString());\n+            assertEquals(0, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testDontQuoteEuroFirstChar() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) {\n+            assertInitialState(printer);\n+            printer.printRecord(EURO_CH, \"Deux\");\n+            assertEquals(EURO_CH + \",Deux\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testEolEscaped() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'))) {\n+            assertInitialState(printer);\n+            printer.print(\"a\\rb\\nc\");\n+            printer.print(\"x\\fy\\bz\");\n+            assertEquals(\"a!rb!nc,x\\fy\\bz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testEolPlain() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\n+            assertInitialState(printer);\n+            printer.print(\"a\\rb\\nc\");\n+            printer.print(\"x\\fy\\bz\");\n+            assertEquals(\"a\\rb\\nc,x\\fy\\bz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testEolQuoted() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\n+            assertInitialState(printer);\n+            printer.print(\"a\\rb\\nc\");\n+            printer.print(\"x\\by\\fz\");\n+            assertEquals(\"'a\\rb\\nc',x\\by\\fz\", sw.toString());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unlikely-arg-type\")\n+    @Test\n+    public void testEquals() throws IOException {\n+        // Don't use assertNotEquals here\n+        assertFalse(CSVFormat.DEFAULT.equals(null));\n+        // Don't use assertNotEquals here\n+        assertFalse(CSVFormat.DEFAULT.equals(\"\"));\n+    }\n+\n+    @Test\n+    public void testEscapeBackslash1() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n+            assertInitialState(printer);\n+            printer.print(\"\\\\\");\n+        }\n+        assertEquals(\"\\\\\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeBackslash2() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n+            assertInitialState(printer);\n+            printer.print(\"\\\\\\r\");\n+        }\n+        assertEquals(\"'\\\\\\r'\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeBackslash3() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n+            assertInitialState(printer);\n+            printer.print(\"X\\\\\\r\");\n+        }\n+        assertEquals(\"'X\\\\\\r'\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeBackslash4() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n+            assertInitialState(printer);\n+            printer.print(\"\\\\\\\\\");\n+        }\n+        assertEquals(\"\\\\\\\\\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeBackslash5() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n+            assertInitialState(printer);\n+            printer.print(\"\\\\\\\\\");\n+        }\n+        assertEquals(\"\\\\\\\\\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeNull1() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n+            assertInitialState(printer);\n+            printer.print(\"\\\\\");\n+        }\n+        assertEquals(\"\\\\\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeNull2() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n+            assertInitialState(printer);\n+            printer.print(\"\\\\\\r\");\n+        }\n+        assertEquals(\"\\\"\\\\\\r\\\"\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeNull3() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n+            assertInitialState(printer);\n+            printer.print(\"X\\\\\\r\");\n+        }\n+        assertEquals(\"\\\"X\\\\\\r\\\"\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeNull4() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n+            assertInitialState(printer);\n+            printer.print(\"\\\\\\\\\");\n+        }\n+        assertEquals(\"\\\\\\\\\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeNull5() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n+            assertInitialState(printer);\n+            printer.print(\"\\\\\\\\\");\n+        }\n+        assertEquals(\"\\\\\\\\\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllArrayOfArrays() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords((Object[]) new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } });\n+            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllArrayOfArraysWithFirstEmptyValue2() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords((Object[]) new String[][] { { \"\" } });\n+            assertEquals(\"\\\"\\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllArrayOfArraysWithFirstSpaceValue1() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords((Object[]) new String[][] { { \" \", \"r1c2\" } });\n+            assertEquals(\"\\\" \\\",r1c2\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllArrayOfArraysWithFirstTabValue1() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords((Object[]) new String[][] { { \"\\t\", \"r1c2\" } });\n+            assertEquals(\"\\\"\\t\\\",r1c2\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllArrayOfLists() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords((Object[]) new List[] { Arrays.asList(\"r1c1\", \"r1c2\"), Arrays.asList(\"r2c1\", \"r2c2\") });\n+            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllArrayOfListsWithFirstEmptyValue2() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords((Object[]) new List[] { Arrays.asList(\"\") });\n+            assertEquals(\"\\\"\\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllIterableOfArrays() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords(Arrays.asList(new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } }));\n+            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllIterableOfArraysWithFirstEmptyValue2() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords(Arrays.asList(new String[][] { { \"\" } }));\n+            assertEquals(\"\\\"\\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllIterableOfLists() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords(Arrays.asList(Arrays.asList(\"r1c1\", \"r1c2\"), Arrays.asList(\"r2c1\", \"r2c2\")));\n+            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllStreamOfArrays() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords(Stream.of(new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } }));\n+            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrinter1() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", \"b\");\n+            assertEquals(\"a,b\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrinter2() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a,b\", \"b\");\n+            assertEquals(\"\\\"a,b\\\",b\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testHeader() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\"))) {\n+            assertEquals(1, printer.getRecordCount());\n+            printer.printRecord(\"a\", \"b\", \"c\");\n+            printer.printRecord(\"x\", \"y\", \"z\");\n+            assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testHeaderCommentExcel() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final Date now = new Date();\n+        final CSVFormat format = CSVFormat.EXCEL;\n+        try (CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format)) {\n+            assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1,Col2\\r\\nA,B\\r\\nC,D\\r\\n\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testHeaderCommentTdf() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final Date now = new Date();\n+        final CSVFormat format = CSVFormat.TDF;\n+        try (CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format)) {\n+            assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1\\tCol2\\r\\nA\\tB\\r\\nC\\tD\\r\\n\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testHeaderNotSet() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", \"b\", \"c\");\n+            printer.printRecord(\"x\", \"y\", \"z\");\n+            assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testInvalidFormat() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter(CR));\n+    }\n+\n+    @Test\n+    public void testJdbcPrinter() throws IOException, ClassNotFoundException, SQLException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT;\n+        try (Connection connection = getH2Connection()) {\n+            setUpTable(connection);\n+            try (Statement stmt = connection.createStatement();\n+                    CSVPrinter printer = new CSVPrinter(sw, csvFormat);\n+                    ResultSet resultSet = stmt.executeQuery(\"select ID, NAME, TEXT, BIN_DATA from TEST\")) {\n+                assertInitialState(printer);\n+                printer.printRecords(resultSet);\n+                assertEquals(TABLE_RECORD_COUNT, printer.getRecordCount());\n+            }\n+        }\n+        final String csv = sw.toString();\n+        assertEquals(\"1,r1,\\\"long text 1\\\",\\\"YmluYXJ5IGRhdGEgMQ==\\r\\n\\\"\" + recordSeparator + \"2,r2,\\\"\" + longText2 + \"\\\",\\\"YmluYXJ5IGRhdGEgMg==\\r\\n\\\"\" +\n+                recordSeparator, csv);\n+        // Round trip the data\n+        try (StringReader reader = new StringReader(csv);\n+                CSVParser csvParser = csvFormat.parse(reader)) {\n+            // Row 1\n+            CSVRecord record = csvParser.nextRecord();\n+            assertEquals(\"1\", record.get(0));\n+            assertEquals(\"r1\", record.get(1));\n+            assertEquals(\"long text 1\", record.get(2));\n+            assertEquals(\"YmluYXJ5IGRhdGEgMQ==\\r\\n\", record.get(3));\n+            // Row 2\n+            record = csvParser.nextRecord();\n+            assertEquals(\"2\", record.get(0));\n+            assertEquals(\"r2\", record.get(1));\n+            assertEquals(\"YmluYXJ5IGRhdGEgMg==\\r\\n\", record.get(3));\n+        }\n+    }\n+\n+    @Test\n+    public void testJdbcPrinterWithFirstEmptyValue2() throws IOException, ClassNotFoundException, SQLException {\n+        final StringWriter sw = new StringWriter();\n+        try (Connection connection = getH2Connection()) {\n+            try (Statement stmt = connection.createStatement();\n+                    ResultSet resultSet = stmt.executeQuery(\"select '' AS EMPTYVALUE from DUAL\");\n+                    CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet).print(sw)) {\n+                printer.printRecords(resultSet);\n+            }\n+        }\n+        assertEquals(\"EMPTYVALUE\" + recordSeparator + \"\\\"\\\"\" + recordSeparator, sw.toString());\n+    }\n+\n+    @Test\n+    public void testJdbcPrinterWithResultSet() throws IOException, ClassNotFoundException, SQLException {\n+        final StringWriter sw = new StringWriter();\n+        try (Connection connection = getH2Connection()) {\n+            setUpTable(connection);\n+            try (Statement stmt = connection.createStatement();\n+                    ResultSet resultSet = stmt.executeQuery(\"select ID, NAME, TEXT from TEST\");\n+                    CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet).print(sw)) {\n+                printer.printRecords(resultSet);\n+            }\n+        }\n+        assertEquals(\"ID,NAME,TEXT\" + recordSeparator + \"1,r1,\\\"long text 1\\\"\" + recordSeparator + \"2,r2,\\\"\" + longText2 + \"\\\"\" + recordSeparator,\n+                sw.toString());\n+    }\n+\n+    @Test\n+    public void testJdbcPrinterWithResultSetHeader() throws IOException, ClassNotFoundException, SQLException {\n+        final StringWriter sw = new StringWriter();\n+        try (Connection connection = getH2Connection()) {\n+            setUpTable(connection);\n+            try (Statement stmt = connection.createStatement();\n+                    CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+                try (ResultSet resultSet = stmt.executeQuery(\"select ID, NAME from TEST\")) {\n+                    printer.printRecords(resultSet, true);\n+                    assertEquals(TABLE_RECORD_COUNT, printer.getRecordCount());\n+                    assertEquals(\"ID,NAME\" + recordSeparator + \"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator, sw.toString());\n+                }\n+                try (ResultSet resultSet = stmt.executeQuery(\"select ID, NAME from TEST\")) {\n+                    printer.printRecords(resultSet, false);\n+                    assertEquals(TABLE_RECORD_COUNT * 2, printer.getRecordCount());\n+                    assertNotEquals(\"ID,NAME\" + recordSeparator + \"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator, sw.toString());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testJdbcPrinterWithResultSetMetaData() throws IOException, ClassNotFoundException, SQLException {\n+        final StringWriter sw = new StringWriter();\n+        try (Connection connection = getH2Connection()) {\n+            setUpTable(connection);\n+            try (Statement stmt = connection.createStatement();\n+                    ResultSet resultSet = stmt.executeQuery(\"select ID, NAME, TEXT from TEST\");\n+                    CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet.getMetaData()).print(sw)) {\n+                // The header is the first record.\n+                assertEquals(1, printer.getRecordCount());\n+                printer.printRecords(resultSet);\n+                assertEquals(3, printer.getRecordCount());\n+                assertEquals(\"ID,NAME,TEXT\" + recordSeparator + \"1,r1,\\\"long text 1\\\"\" + recordSeparator + \"2,r2,\\\"\" + longText2 + \"\\\"\" + recordSeparator,\n+                        sw.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testJira135_part1() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\n+        final StringWriter sw = new StringWriter();\n+        final List<String> list = new LinkedList<>();\n+        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            list.add(\"\\\"\");\n+            printer.printRecord(list);\n+        }\n+        final String expected = \"\\\"\\\\\\\"\\\"\" + format.getRecordSeparator();\n+        assertEquals(expected, sw.toString());\n+        final String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testJira135_part2() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\n+        final StringWriter sw = new StringWriter();\n+        final List<String> list = new LinkedList<>();\n+        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            list.add(\"\\n\");\n+            printer.printRecord(list);\n+        }\n+        final String expected = \"\\\"\\\\n\\\"\" + format.getRecordSeparator();\n+        assertEquals(expected, sw.toString());\n+        final String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n+    }\n+\n+    @Test\n+    public void testJira135_part3() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\n+        final StringWriter sw = new StringWriter();\n+        final List<String> list = new LinkedList<>();\n+        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            list.add(\"\\\\\");\n+            printer.printRecord(list);\n+        }\n+        final String expected = \"\\\"\\\\\\\\\\\"\" + format.getRecordSeparator();\n+        assertEquals(expected, sw.toString());\n+        final String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testJira135All() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\n+        final StringWriter sw = new StringWriter();\n+        final List<String> list = new LinkedList<>();\n+        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            list.add(\"\\\"\");\n+            list.add(\"\\n\");\n+            list.add(\"\\\\\");\n+            printer.printRecord(list);\n+        }\n+        final String expected = \"\\\"\\\\\\\"\\\",\\\"\\\\n\\\",\\\"\\\\\\\"\" + format.getRecordSeparator();\n+        assertEquals(expected, sw.toString());\n+        final String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n+    }\n+\n+    @Test\n+    public void testMongoDbCsvBasic() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\n+            printer.printRecord(\"a\", \"b\");\n+            assertEquals(\"a,b\" + recordSeparator, sw.toString());\n+            assertEquals(1, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testMongoDbCsvCommaInValue() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\n+            printer.printRecord(\"a,b\", \"c\");\n+            assertEquals(\"\\\"a,b\\\",c\" + recordSeparator, sw.toString());\n+            assertEquals(1, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testMongoDbCsvDoubleQuoteInValue() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\n+            printer.printRecord(\"a \\\"c\\\" b\", \"d\");\n+            assertEquals(\"\\\"a \\\"\\\"c\\\"\\\" b\\\",d\" + recordSeparator, sw.toString());\n+            assertEquals(1, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testMongoDbCsvTabInValue() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\n+            printer.printRecord(\"a\\tb\", \"c\");\n+            assertEquals(\"a\\tb,c\" + recordSeparator, sw.toString());\n+            assertEquals(1, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testMongoDbTsvBasic() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_TSV)) {\n+            printer.printRecord(\"a\", \"b\");\n+            assertEquals(\"a\\tb\" + recordSeparator, sw.toString());\n+            assertEquals(1, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testMongoDbTsvCommaInValue() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_TSV)) {\n+            printer.printRecord(\"a,b\", \"c\");\n+            assertEquals(\"a,b\\tc\" + recordSeparator, sw.toString());\n+            assertEquals(1, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testMongoDbTsvTabInValue() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_TSV)) {\n+            printer.printRecord(\"a\\tb\", \"c\");\n+            assertEquals(\"\\\"a\\tb\\\"\\tc\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testMultiLineComment() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'))) {\n+            printer.printComment(\"This is a comment\\non multiple lines\");\n+            assertEquals(\"# This is a comment\" + recordSeparator + \"# on multiple lines\" + recordSeparator, sw.toString());\n+            assertEquals(0, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testMySqlNullOutput() throws IOException {\n+        Object[] s = new String[] { \"NULL\", null };\n+        CSVFormat format = CSVFormat.MYSQL.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.NON_NUMERIC);\n+        StringWriter writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        String expected = \"\\\"NULL\\\"\\tNULL\\n\";\n+        assertEquals(expected, writer.toString());\n+        String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(s, record0);\n+\n+        s = new String[] { \"\\\\N\", null };\n+        format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\t\\\\N\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\N\", \"A\" };\n+        format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\tA\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\n\", \"A\" };\n+        format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\n\\tA\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\", null };\n+        format = CSVFormat.MYSQL.withNullString(\"NULL\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\tNULL\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\", null };\n+        format = CSVFormat.MYSQL;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\t\\\\N\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\n+        format = CSVFormat.MYSQL;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"NULL\", \"\\\\\\r\" };\n+        format = CSVFormat.MYSQL;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\\\r\" };\n+        format = CSVFormat.MYSQL;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+    }\n+\n+    @Test\n+    public void testMySqlNullStringDefault() {\n+        assertEquals(\"\\\\N\", CSVFormat.MYSQL.getNullString());\n+    }\n+\n+    @Test\n+    public void testNewCsvPrinterAppendableNullFormat() {\n+        assertThrows(NullPointerException.class, () -> new CSVPrinter(new StringWriter(), null));\n+    }\n+\n+    @Test\n+    public void testNewCsvPrinterNullAppendableFormat() {\n+        assertThrows(NullPointerException.class, () -> new CSVPrinter(null, CSVFormat.DEFAULT));\n+    }\n+\n+    @Test\n+    public void testNotFlushable() throws IOException {\n+        final Appendable out = new StringBuilder();\n+        try (CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT)) {\n+            printer.printRecord(\"a\", \"b\", \"c\");\n+            assertEquals(\"a,b,c\" + recordSeparator, out.toString());\n+            printer.flush();\n+        }\n+    }\n+\n+    @Test\n+    public void testParseCustomNullValues() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVFormat format = CSVFormat.DEFAULT.withNullString(\"NULL\");\n+        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            printer.printRecord(\"a\", null, \"b\");\n+        }\n+        final String csvString = sw.toString();\n+        assertEquals(\"a,NULL,b\" + recordSeparator, csvString);\n+        try (CSVParser iterable = format.parse(new StringReader(csvString))) {\n+            final Iterator<CSVRecord> iterator = iterable.iterator();\n+            final CSVRecord record = iterator.next();\n+            assertEquals(\"a\", record.get(0));\n+            assertNull(record.get(1));\n+            assertEquals(\"b\", record.get(2));\n+            assertFalse(iterator.hasNext());\n+        }\n+    }\n+\n+    @Test\n+    public void testPlainEscaped() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'))) {\n+            printer.print(\"abc\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"abc,xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPlainPlain() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\n+            printer.print(\"abc\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"abc,xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPlainQuoted() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\n+            printer.print(\"abc\");\n+            assertEquals(\"abc\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testPostgreSqlCsvNullOutput() throws IOException {\n+        Object[] s = new String[] { \"NULL\", null };\n+        CSVFormat format = CSVFormat.POSTGRESQL_CSV.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.ALL_NON_NULL);\n+        StringWriter writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        String expected = \"\\\"NULL\\\",NULL\\n\";\n+        assertEquals(expected, writer.toString());\n+        String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(new Object[2], record0);\n+\n+        s = new String[] { \"\\\\N\", null };\n+        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\t\\\\N\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\N\", \"A\" };\n+        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\tA\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\n\", \"A\" };\n+        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\n\\tA\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\", null };\n+        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"NULL\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\tNULL\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\", null };\n+        format = CSVFormat.POSTGRESQL_CSV;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\t\\\\N\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_CSV;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"NULL\", \"\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_CSV;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_CSV;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testPostgreSqlCsvTextOutput() throws IOException {\n+        Object[] s = new String[] { \"NULL\", null };\n+        CSVFormat format = CSVFormat.POSTGRESQL_TEXT.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.ALL_NON_NULL);\n+        StringWriter writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        String expected = \"\\\"NULL\\\"\\tNULL\\n\";\n+        assertEquals(expected, writer.toString());\n+        String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(new Object[2], record0);\n+\n+        s = new String[] { \"\\\\N\", null };\n+        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\t\\\\N\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\N\", \"A\" };\n+        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\tA\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\n\", \"A\" };\n+        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\n\\tA\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\", null };\n+        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"NULL\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\tNULL\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\", null };\n+        format = CSVFormat.POSTGRESQL_TEXT;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\t\\\\N\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_TEXT;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"NULL\", \"\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_TEXT;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_TEXT;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+    }\n+\n+    @Test\n+    public void testPostgreSqlNullStringDefaultCsv() {\n+        assertEquals(\"\", CSVFormat.POSTGRESQL_CSV.getNullString());\n+    }\n+\n+    @Test\n+    public void testPostgreSqlNullStringDefaultText() {\n+        assertEquals(\"\\\\N\", CSVFormat.POSTGRESQL_TEXT.getNullString());\n+    }\n+\n+    @Test\n+    public void testPrint() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = CSVFormat.DEFAULT.print(sw)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", \"b\\\\c\");\n+            assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintCSVParser() throws IOException {\n+        // @formatter:off\n+        final String code = \"a1,b1\\n\" + // 1)\n+                \"a2,b2\\n\" + // 2)\n+                \"a3,b3\\n\" + // 3)\n+                \"a4,b4\\n\";  // 4)\n+        // @formatter:on\n+        final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\n+        final CSVFormat format = CSVFormat.DEFAULT;\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = format.print(sw);\n+                CSVParser parser = CSVParser.parse(code, format)) {\n+            assertInitialState(printer);\n+            printer.printRecords(parser);\n+        }\n+        try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertFalse(records.isEmpty());\n+            Utils.compare(\"Fail\", res, records);\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintCSVRecord() throws IOException {\n+        // @formatter:off\n+        final String code = \"a1,b1\\n\" + // 1)\n+                \"a2,b2\\n\" +  // 2)\n+                \"a3,b3\\n\" +  // 3)\n+                \"a4,b4\\n\";   // 4)\n+        // @formatter:on\n+        final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\n+        final CSVFormat format = CSVFormat.DEFAULT;\n+        final StringWriter sw = new StringWriter();\n+        int row = 0;\n+        try (CSVPrinter printer = format.print(sw);\n+                CSVParser parser = CSVParser.parse(code, format)) {\n+            assertInitialState(printer);\n+            for (final CSVRecord record : parser) {\n+                printer.printRecord(record);\n+                assertEquals(++row, printer.getRecordCount());\n+            }\n+            assertEquals(row, printer.getRecordCount());\n+        }\n+        try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertFalse(records.isEmpty());\n+            Utils.compare(\"Fail\", res, records);\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintCSVRecords() throws IOException {\n+        // @formatter:off\n+        final String code = \"a1,b1\\n\" + // 1)\n+                \"a2,b2\\n\" + // 2)\n+                \"a3,b3\\n\" + // 3)\n+                \"a4,b4\\n\";  // 4)\n+        // @formatter:on\n+        final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\n+        final CSVFormat format = CSVFormat.DEFAULT;\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = format.print(sw);\n+                CSVParser parser = CSVParser.parse(code, format)) {\n+            assertInitialState(printer);\n+            printer.printRecords(parser.getRecords());\n+        }\n+        try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertFalse(records.isEmpty());\n+            Utils.compare(\"Fail\", res, records);\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintCustomNullValues() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withNullString(\"NULL\"))) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", null, \"b\");\n+            assertEquals(\"a,NULL,b\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrinter1() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", \"b\");\n+            assertEquals(1, printer.getRecordCount());\n+            assertEquals(\"a,b\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrinter2() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a,b\", \"b\");\n+            assertEquals(\"\\\"a,b\\\",b\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrinter3() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a, b\", \"b \");\n+            assertEquals(\"\\\"a, b\\\",\\\"b \\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrinter4() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", \"b\\\"c\");\n+            assertEquals(\"a,\\\"b\\\"\\\"c\\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrinter5() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", \"b\\nc\");\n+            assertEquals(\"a,\\\"b\\nc\\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrinter6() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", \"b\\r\\nc\");\n+            assertEquals(\"a,\\\"b\\r\\nc\\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrinter7() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", \"b\\\\c\");\n+            assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintNullValues() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", null, \"b\");\n+            assertEquals(\"a,,b\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintOnePositiveInteger() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.MINIMAL))) {\n+            assertInitialState(printer);\n+            printer.print(Integer.MAX_VALUE);\n+            assertEquals(String.valueOf(Integer.MAX_VALUE), sw.toString());\n+        }\n+    }\n+\n+    /**\n+     * Test to target the use of {@link IOUtils#copy(java.io.Reader, Appendable)} which directly buffers the value from the Reader to the Appendable.\n+     *\n+     * <p>\n+     * Requires the format to have no quote or escape character, value to be a {@link Reader Reader} and the output <em>MUST NOT</em> be a {@link Writer Writer}\n+     * but some other Appendable.\n+     * </p>\n+     *\n+     * @throws IOException Not expected to happen\n+     */\n+    @Test\n+    public void testPrintReaderWithoutQuoteToAppendable() throws IOException {\n+        final StringBuilder sb = new StringBuilder();\n+        final String content = \"testValue\";\n+        try (CSVPrinter printer = new CSVPrinter(sb, CSVFormat.DEFAULT.withQuote(null))) {\n+            assertInitialState(printer);\n+            final StringReader value = new StringReader(content);\n+            printer.print(value);\n+        }\n+        assertEquals(content, sb.toString());\n+    }\n+\n+    /**\n+     * Test to target the use of {@link IOUtils#copyLarge(java.io.Reader, Writer)} which directly buffers the value from the Reader to the Writer.\n+     *\n+     * <p>\n+     * Requires the format to have no quote or escape character, value to be a {@link Reader Reader} and the output <em>MUST</em> be a {@link Writer Writer}.\n+     * </p>\n+     *\n+     * @throws IOException Not expected to happen\n+     */\n+    @Test\n+    public void testPrintReaderWithoutQuoteToWriter() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final String content = \"testValue\";\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\n+            final StringReader value = new StringReader(content);\n+            printer.print(value);\n+        }\n+        assertEquals(content, sw.toString());\n+    }\n+\n+    @Test\n+    public void testPrintRecordStream() throws IOException {\n+        // @formatter:off\n+        final String code = \"a1,b1\\n\" + // 1)\n+                \"a2,b2\\n\" + // 2)\n+                \"a3,b3\\n\" + // 3)\n+                \"a4,b4\\n\";  // 4)\n+        // @formatter:on\n+        final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\n+        final CSVFormat format = CSVFormat.DEFAULT;\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = format.print(sw);\n+                CSVParser parser = CSVParser.parse(code, format)) {\n+            long count = 0;\n+            for (final CSVRecord record : parser) {\n+                printer.printRecord(record.stream());\n+                assertEquals(++count, printer.getRecordCount());\n+            }\n+        }\n+        try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertFalse(records.isEmpty());\n+            Utils.compare(\"Fail\", res, records);\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintRecordsWithCSVRecord() throws IOException {\n+        final String[] values = { \"A\", \"B\", \"C\" };\n+        final String rowData = StringUtils.join(values, ',');\n+        final CharArrayWriter charArrayWriter = new CharArrayWriter(0);\n+        try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(rowData));\n+                CSVPrinter printer = CSVFormat.INFORMIX_UNLOAD.print(charArrayWriter)) {\n+            long count = 0;\n+            for (final CSVRecord record : parser) {\n+                printer.printRecord(record);\n+                assertEquals(++count, printer.getRecordCount());\n+            }\n+        }\n+        assertEquals(6, charArrayWriter.size());\n+        assertEquals(\"A|B|C\" + CSVFormat.INFORMIX_UNLOAD.getRecordSeparator(), charArrayWriter.toString());\n+    }\n+\n+    @Test\n+    public void testPrintRecordsWithEmptyVector() throws IOException {\n+        final PrintStream out = System.out;\n+        try {\n+            System.setOut(new PrintStream(NullOutputStream.INSTANCE));\n+            try (CSVPrinter printer = CSVFormat.POSTGRESQL_TEXT.printer()) {\n+                final Vector<CSVFormatTest.EmptyEnum> vector = new Vector<>();\n+                final int expectedCapacity = 23;\n+                vector.setSize(expectedCapacity);\n+                printer.printRecords(vector);\n+                assertEquals(expectedCapacity, vector.capacity());\n+                assertEquals(expectedCapacity, printer.getRecordCount());\n+            }\n+        } finally {\n+            System.setOut(out);\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintRecordsWithObjectArray() throws IOException {\n+        final CharArrayWriter charArrayWriter = new CharArrayWriter(0);\n+        final Object[] objectArray = new Object[6];\n+        try (CSVPrinter printer = CSVFormat.INFORMIX_UNLOAD.print(charArrayWriter)) {\n+            final HashSet<BatchUpdateException> hashSet = new HashSet<>();\n+            objectArray[3] = hashSet;\n+            printer.printRecords(objectArray);\n+            assertEquals(objectArray.length, printer.getRecordCount());\n+        }\n+        assertEquals(6, charArrayWriter.size());\n+        assertEquals(\"\\n\\n\\n\\n\\n\\n\", charArrayWriter.toString());\n+    }\n+\n+    @Test\n+    public void testPrintRecordsWithResultSetOneRow() throws IOException, SQLException {\n+        try (CSVPrinter printer = CSVFormat.MYSQL.printer()) {\n+            try (ResultSet resultSet = new SimpleResultSet()) {\n+                assertInitialState(printer);\n+                printer.printRecords(resultSet);\n+                assertInitialState(printer);\n+                assertEquals(0, resultSet.getRow());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintToFileWithCharsetUtf16Be() throws IOException {\n+        final File file = createTempFile();\n+        try (CSVPrinter printer = CSVFormat.DEFAULT.print(file, StandardCharsets.UTF_16BE)) {\n+            printer.printRecord(\"a\", \"b\\\\c\");\n+        }\n+        assertEquals(\"a,b\\\\c\" + recordSeparator, FileUtils.readFileToString(file, StandardCharsets.UTF_16BE));\n+    }\n+\n+    @Test\n+    public void testPrintToFileWithDefaultCharset() throws IOException {\n+        final File file = createTempFile();\n+        try (CSVPrinter printer = CSVFormat.DEFAULT.print(file, Charset.defaultCharset())) {\n+            printer.printRecord(\"a\", \"b\\\\c\");\n+        }\n+        assertEquals(\"a,b\\\\c\" + recordSeparator, FileUtils.readFileToString(file, Charset.defaultCharset()));\n+    }\n+\n+    @Test\n+    public void testPrintToPathWithDefaultCharset() throws IOException {\n+        final Path file = createTempPath();\n+        try (CSVPrinter printer = CSVFormat.DEFAULT.print(file, Charset.defaultCharset())) {\n+            printer.printRecord(\"a\", \"b\\\\c\");\n+        }\n+        assertEquals(\"a,b\\\\c\" + recordSeparator, new String(Files.readAllBytes(file), Charset.defaultCharset()));\n+    }\n+\n+    @Test\n+    public void testQuoteAll() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.ALL))) {\n+            printer.printRecord(\"a\", \"b\\nc\", \"d\");\n+            assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",\\\"d\\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testQuoteCommaFirstChar() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) {\n+            printer.printRecord(\",\");\n+            assertEquals(\"\\\",\\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testQuoteNonNumeric() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.NON_NUMERIC))) {\n+            printer.printRecord(\"a\", \"b\\nc\", Integer.valueOf(1));\n+            assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",1\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testRandomDefault() throws Exception {\n+        doRandom(CSVFormat.DEFAULT, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    public void testRandomExcel() throws Exception {\n+        doRandom(CSVFormat.EXCEL, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testRandomMongoDbCsv() throws Exception {\n+        doRandom(CSVFormat.MONGODB_CSV, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    public void testRandomMySql() throws Exception {\n+        doRandom(CSVFormat.MYSQL, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testRandomOracle() throws Exception {\n+        doRandom(CSVFormat.ORACLE, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testRandomPostgreSqlCsv() throws Exception {\n+        doRandom(CSVFormat.POSTGRESQL_CSV, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    public void testRandomPostgreSqlText() throws Exception {\n+        doRandom(CSVFormat.POSTGRESQL_TEXT, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    public void testRandomRfc4180() throws Exception {\n+        doRandom(CSVFormat.RFC4180, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    public void testRandomTdf() throws Exception {\n+        doRandom(CSVFormat.TDF, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    public void testSingleLineComment() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'))) {\n+            printer.printComment(\"This is a comment\");\n+            assertEquals(\"# This is a comment\" + recordSeparator, sw.toString());\n+            assertEquals(0, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testSingleQuoteQuoted() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\n+            printer.print(\"a'b'c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"'a''b''c',xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testSkipHeaderRecordFalse() throws IOException {\n+        // functionally identical to testHeader, used to test CSV-153\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(false))) {\n+            printer.printRecord(\"a\", \"b\", \"c\");\n+            printer.printRecord(\"x\", \"y\", \"z\");\n+            assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testSkipHeaderRecordTrue() throws IOException {\n+        // functionally identical to testHeaderNotSet, used to test CSV-153\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(true))) {\n+            printer.printRecord(\"a\", \"b\", \"c\");\n+            printer.printRecord(\"x\", \"y\", \"z\");\n+            assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testTrailingDelimiterOnTwoColumns() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrailingDelimiter())) {\n+            printer.printRecord(\"A\", \"B\");\n+            assertEquals(\"A,B,\\r\\n\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testTrimOffOneColumn() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim(false))) {\n+            printer.print(\" A \");\n+            assertEquals(\"\\\" A \\\"\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testTrimOnOneColumn() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim())) {\n+            printer.print(\" A \");\n+            assertEquals(\"A\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testTrimOnTwoColumns() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim())) {\n+            printer.print(\" A \");\n+            printer.print(\" B \");\n+            assertEquals(\"A,B\", sw.toString());\n+        }\n+    }\n+\n+    private String[] toFirstRecordValues(final String expected, final CSVFormat format) throws IOException {\n+        try (CSVParser parser = CSVParser.parse(expected, format)) {\n+            return parser.getRecords().get(0).values();\n+        }\n+    }\n+\n+    private void tryFormat(final List<String> list, final Character quote, final Character escape, final String expected) throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withQuote(quote).withEscape(escape).withRecordSeparator(null);\n+        final Appendable out = new StringBuilder();\n+        try (CSVPrinter printer = new CSVPrinter(out, format)) {\n+            printer.printRecord(list);\n+        }\n+        assertEquals(expected, out.toString());\n+    }\n+\n+}\ndiff --git a/src/test/java/org/apache/commons/csv/PerformanceTest.java b/src/test/java/org/apache/commons/csv/PerformanceTest.java\nindex f692ae8e..bf0d4838 100644\n--- a/src/test/java/org/apache/commons/csv/PerformanceTest.java\n+++ b/src/test/java/org/apache/commons/csv/PerformanceTest.java\n@@ -1,345 +1,345 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv;\r\n-\r\n-import static org.apache.commons.io.IOUtils.EOF;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.File;\r\n-import java.io.FileInputStream;\r\n-import java.io.FileOutputStream;\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStream;\r\n-import java.io.Reader;\r\n-import java.lang.reflect.Constructor;\r\n-import java.lang.reflect.InvocationTargetException;\r\n-import java.nio.charset.StandardCharsets;\r\n-import java.nio.file.Files;\r\n-import java.nio.file.Paths;\r\n-import java.util.zip.GZIPInputStream;\r\n-\r\n-import org.apache.commons.io.FileUtils;\r\n-import org.apache.commons.io.IOUtils;\r\n-\r\n-/**\r\n- * Basic test harness.\r\n- */\r\n-@SuppressWarnings(\"boxing\")\r\n-public class PerformanceTest {\r\n-\r\n-    @FunctionalInterface\r\n-    private interface CSVParserFactory {\r\n-        CSVParser createParser() throws IOException;\r\n-    }\r\n-\r\n-    // Container for basic statistics\r\n-    private static final class Stats {\r\n-        final int count;\r\n-        final int fields;\r\n-\r\n-        Stats(final int c, final int f) {\r\n-            count = c;\r\n-            fields = f;\r\n-        }\r\n-    }\r\n-\r\n-    private static final String[] PROPERTY_NAMES = { \"java.version\", // Java Runtime Environment version\r\n-            \"java.vendor\", // Java Runtime Environment vendor\r\n-//        \"java.vm.specification.version\", // Java Virtual Machine specification version\r\n-//        \"java.vm.specification.vendor\",  // Java Virtual Machine specification vendor\r\n-//        \"java.vm.specification.name\",    // Java Virtual Machine specification name\r\n-            \"java.vm.version\", // Java Virtual Machine implementation version\r\n-//        \"java.vm.vendor\",                // Java Virtual Machine implementation vendor\r\n-            \"java.vm.name\", // Java Virtual Machine implementation name\r\n-//        \"java.specification.version\",    // Java Runtime Environment specification version\r\n-//        \"java.specification.vendor\",     // Java Runtime Environment specification vendor\r\n-//        \"java.specification.name\",       // Java Runtime Environment specification name\r\n-\r\n-            \"os.name\", // Operating system name\r\n-            \"os.arch\", // Operating system architecture\r\n-            \"os.version\", // Operating system version\r\n-    };\r\n-    private static int max = 11; // skip first test\r\n-\r\n-    private static int num; // number of elapsed times recorded\r\n-\r\n-    private static final long[] ELAPSED_TIMES = new long[max];\r\n-    private static final CSVFormat format = CSVFormat.EXCEL;\r\n-\r\n-    private static final String TEST_RESRC = \"org/apache/commons/csv/perf/worldcitiespop.txt.gz\";\r\n-\r\n-    private static final File BIG_FILE = new File(FileUtils.getTempDirectoryPath(), \"worldcitiespop.txt\");\r\n-\r\n-    private static Reader createReader() throws IOException {\r\n-        return new InputStreamReader(new FileInputStream(BIG_FILE), StandardCharsets.ISO_8859_1);\r\n-    }\r\n-\r\n-    private static Lexer createTestCSVLexer(final String test, final ExtendedBufferedReader input)\r\n-            throws InstantiationException, IllegalAccessException, InvocationTargetException, Exception {\r\n-        return test.startsWith(\"CSVLexer\") ? getLexerCtor(test).newInstance(format, input) : new Lexer(format, input);\r\n-    }\r\n-\r\n-    private static Constructor<Lexer> getLexerCtor(final String clazz) throws Exception {\r\n-        @SuppressWarnings(\"unchecked\")\r\n-        final Class<Lexer> lexer = (Class<Lexer>) Class.forName(\"org.apache.commons.csv.\" + clazz);\r\n-        return lexer.getConstructor(CSVFormat.class, ExtendedBufferedReader.class);\r\n-    }\r\n-\r\n-    private static Stats iterate(final Iterable<CSVRecord> iterable) {\r\n-        int count = 0;\r\n-        int fields = 0;\r\n-        for (final CSVRecord record : iterable) {\r\n-            count++;\r\n-            fields += record.size();\r\n-        }\r\n-        return new Stats(count, fields);\r\n-    }\r\n-\r\n-    public static void main(final String[] args) throws Exception {\r\n-        if (BIG_FILE.exists()) {\r\n-            System.out.printf(\"Found test fixture %s: %,d bytes.%n\", BIG_FILE, BIG_FILE.length());\r\n-        } else {\r\n-            System.out.println(\"Decompressing test fixture to: \" + BIG_FILE + \"...\");\r\n-            try (InputStream input = new GZIPInputStream(PerformanceTest.class.getClassLoader().getResourceAsStream(TEST_RESRC));\r\n-                    OutputStream output = new FileOutputStream(BIG_FILE)) {\r\n-                IOUtils.copy(input, output);\r\n-                System.out.println(String.format(\"Decompressed test fixture %s: %,d bytes.\", BIG_FILE, BIG_FILE.length()));\r\n-            }\r\n-        }\r\n-        final int argc = args.length;\r\n-        if (argc > 0) {\r\n-            max = Integer.parseInt(args[0]);\r\n-        }\r\n-\r\n-        final String[] tests;\r\n-        if (argc > 1) {\r\n-            tests = new String[argc - 1];\r\n-            System.arraycopy(args, 1, tests, 0, argc - 1);\r\n-        } else {\r\n-            tests = new String[] { \"file\", \"split\", \"extb\", \"exts\", \"csv\", \"csv-path\", \"csv-path-db\", \"csv-url\", \"lexreset\", \"lexnew\" };\r\n-        }\r\n-        for (final String p : PROPERTY_NAMES) {\r\n-            System.out.printf(\"%s=%s%n\", p, System.getProperty(p));\r\n-        }\r\n-        System.out.printf(\"Max count: %d%n%n\", max);\r\n-\r\n-        for (final String test : tests) {\r\n-            switch (test) {\r\n-            case \"file\":\r\n-                testReadBigFile(false);\r\n-                break;\r\n-            case \"split\":\r\n-                testReadBigFile(true);\r\n-                break;\r\n-            case \"csv\":\r\n-                testParseCommonsCSV();\r\n-                break;\r\n-            case \"csv-path\":\r\n-                testParsePath();\r\n-                break;\r\n-            case \"csv-path-db\":\r\n-                testParsePathDoubleBuffering();\r\n-                break;\r\n-            case \"csv-url\":\r\n-                testParseURL();\r\n-                break;\r\n-            case \"lexreset\":\r\n-                testCSVLexer(false, test);\r\n-                break;\r\n-            case \"lexnew\":\r\n-                testCSVLexer(true, test);\r\n-                break;\r\n-            default:\r\n-                if (test.startsWith(\"CSVLexer\")) {\r\n-                    testCSVLexer(false, test);\r\n-                } else if (\"extb\".equals(test)) {\r\n-                    testExtendedBuffer(false);\r\n-                } else if (\"exts\".equals(test)) {\r\n-                    testExtendedBuffer(true);\r\n-                } else {\r\n-                    System.out.printf(\"Invalid test name: %s%n\", test);\r\n-                }\r\n-                break;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private static Stats readAll(final BufferedReader in, final boolean split) throws IOException {\r\n-        int count = 0;\r\n-        int fields = 0;\r\n-        String record;\r\n-        while ((record = in.readLine()) != null) {\r\n-            count++;\r\n-            fields += split ? record.split(\",\").length : 1;\r\n-        }\r\n-        return new Stats(count, fields);\r\n-    }\r\n-\r\n-    // calculate and show average\r\n-    private static void show() {\r\n-        if (num > 1) {\r\n-            long tot = 0;\r\n-            for (int i = 1; i < num; i++) { // skip first test\r\n-                tot += ELAPSED_TIMES[i];\r\n-            }\r\n-            System.out.printf(\"%-20s: %5dms%n%n\", \"Average(not first)\", tot / (num - 1));\r\n-        }\r\n-        num = 0; // ready for next set\r\n-    }\r\n-\r\n-    // Display end stats; store elapsed for average\r\n-    private static void show(final String msg, final Stats s, final long start) {\r\n-        final long elapsed = System.currentTimeMillis() - start;\r\n-        System.out.printf(\"%-20s: %5dms %d lines %d fields%n\", msg, elapsed, s.count, s.fields);\r\n-        ELAPSED_TIMES[num] = elapsed;\r\n-        num++;\r\n-    }\r\n-\r\n-    private static void testCSVLexer(final boolean newToken, final String test) throws Exception {\r\n-        Token token = new Token();\r\n-        String dynamic = \"\";\r\n-        for (int i = 0; i < max; i++) {\r\n-            final String simpleName;\r\n-            final Stats stats;\r\n-            final long startMillis;\r\n-            try (ExtendedBufferedReader input = new ExtendedBufferedReader(createReader());\r\n-                    Lexer lexer = createTestCSVLexer(test, input)) {\r\n-                if (test.startsWith(\"CSVLexer\")) {\r\n-                    dynamic = \"!\";\r\n-                }\r\n-                simpleName = lexer.getClass().getSimpleName();\r\n-                int count = 0;\r\n-                int fields = 0;\r\n-                startMillis = System.currentTimeMillis();\r\n-                do {\r\n-                    if (newToken) {\r\n-                        token = new Token();\r\n-                    } else {\r\n-                        token.reset();\r\n-                    }\r\n-                    lexer.nextToken(token);\r\n-                    switch (token.type) {\r\n-                    case EOF:\r\n-                        break;\r\n-                    case EORECORD:\r\n-                        fields++;\r\n-                        count++;\r\n-                        break;\r\n-                    case INVALID:\r\n-                        throw new IOException(\"invalid parse sequence <\" + token.content.toString() + \">\");\r\n-                    case TOKEN:\r\n-                        fields++;\r\n-                        break;\r\n-                    case COMMENT: // not really expecting these\r\n-                        break;\r\n-                    default:\r\n-                        throw new IllegalStateException(\"Unexpected Token type: \" + token.type);\r\n-                    }\r\n-                } while (!token.type.equals(Token.Type.EOF));\r\n-                stats = new Stats(count, fields);\r\n-            }\r\n-            show(simpleName + dynamic + \" \" + (newToken ? \"new\" : \"reset\"), stats, startMillis);\r\n-        }\r\n-        show();\r\n-    }\r\n-\r\n-    private static void testExtendedBuffer(final boolean makeString) throws Exception {\r\n-        for (int i = 0; i < max; i++) {\r\n-            int fields = 0;\r\n-            int lines = 0;\r\n-            final long startMillis;\r\n-            try (ExtendedBufferedReader in = new ExtendedBufferedReader(createReader())) {\r\n-                startMillis = System.currentTimeMillis();\r\n-                int read;\r\n-                if (makeString) {\r\n-                    StringBuilder sb = new StringBuilder();\r\n-                    while ((read = in.read()) != EOF) {\r\n-                        sb.append((char) read);\r\n-                        if (read == ',') { // count delimiters\r\n-                            sb.toString();\r\n-                            sb = new StringBuilder();\r\n-                            fields++;\r\n-                        } else if (read == '\\n') {\r\n-                            sb.toString();\r\n-                            sb = new StringBuilder();\r\n-                            lines++;\r\n-                        }\r\n-                    }\r\n-                } else {\r\n-                    while ((read = in.read()) != EOF) {\r\n-                        if (read == ',') { // count delimiters\r\n-                            fields++;\r\n-                        } else if (read == '\\n') {\r\n-                            lines++;\r\n-                        }\r\n-                    }\r\n-                }\r\n-                fields += lines; // EOL is a delimiter too\r\n-            }\r\n-            show(\"Extended\" + (makeString ? \" toString\" : \"\"), new Stats(lines, fields), startMillis);\r\n-        }\r\n-        show();\r\n-    }\r\n-\r\n-    private static void testParseCommonsCSV() throws Exception {\r\n-        testParser(\"CSV\", () -> CSVParser.builder().setReader(createReader()).setFormat(format).get());\r\n-    }\r\n-\r\n-    private static void testParsePath() throws Exception {\r\n-        testParser(\"CSV-PATH\", () -> CSVParser.parse(Files.newInputStream(Paths.get(BIG_FILE.toURI())), StandardCharsets.ISO_8859_1, format));\r\n-    }\r\n-\r\n-    private static void testParsePathDoubleBuffering() throws Exception {\r\n-        testParser(\"CSV-PATH-DB\", () -> CSVParser.parse(Files.newBufferedReader(Paths.get(BIG_FILE.toURI()), StandardCharsets.ISO_8859_1), format));\r\n-    }\r\n-\r\n-    private static void testParser(final String msg, final CSVParserFactory fac) throws Exception {\r\n-        for (int i = 0; i < max; i++) {\r\n-            final long startMillis;\r\n-            final Stats stats;\r\n-            try (CSVParser parser = fac.createParser()) {\r\n-                startMillis = System.currentTimeMillis();\r\n-                stats = iterate(parser);\r\n-            }\r\n-            show(msg, stats, startMillis);\r\n-        }\r\n-        show();\r\n-    }\r\n-\r\n-    private static void testParseURL() throws Exception {\r\n-        testParser(\"CSV-URL\", () -> CSVParser.parse(BIG_FILE.toURI().toURL(), StandardCharsets.ISO_8859_1, format));\r\n-    }\r\n-\r\n-    private static void testReadBigFile(final boolean split) throws Exception {\r\n-        for (int i = 0; i < max; i++) {\r\n-            final long startMillis;\r\n-            final Stats stats;\r\n-            try (BufferedReader in = new BufferedReader(createReader())) {\r\n-                startMillis = System.currentTimeMillis();\r\n-                stats = readAll(in, split);\r\n-            }\r\n-            show(split ? \"file+split\" : \"file\", stats, startMillis);\r\n-        }\r\n-        show();\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import static org.apache.commons.io.IOUtils.EOF;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.Reader;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.IOUtils;\n+\n+/**\n+ * Basic test harness.\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class PerformanceTest {\n+\n+    @FunctionalInterface\n+    private interface CSVParserFactory {\n+        CSVParser createParser() throws IOException;\n+    }\n+\n+    // Container for basic statistics\n+    private static final class Stats {\n+        final int count;\n+        final int fields;\n+\n+        Stats(final int c, final int f) {\n+            count = c;\n+            fields = f;\n+        }\n+    }\n+\n+    private static final String[] PROPERTY_NAMES = { \"java.version\", // Java Runtime Environment version\n+            \"java.vendor\", // Java Runtime Environment vendor\n+//        \"java.vm.specification.version\", // Java Virtual Machine specification version\n+//        \"java.vm.specification.vendor\",  // Java Virtual Machine specification vendor\n+//        \"java.vm.specification.name\",    // Java Virtual Machine specification name\n+            \"java.vm.version\", // Java Virtual Machine implementation version\n+//        \"java.vm.vendor\",                // Java Virtual Machine implementation vendor\n+            \"java.vm.name\", // Java Virtual Machine implementation name\n+//        \"java.specification.version\",    // Java Runtime Environment specification version\n+//        \"java.specification.vendor\",     // Java Runtime Environment specification vendor\n+//        \"java.specification.name\",       // Java Runtime Environment specification name\n+\n+            \"os.name\", // Operating system name\n+            \"os.arch\", // Operating system architecture\n+            \"os.version\", // Operating system version\n+    };\n+    private static int max = 11; // skip first test\n+\n+    private static int num; // number of elapsed times recorded\n+\n+    private static final long[] ELAPSED_TIMES = new long[max];\n+    private static final CSVFormat format = CSVFormat.EXCEL;\n+\n+    private static final String TEST_RESRC = \"org/apache/commons/csv/perf/worldcitiespop.txt.gz\";\n+\n+    private static final File BIG_FILE = new File(FileUtils.getTempDirectoryPath(), \"worldcitiespop.txt\");\n+\n+    private static Reader createReader() throws IOException {\n+        return new InputStreamReader(new FileInputStream(BIG_FILE), StandardCharsets.ISO_8859_1);\n+    }\n+\n+    private static Lexer createTestCSVLexer(final String test, final ExtendedBufferedReader input)\n+            throws InstantiationException, IllegalAccessException, InvocationTargetException, Exception {\n+        return test.startsWith(\"CSVLexer\") ? getLexerCtor(test).newInstance(format, input) : new Lexer(format, input);\n+    }\n+\n+    private static Constructor<Lexer> getLexerCtor(final String clazz) throws Exception {\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<Lexer> lexer = (Class<Lexer>) Class.forName(\"org.apache.commons.csv.\" + clazz);\n+        return lexer.getConstructor(CSVFormat.class, ExtendedBufferedReader.class);\n+    }\n+\n+    private static Stats iterate(final Iterable<CSVRecord> iterable) {\n+        int count = 0;\n+        int fields = 0;\n+        for (final CSVRecord record : iterable) {\n+            count++;\n+            fields += record.size();\n+        }\n+        return new Stats(count, fields);\n+    }\n+\n+    public static void main(final String[] args) throws Exception {\n+        if (BIG_FILE.exists()) {\n+            System.out.printf(\"Found test fixture %s: %,d bytes.%n\", BIG_FILE, BIG_FILE.length());\n+        } else {\n+            System.out.println(\"Decompressing test fixture to: \" + BIG_FILE + \"...\");\n+            try (InputStream input = new GZIPInputStream(PerformanceTest.class.getClassLoader().getResourceAsStream(TEST_RESRC));\n+                    OutputStream output = new FileOutputStream(BIG_FILE)) {\n+                IOUtils.copy(input, output);\n+                System.out.println(String.format(\"Decompressed test fixture %s: %,d bytes.\", BIG_FILE, BIG_FILE.length()));\n+            }\n+        }\n+        final int argc = args.length;\n+        if (argc > 0) {\n+            max = Integer.parseInt(args[0]);\n+        }\n+\n+        final String[] tests;\n+        if (argc > 1) {\n+            tests = new String[argc - 1];\n+            System.arraycopy(args, 1, tests, 0, argc - 1);\n+        } else {\n+            tests = new String[] { \"file\", \"split\", \"extb\", \"exts\", \"csv\", \"csv-path\", \"csv-path-db\", \"csv-url\", \"lexreset\", \"lexnew\" };\n+        }\n+        for (final String p : PROPERTY_NAMES) {\n+            System.out.printf(\"%s=%s%n\", p, System.getProperty(p));\n+        }\n+        System.out.printf(\"Max count: %d%n%n\", max);\n+\n+        for (final String test : tests) {\n+            switch (test) {\n+            case \"file\":\n+                testReadBigFile(false);\n+                break;\n+            case \"split\":\n+                testReadBigFile(true);\n+                break;\n+            case \"csv\":\n+                testParseCommonsCSV();\n+                break;\n+            case \"csv-path\":\n+                testParsePath();\n+                break;\n+            case \"csv-path-db\":\n+                testParsePathDoubleBuffering();\n+                break;\n+            case \"csv-url\":\n+                testParseURL();\n+                break;\n+            case \"lexreset\":\n+                testCSVLexer(false, test);\n+                break;\n+            case \"lexnew\":\n+                testCSVLexer(true, test);\n+                break;\n+            default:\n+                if (test.startsWith(\"CSVLexer\")) {\n+                    testCSVLexer(false, test);\n+                } else if (\"extb\".equals(test)) {\n+                    testExtendedBuffer(false);\n+                } else if (\"exts\".equals(test)) {\n+                    testExtendedBuffer(true);\n+                } else {\n+                    System.out.printf(\"Invalid test name: %s%n\", test);\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    private static Stats readAll(final BufferedReader in, final boolean split) throws IOException {\n+        int count = 0;\n+        int fields = 0;\n+        String record;\n+        while ((record = in.readLine()) != null) {\n+            count++;\n+            fields += split ? record.split(\",\").length : 1;\n+        }\n+        return new Stats(count, fields);\n+    }\n+\n+    // calculate and show average\n+    private static void show() {\n+        if (num > 1) {\n+            long tot = 0;\n+            for (int i = 1; i < num; i++) { // skip first test\n+                tot += ELAPSED_TIMES[i];\n+            }\n+            System.out.printf(\"%-20s: %5dms%n%n\", \"Average(not first)\", tot / (num - 1));\n+        }\n+        num = 0; // ready for next set\n+    }\n+\n+    // Display end stats; store elapsed for average\n+    private static void show(final String msg, final Stats s, final long start) {\n+        final long elapsed = System.currentTimeMillis() - start;\n+        System.out.printf(\"%-20s: %5dms %d lines %d fields%n\", msg, elapsed, s.count, s.fields);\n+        ELAPSED_TIMES[num] = elapsed;\n+        num++;\n+    }\n+\n+    private static void testCSVLexer(final boolean newToken, final String test) throws Exception {\n+        Token token = new Token();\n+        String dynamic = \"\";\n+        for (int i = 0; i < max; i++) {\n+            final String simpleName;\n+            final Stats stats;\n+            final long startMillis;\n+            try (ExtendedBufferedReader input = new ExtendedBufferedReader(createReader());\n+                    Lexer lexer = createTestCSVLexer(test, input)) {\n+                if (test.startsWith(\"CSVLexer\")) {\n+                    dynamic = \"!\";\n+                }\n+                simpleName = lexer.getClass().getSimpleName();\n+                int count = 0;\n+                int fields = 0;\n+                startMillis = System.currentTimeMillis();\n+                do {\n+                    if (newToken) {\n+                        token = new Token();\n+                    } else {\n+                        token.reset();\n+                    }\n+                    lexer.nextToken(token);\n+                    switch (token.type) {\n+                    case EOF:\n+                        break;\n+                    case EORECORD:\n+                        fields++;\n+                        count++;\n+                        break;\n+                    case INVALID:\n+                        throw new IOException(\"invalid parse sequence <\" + token.content.toString() + \">\");\n+                    case TOKEN:\n+                        fields++;\n+                        break;\n+                    case COMMENT: // not really expecting these\n+                        break;\n+                    default:\n+                        throw new IllegalStateException(\"Unexpected Token type: \" + token.type);\n+                    }\n+                } while (!token.type.equals(Token.Type.EOF));\n+                stats = new Stats(count, fields);\n+            }\n+            show(simpleName + dynamic + \" \" + (newToken ? \"new\" : \"reset\"), stats, startMillis);\n+        }\n+        show();\n+    }\n+\n+    private static void testExtendedBuffer(final boolean makeString) throws Exception {\n+        for (int i = 0; i < max; i++) {\n+            int fields = 0;\n+            int lines = 0;\n+            final long startMillis;\n+            try (ExtendedBufferedReader in = new ExtendedBufferedReader(createReader())) {\n+                startMillis = System.currentTimeMillis();\n+                int read;\n+                if (makeString) {\n+                    StringBuilder sb = new StringBuilder();\n+                    while ((read = in.read()) != EOF) {\n+                        sb.append((char) read);\n+                        if (read == ',') { // count delimiters\n+                            sb.toString();\n+                            sb = new StringBuilder();\n+                            fields++;\n+                        } else if (read == '\\n') {\n+                            sb.toString();\n+                            sb = new StringBuilder();\n+                            lines++;\n+                        }\n+                    }\n+                } else {\n+                    while ((read = in.read()) != EOF) {\n+                        if (read == ',') { // count delimiters\n+                            fields++;\n+                        } else if (read == '\\n') {\n+                            lines++;\n+                        }\n+                    }\n+                }\n+                fields += lines; // EOL is a delimiter too\n+            }\n+            show(\"Extended\" + (makeString ? \" toString\" : \"\"), new Stats(lines, fields), startMillis);\n+        }\n+        show();\n+    }\n+\n+    private static void testParseCommonsCSV() throws Exception {\n+        testParser(\"CSV\", () -> CSVParser.builder().setReader(createReader()).setFormat(format).get());\n+    }\n+\n+    private static void testParsePath() throws Exception {\n+        testParser(\"CSV-PATH\", () -> CSVParser.parse(Files.newInputStream(Paths.get(BIG_FILE.toURI())), StandardCharsets.ISO_8859_1, format));\n+    }\n+\n+    private static void testParsePathDoubleBuffering() throws Exception {\n+        testParser(\"CSV-PATH-DB\", () -> CSVParser.parse(Files.newBufferedReader(Paths.get(BIG_FILE.toURI()), StandardCharsets.ISO_8859_1), format));\n+    }\n+\n+    private static void testParser(final String msg, final CSVParserFactory fac) throws Exception {\n+        for (int i = 0; i < max; i++) {\n+            final long startMillis;\n+            final Stats stats;\n+            try (CSVParser parser = fac.createParser()) {\n+                startMillis = System.currentTimeMillis();\n+                stats = iterate(parser);\n+            }\n+            show(msg, stats, startMillis);\n+        }\n+        show();\n+    }\n+\n+    private static void testParseURL() throws Exception {\n+        testParser(\"CSV-URL\", () -> CSVParser.parse(BIG_FILE.toURI().toURL(), StandardCharsets.ISO_8859_1, format));\n+    }\n+\n+    private static void testReadBigFile(final boolean split) throws Exception {\n+        for (int i = 0; i < max; i++) {\n+            final long startMillis;\n+            final Stats stats;\n+            try (BufferedReader in = new BufferedReader(createReader())) {\n+                startMillis = System.currentTimeMillis();\n+                stats = readAll(in, split);\n+            }\n+            show(split ? \"file+split\" : \"file\", stats, startMillis);\n+        }\n+        show();\n+    }\n+}\n+\ndiff --git a/src/test/java/org/apache/commons/csv/issues/JiraCsv198Test.java b/src/test/java/org/apache/commons/csv/issues/JiraCsv198Test.java\nindex cee88f15..641797fe 100644\n--- a/src/test/java/org/apache/commons/csv/issues/JiraCsv198Test.java\n+++ b/src/test/java/org/apache/commons/csv/issues/JiraCsv198Test.java\n@@ -1,54 +1,54 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv.issues;\r\n-\r\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.InputStreamReader;\r\n-import java.io.UnsupportedEncodingException;\r\n-import java.nio.charset.StandardCharsets;\r\n-\r\n-import org.apache.commons.csv.CSVFormat;\r\n-import org.apache.commons.csv.CSVParser;\r\n-import org.junit.jupiter.api.Test;\r\n-\r\n-public class JiraCsv198Test {\r\n-\r\n-    // @formatter:off\r\n-    private static final CSVFormat CSV_FORMAT = CSVFormat.EXCEL.builder()\r\n-        .setDelimiter('^')\r\n-        .setHeader()\r\n-        .setSkipHeaderRecord(true)\r\n-        .get();\r\n-    // @formatter:on\r\n-\r\n-    @Test\r\n-    public void test() throws UnsupportedEncodingException, IOException {\r\n-        final InputStream pointsOfReference = getClass().getResourceAsStream(\"/org/apache/commons/csv/CSV-198/optd_por_public.csv\");\r\n-        assertNotNull(pointsOfReference);\r\n-        try (@SuppressWarnings(\"resource\")\r\n-        CSVParser parser = CSV_FORMAT.parse(new InputStreamReader(pointsOfReference, StandardCharsets.UTF_8))) {\r\n-            parser.forEach(record -> assertNotNull(record.get(\"location_type\")));\r\n-        }\r\n-    }\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv.issues;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.commons.csv.CSVFormat;\n+import org.apache.commons.csv.CSVParser;\n+import org.junit.jupiter.api.Test;\n+\n+public class JiraCsv198Test {\n+\n+    // @formatter:off\n+    private static final CSVFormat CSV_FORMAT = CSVFormat.EXCEL.builder()\n+        .setDelimiter('^')\n+        .setHeader()\n+        .setSkipHeaderRecord(true)\n+        .get();\n+    // @formatter:on\n+\n+    @Test\n+    public void test() throws UnsupportedEncodingException, IOException {\n+        final InputStream pointsOfReference = getClass().getResourceAsStream(\"/org/apache/commons/csv/CSV-198/optd_por_public.csv\");\n+        assertNotNull(pointsOfReference);\n+        try (@SuppressWarnings(\"resource\")\n+        CSVParser parser = CSV_FORMAT.parse(new InputStreamReader(pointsOfReference, StandardCharsets.UTF_8))) {\n+            parser.forEach(record -> assertNotNull(record.get(\"location_type\")));\n+        }\n+    }\n+\n+}\ndiff --git a/src/test/java/org/apache/commons/csv/issues/JiraCsv211Test.java b/src/test/java/org/apache/commons/csv/issues/JiraCsv211Test.java\nindex 9da17465..a4e3960c 100644\n--- a/src/test/java/org/apache/commons/csv/issues/JiraCsv211Test.java\n+++ b/src/test/java/org/apache/commons/csv/issues/JiraCsv211Test.java\n@@ -1,54 +1,54 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv.issues;\r\n-\r\n-import static org.junit.jupiter.api.Assertions.assertEquals;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.StringReader;\r\n-\r\n-import org.apache.commons.csv.CSVFormat;\r\n-import org.apache.commons.csv.CSVParser;\r\n-import org.junit.jupiter.api.Test;\r\n-\r\n-public class JiraCsv211Test {\r\n-\r\n-    @Test\r\n-    public void testJiraCsv211Format() throws IOException {\r\n-        // @formatter:off\r\n-        final CSVFormat printFormat = CSVFormat.DEFAULT.builder()\r\n-            .setDelimiter('\\t')\r\n-            .setHeader(\"ID\", \"Name\", \"Country\", \"Age\")\r\n-            .get();\r\n-        // @formatter:on\r\n-        final String formatted = printFormat.format(\"1\", \"Jane Doe\", \"USA\", \"\");\r\n-        assertEquals(\"ID\\tName\\tCountry\\tAge\\r\\n1\\tJane Doe\\tUSA\\t\", formatted);\r\n-\r\n-        final CSVFormat parseFormat = CSVFormat.DEFAULT.builder().setDelimiter('\\t').setHeader().setSkipHeaderRecord(true).get();\r\n-        try (CSVParser parser = parseFormat.parse(new StringReader(formatted))) {\r\n-            parser.forEach(record -> {\r\n-                assertEquals(\"1\", record.get(0));\r\n-                assertEquals(\"Jane Doe\", record.get(1));\r\n-                assertEquals(\"USA\", record.get(2));\r\n-                assertEquals(\"\", record.get(3));\r\n-            });\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv.issues;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+\n+import org.apache.commons.csv.CSVFormat;\n+import org.apache.commons.csv.CSVParser;\n+import org.junit.jupiter.api.Test;\n+\n+public class JiraCsv211Test {\n+\n+    @Test\n+    public void testJiraCsv211Format() throws IOException {\n+        // @formatter:off\n+        final CSVFormat printFormat = CSVFormat.DEFAULT.builder()\n+            .setDelimiter('\\t')\n+            .setHeader(\"ID\", \"Name\", \"Country\", \"Age\")\n+            .get();\n+        // @formatter:on\n+        final String formatted = printFormat.format(\"1\", \"Jane Doe\", \"USA\", \"\");\n+        assertEquals(\"ID\\tName\\tCountry\\tAge\\r\\n1\\tJane Doe\\tUSA\\t\", formatted);\n+\n+        final CSVFormat parseFormat = CSVFormat.DEFAULT.builder().setDelimiter('\\t').setHeader().setSkipHeaderRecord(true).get();\n+        try (CSVParser parser = parseFormat.parse(new StringReader(formatted))) {\n+            parser.forEach(record -> {\n+                assertEquals(\"1\", record.get(0));\n+                assertEquals(\"Jane Doe\", record.get(1));\n+                assertEquals(\"USA\", record.get(2));\n+                assertEquals(\"\", record.get(3));\n+            });\n+        }\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java b/src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java\nindex 4e614816..0be6a52f 100644\n--- a/src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java\n+++ b/src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java\n@@ -1,216 +1,216 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv.issues;\r\n-\r\n-import static org.junit.jupiter.api.Assertions.assertEquals;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.Reader;\r\n-import java.io.StringReader;\r\n-\r\n-import org.apache.commons.csv.CSVFormat;\r\n-import org.apache.commons.csv.CSVParser;\r\n-import org.apache.commons.csv.CSVPrinter;\r\n-import org.apache.commons.csv.CSVRecord;\r\n-import org.junit.jupiter.api.Test;\r\n-\r\n-public class JiraCsv288Test {\r\n-\r\n-    private void print(final CSVRecord csvRecord, final CSVPrinter csvPrinter) throws IOException {\r\n-        for (final String value : csvRecord) {\r\n-            csvPrinter.print(value);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Before fix:\r\n-    // expected: <a,b,c,d,,f> but was: <a,b,c,d,|f>\r\n-    public void testParseWithABADelimiter() throws Exception {\r\n-        final Reader in = new StringReader(\"a|~|b|~|c|~|d|~||~|f\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser parser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"|~|\").get())) {\r\n-            for (final CSVRecord csvRecord : parser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Before fix:\r\n-    // expected: <a,b,c,d,,f> but was: <a,b|c,d,|f>\r\n-    public void testParseWithDoublePipeDelimiter() throws Exception {\r\n-        final Reader in = new StringReader(\"a||b||c||d||||f\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Regression, already passed before fix\r\n-\r\n-    public void testParseWithDoublePipeDelimiterDoubleCharValue() throws Exception {\r\n-        final Reader in = new StringReader(\"a||bb||cc||dd||f\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,bb,cc,dd,f\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Before fix:\r\n-    // expected: <a,b,c,d,,f,> but was: <a,b|c,d,|f>\r\n-    public void testParseWithDoublePipeDelimiterEndsWithDelimiter() throws Exception {\r\n-        final Reader in = new StringReader(\"a||b||c||d||||f||\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f,\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Before fix:\r\n-    // expected: <a,b||c,d,,f> but was: <a,b||c,d,|f>\r\n-    public void testParseWithDoublePipeDelimiterQuoted() throws Exception {\r\n-        final Reader in = new StringReader(\"a||\\\"b||c\\\"||d||||f\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b||c,d,,f\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Regression, already passed before fix\r\n-    public void testParseWithSinglePipeDelimiterEndsWithDelimiter() throws Exception {\r\n-        final Reader in = new StringReader(\"a|b|c|d||f|\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"|\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f,\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Before fix:\r\n-    // expected: <a,b,c,d,,f> but was: <a,b|c,d,|f>\r\n-    public void testParseWithTriplePipeDelimiter() throws Exception {\r\n-        final Reader in = new StringReader(\"a|||b|||c|||d||||||f\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"|||\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Regression, already passed before fix\r\n-    public void testParseWithTwoCharDelimiter1() throws Exception {\r\n-        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Regression, already passed before fix\r\n-    public void testParseWithTwoCharDelimiter2() throws Exception {\r\n-        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f~\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f~\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Regression, already passed before fix\r\n-    public void testParseWithTwoCharDelimiter3() throws Exception {\r\n-        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f|\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f|\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Regression, already passed before fix\r\n-    public void testParseWithTwoCharDelimiter4() throws Exception {\r\n-        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f~~||g\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f~,|g\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Before fix:\r\n-    // expected: <a,b,c,d,,f,> but was: <a,b,c,d,,f>\r\n-    public void testParseWithTwoCharDelimiterEndsWithDelimiter() throws Exception {\r\n-        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f~|\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f,\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv.issues;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+\n+import org.apache.commons.csv.CSVFormat;\n+import org.apache.commons.csv.CSVParser;\n+import org.apache.commons.csv.CSVPrinter;\n+import org.apache.commons.csv.CSVRecord;\n+import org.junit.jupiter.api.Test;\n+\n+public class JiraCsv288Test {\n+\n+    private void print(final CSVRecord csvRecord, final CSVPrinter csvPrinter) throws IOException {\n+        for (final String value : csvRecord) {\n+            csvPrinter.print(value);\n+        }\n+    }\n+\n+    @Test\n+    // Before fix:\n+    // expected: <a,b,c,d,,f> but was: <a,b,c,d,|f>\n+    public void testParseWithABADelimiter() throws Exception {\n+        final Reader in = new StringReader(\"a|~|b|~|c|~|d|~||~|f\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser parser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"|~|\").get())) {\n+            for (final CSVRecord csvRecord : parser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Before fix:\n+    // expected: <a,b,c,d,,f> but was: <a,b|c,d,|f>\n+    public void testParseWithDoublePipeDelimiter() throws Exception {\n+        final Reader in = new StringReader(\"a||b||c||d||||f\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Regression, already passed before fix\n+\n+    public void testParseWithDoublePipeDelimiterDoubleCharValue() throws Exception {\n+        final Reader in = new StringReader(\"a||bb||cc||dd||f\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,bb,cc,dd,f\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Before fix:\n+    // expected: <a,b,c,d,,f,> but was: <a,b|c,d,|f>\n+    public void testParseWithDoublePipeDelimiterEndsWithDelimiter() throws Exception {\n+        final Reader in = new StringReader(\"a||b||c||d||||f||\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f,\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Before fix:\n+    // expected: <a,b||c,d,,f> but was: <a,b||c,d,|f>\n+    public void testParseWithDoublePipeDelimiterQuoted() throws Exception {\n+        final Reader in = new StringReader(\"a||\\\"b||c\\\"||d||||f\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b||c,d,,f\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Regression, already passed before fix\n+    public void testParseWithSinglePipeDelimiterEndsWithDelimiter() throws Exception {\n+        final Reader in = new StringReader(\"a|b|c|d||f|\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"|\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f,\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Before fix:\n+    // expected: <a,b,c,d,,f> but was: <a,b|c,d,|f>\n+    public void testParseWithTriplePipeDelimiter() throws Exception {\n+        final Reader in = new StringReader(\"a|||b|||c|||d||||||f\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"|||\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Regression, already passed before fix\n+    public void testParseWithTwoCharDelimiter1() throws Exception {\n+        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Regression, already passed before fix\n+    public void testParseWithTwoCharDelimiter2() throws Exception {\n+        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f~\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f~\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Regression, already passed before fix\n+    public void testParseWithTwoCharDelimiter3() throws Exception {\n+        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f|\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f|\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Regression, already passed before fix\n+    public void testParseWithTwoCharDelimiter4() throws Exception {\n+        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f~~||g\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f~,|g\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Before fix:\n+    // expected: <a,b,c,d,,f,> but was: <a,b,c,d,,f>\n+    public void testParseWithTwoCharDelimiterEndsWithDelimiter() throws Exception {\n+        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f~|\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f,\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+}",
    "source_only_diff": "diff --git a/.gitattributes b/.gitattributes\nnew file mode 100644\nindex 00000000..bec231c1\n--- /dev/null\n+++ b/.gitattributes\n@@ -0,0 +1,16 @@\n+#   Licensed to the Apache Software Foundation (ASF) under one or more\n+#   contributor license agreements.  See the NOTICE file distributed with\n+#   this work for additional information regarding copyright ownership.\n+#   The ASF licenses this file to You under the Apache License, Version 2.0\n+#   (the \"License\"); you may not use this file except in compliance with\n+#   the License.  You may obtain a copy of the License at\n+#\n+#       http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#   Unless required by applicable law or agreed to in writing, software\n+#   distributed under the License is distributed on an \"AS IS\" BASIS,\n+#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#   See the License for the specific language governing permissions and\n+#   limitations under the License.\n+\n+* text=auto\n\ndiff --git a/.github/workflows/codeql-analysis.yml b/.github/workflows/codeql-analysis.yml\nindex d6f2c05d..1f42db3b 100644\n--- a/.github/workflows/codeql-analysis.yml\n+++ b/.github/workflows/codeql-analysis.yml\n@@ -1,85 +1,85 @@\n-# Licensed to the Apache Software Foundation (ASF) under one or more\r\n-# contributor license agreements.  See the NOTICE file distributed with\r\n-# this work for additional information regarding copyright ownership.\r\n-# The ASF licenses this file to You under the Apache License, Version 2.0\r\n-# (the \"License\"); you may not use this file except in compliance with\r\n-# the License.  You may obtain a copy of the License at\r\n-#\r\n-#      http://www.apache.org/licenses/LICENSE-2.0\r\n-#\r\n-# Unless required by applicable law or agreed to in writing, software\r\n-# distributed under the License is distributed on an \"AS IS\" BASIS,\r\n-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n-# See the License for the specific language governing permissions and\r\n-# limitations under the License.\r\n-\r\n-name: \"CodeQL\"\r\n-\r\n-on:\r\n-  push:\r\n-    branches: [ master ]\r\n-  pull_request:\r\n-    # The branches below must be a subset of the branches above\r\n-    branches: [ master ]\r\n-  schedule:\r\n-    - cron: '33 9 * * 4'\r\n-\r\n-permissions:\r\n-  contents: read\r\n-\r\n-jobs:\r\n-  analyze:\r\n-    name: Analyze\r\n-    runs-on: ubuntu-latest\r\n-    permissions:\r\n-      actions: read\r\n-      contents: read\r\n-      security-events: write\r\n-\r\n-    strategy:\r\n-      fail-fast: false\r\n-      matrix:\r\n-        language: [ 'java' ]\r\n-        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\r\n-        # Learn more about CodeQL language support at https://git.io/codeql-language-support\r\n-\r\n-    steps:\r\n-    - name: Checkout repository\r\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+name: \"CodeQL\"\n+\n+on:\n+  push:\n+    branches: [ master ]\n+  pull_request:\n+    # The branches below must be a subset of the branches above\n+    branches: [ master ]\n+  schedule:\n+    - cron: '33 9 * * 4'\n+\n+permissions:\n+  contents: read\n+\n+jobs:\n+  analyze:\n+    name: Analyze\n+    runs-on: ubuntu-latest\n+    permissions:\n+      actions: read\n+      contents: read\n+      security-events: write\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        language: [ 'java' ]\n+        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n+        # Learn more about CodeQL language support at https://git.io/codeql-language-support\n+\n+    steps:\n+    - name: Checkout repository\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # 4.2.2\n-      with:\r\n-        persist-credentials: false\r\n+      with:\n+        persist-credentials: false\n     - uses: actions/cache@1bd1e32a3bdc45362d1e726936510720a7c30a57 # v4.2.0\n-      with:\r\n-        path: ~/.m2/repository\r\n-        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}\r\n-        restore-keys: |\r\n-          ${{ runner.os }}-maven-\r\n-\r\n-    # Initializes the CodeQL tools for scanning.\r\n-    - name: Initialize CodeQL\r\n+      with:\n+        path: ~/.m2/repository\n+        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}\n+        restore-keys: |\n+          ${{ runner.os }}-maven-\n+\n+    # Initializes the CodeQL tools for scanning.\n+    - name: Initialize CodeQL\n       uses: github/codeql-action/init@b6a472f63d85b9c78a3ac5e89422239fc15e9b3c    # 3.28.1\n-      with:\r\n-        languages: ${{ matrix.language }}\r\n-        # If you wish to specify custom queries, you can do so here or in a config file.\r\n-        # By default, queries listed here will override any specified in a config file.\r\n-        # Prefix the list here with \"+\" to use these queries and those in the config file.\r\n-        # queries: ./path/to/local/query, your-org/your-repo/queries@main\r\n-\r\n-    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\r\n-    # If this step fails, then you should remove it and run the build manually (see below)\r\n-    - name: Autobuild\r\n+      with:\n+        languages: ${{ matrix.language }}\n+        # If you wish to specify custom queries, you can do so here or in a config file.\n+        # By default, queries listed here will override any specified in a config file.\n+        # Prefix the list here with \"+\" to use these queries and those in the config file.\n+        # queries: ./path/to/local/query, your-org/your-repo/queries@main\n+\n+    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n+    # If this step fails, then you should remove it and run the build manually (see below)\n+    - name: Autobuild\n       uses: github/codeql-action/autobuild@b6a472f63d85b9c78a3ac5e89422239fc15e9b3c    # 3.28.1\n-\r\n-    #  Command-line programs to run using the OS shell.\r\n-    #  https://git.io/JvXDl\r\n-\r\n-    #  If the Autobuild fails above, remove it and uncomment the following three lines\r\n-    #    and modify them (or add more) to build your code if your project\r\n-    #    uses a compiled language\r\n-\r\n-    #- run: |\r\n-    #   make bootstrap\r\n-    #   make release\r\n-\r\n-    - name: Perform CodeQL Analysis\r\n+\n+    #  Command-line programs to run using the OS shell.\n+    #  https://git.io/JvXDl\n+\n+    #  If the Autobuild fails above, remove it and uncomment the following three lines\n+    #    and modify them (or add more) to build your code if your project\n+    #    uses a compiled language\n+\n+    #- run: |\n+    #   make bootstrap\n+    #   make release\n+\n+    - name: Perform CodeQL Analysis\n       uses: github/codeql-action/analyze@b6a472f63d85b9c78a3ac5e89422239fc15e9b3c    # 3.28.1\n\ndiff --git a/.github/workflows/maven.yml b/.github/workflows/maven.yml\nindex 9aec002d..71887b86 100644\n--- a/.github/workflows/maven.yml\n+++ b/.github/workflows/maven.yml\n@@ -1,52 +1,52 @@\n-# Licensed to the Apache Software Foundation (ASF) under one or more\r\n-# contributor license agreements.  See the NOTICE file distributed with\r\n-# this work for additional information regarding copyright ownership.\r\n-# The ASF licenses this file to You under the Apache License, Version 2.0\r\n-# (the \"License\"); you may not use this file except in compliance with\r\n-# the License.  You may obtain a copy of the License at\r\n-#\r\n-#      http://www.apache.org/licenses/LICENSE-2.0\r\n-#\r\n-# Unless required by applicable law or agreed to in writing, software\r\n-# distributed under the License is distributed on an \"AS IS\" BASIS,\r\n-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n-# See the License for the specific language governing permissions and\r\n-# limitations under the License.\r\n-\r\n-name: Java CI\r\n-\r\n-on: [push, pull_request]\r\n-\r\n-permissions:\r\n-  contents: read\r\n-\r\n-jobs:\r\n-  build:\r\n-\r\n-    runs-on: ubuntu-latest\r\n-    continue-on-error: ${{ matrix.experimental }}\r\n-    strategy:\r\n-      matrix:\r\n-        java: [ 8, 11, 17, 21, 23 ]\r\n-        experimental: [false]\r\n-        include:\r\n-            - java: 24-ea\r\n-              experimental: true\r\n-        \r\n-    steps:\r\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+name: Java CI\n+\n+on: [push, pull_request]\n+\n+permissions:\n+  contents: read\n+\n+jobs:\n+  build:\n+\n+    runs-on: ubuntu-latest\n+    continue-on-error: ${{ matrix.experimental }}\n+    strategy:\n+      matrix:\n+        java: [ 8, 11, 17, 21, 23 ]\n+        experimental: [false]\n+        include:\n+            - java: 24-ea\n+              experimental: true\n+        \n+    steps:\n     - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # 4.2.2\n-      with:\r\n-        persist-credentials: false\r\n+      with:\n+        persist-credentials: false\n     - uses: actions/cache@1bd1e32a3bdc45362d1e726936510720a7c30a57 # v4.2.0\n-      with:\r\n-        path: ~/.m2/repository\r\n-        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}\r\n-        restore-keys: |\r\n-          ${{ runner.os }}-maven-\r\n-    - name: Set up JDK ${{ matrix.java }}\r\n+      with:\n+        path: ~/.m2/repository\n+        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}\n+        restore-keys: |\n+          ${{ runner.os }}-maven-\n+    - name: Set up JDK ${{ matrix.java }}\n       uses: actions/setup-java@7a6d8a8234af8eb26422e24e3006232cccaa061b # v4.6.0\n-      with:\r\n-        distribution: 'temurin'\r\n-        java-version: ${{ matrix.java }}\r\n-    - name: Build with Maven\r\n-      run: mvn -Ddoclint=all --show-version --batch-mode --no-transfer-progress\r\n+      with:\n+        distribution: 'temurin'\n+        java-version: ${{ matrix.java }}\n+    - name: Build with Maven\n+      run: mvn -Ddoclint=all --show-version --batch-mode --no-transfer-progress\n\ndiff --git a/src/assembly/bin.xml b/src/assembly/bin.xml\nindex 82301463..f73d62f6 100644\n--- a/src/assembly/bin.xml\n+++ b/src/assembly/bin.xml\n@@ -1,56 +1,56 @@\n-<!--\r\n-Licensed to the Apache Software Foundation (ASF) under one or more\r\n- contributor license agreements.  See the NOTICE file distributed with\r\n- this work for additional information regarding copyright ownership.\r\n- The ASF licenses this file to You under the Apache License, Version 2.0\r\n- (the \"License\"); you may not use this file except in compliance with\r\n- the License.  You may obtain a copy of the License at\r\n-\r\n-      http://www.apache.org/licenses/LICENSE-2.0\r\n-\r\n- Unless required by applicable law or agreed to in writing, software\r\n- distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- See the License for the specific language governing permissions and\r\n- limitations under the License.\r\n--->\r\n+<!--\n+Licensed to the Apache Software Foundation (ASF) under one or more\n+ contributor license agreements.  See the NOTICE file distributed with\n+ this work for additional information regarding copyright ownership.\n+ The ASF licenses this file to You under the Apache License, Version 2.0\n+ (the \"License\"); you may not use this file except in compliance with\n+ the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+-->\n <assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.2.0\"\n     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-    xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.2.0 https://maven.apache.org/xsd/assembly-2.2.0.xsd\">\r\n-    <id>bin</id>\r\n-    <formats>\r\n-        <format>tar.gz</format>\r\n-        <format>zip</format>\r\n-    </formats>\r\n-    <fileSets>\r\n-        <fileSet>\r\n-            <includes>\r\n-                <include>LICENSE.txt</include>\r\n-                <include>NOTICE.txt</include>\r\n-                <include>RELEASE-NOTES.txt</include>\r\n-            </includes>\r\n-        </fileSet>\r\n-        <fileSet>\r\n-            <directory>target</directory>\r\n-            <outputDirectory></outputDirectory>\r\n-            <includes>\r\n-                <include>${artifactId}-${version}.jar</include>\r\n-            </includes>\r\n-        </fileSet>\r\n-        <fileSet>\r\n-            <directory>target/site/apidocs</directory>\r\n-            <outputDirectory>apidocs</outputDirectory>\r\n-            <includes>\r\n-                <include>**/*</include>\r\n-            </includes>\r\n-        </fileSet>\r\n-        <!-- Include sources jar for IDEs -->\r\n-        <fileSet>\r\n-            <directory>target</directory>\r\n-            <outputDirectory></outputDirectory>\r\n-            <includes>\r\n-                <include>${artifactId}-${version}-sources.jar</include>\r\n-            </includes>\r\n-        </fileSet>\r\n-    </fileSets>\r\n-</assembly>\r\n+    xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.2.0 https://maven.apache.org/xsd/assembly-2.2.0.xsd\">\n+    <id>bin</id>\n+    <formats>\n+        <format>tar.gz</format>\n+        <format>zip</format>\n+    </formats>\n+    <fileSets>\n+        <fileSet>\n+            <includes>\n+                <include>LICENSE.txt</include>\n+                <include>NOTICE.txt</include>\n+                <include>RELEASE-NOTES.txt</include>\n+            </includes>\n+        </fileSet>\n+        <fileSet>\n+            <directory>target</directory>\n+            <outputDirectory></outputDirectory>\n+            <includes>\n+                <include>${artifactId}-${version}.jar</include>\n+            </includes>\n+        </fileSet>\n+        <fileSet>\n+            <directory>target/site/apidocs</directory>\n+            <outputDirectory>apidocs</outputDirectory>\n+            <includes>\n+                <include>**/*</include>\n+            </includes>\n+        </fileSet>\n+        <!-- Include sources jar for IDEs -->\n+        <fileSet>\n+            <directory>target</directory>\n+            <outputDirectory></outputDirectory>\n+            <includes>\n+                <include>${artifactId}-${version}-sources.jar</include>\n+            </includes>\n+        </fileSet>\n+    </fileSets>\n+</assembly>\n\ndiff --git a/src/assembly/src.xml b/src/assembly/src.xml\nindex 81955342..9f33f58f 100644\n--- a/src/assembly/src.xml\n+++ b/src/assembly/src.xml\n@@ -1,45 +1,45 @@\n-<!--\r\n-Licensed to the Apache Software Foundation (ASF) under one or more\r\n- contributor license agreements.  See the NOTICE file distributed with\r\n- this work for additional information regarding copyright ownership.\r\n- The ASF licenses this file to You under the Apache License, Version 2.0\r\n- (the \"License\"); you may not use this file except in compliance with\r\n- the License.  You may obtain a copy of the License at\r\n-\r\n-      http://www.apache.org/licenses/LICENSE-2.0\r\n-\r\n- Unless required by applicable law or agreed to in writing, software\r\n- distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- See the License for the specific language governing permissions and\r\n- limitations under the License.\r\n--->\r\n+<!--\n+Licensed to the Apache Software Foundation (ASF) under one or more\n+ contributor license agreements.  See the NOTICE file distributed with\n+ this work for additional information regarding copyright ownership.\n+ The ASF licenses this file to You under the Apache License, Version 2.0\n+ (the \"License\"); you may not use this file except in compliance with\n+ the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+-->\n <assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.2.0\"\n     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-    xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.2.0 https://maven.apache.org/xsd/assembly-2.2.0.xsd\">\r\n-  <id>src</id>\r\n-  <formats>\r\n-    <format>tar.gz</format>\r\n-    <format>zip</format>\r\n-  </formats>\r\n-  <baseDirectory>${artifactId}-${version}-src</baseDirectory>\r\n-  <fileSets>\r\n-    <fileSet>\r\n-      <includes>\r\n-        <include>LICENSE*</include>\r\n-        <include>NOTICE*</include>\r\n-        <include>RELEASE-NOTES.txt</include>\r\n-        <include>pom.xml</include>\r\n-        <include>findbugs-exclude-filter.xml</include>\r\n-        <include>checkstyle*.xml</include>\r\n-      </includes>\r\n-    </fileSet>\r\n-    <fileSet>\r\n-      <directory>src</directory>\r\n-      <excludes>\r\n-        <exclude>**/*Benchmark.java</exclude>\r\n-      </excludes>\r\n-    </fileSet>\r\n-  </fileSets>\r\n-</assembly>\r\n-\r\n+    xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.2.0 https://maven.apache.org/xsd/assembly-2.2.0.xsd\">\n+  <id>src</id>\n+  <formats>\n+    <format>tar.gz</format>\n+    <format>zip</format>\n+  </formats>\n+  <baseDirectory>${artifactId}-${version}-src</baseDirectory>\n+  <fileSets>\n+    <fileSet>\n+      <includes>\n+        <include>LICENSE*</include>\n+        <include>NOTICE*</include>\n+        <include>RELEASE-NOTES.txt</include>\n+        <include>pom.xml</include>\n+        <include>findbugs-exclude-filter.xml</include>\n+        <include>checkstyle*.xml</include>\n+      </includes>\n+    </fileSet>\n+    <fileSet>\n+      <directory>src</directory>\n+      <excludes>\n+        <exclude>**/*Benchmark.java</exclude>\n+      </excludes>\n+    </fileSet>\n+  </fileSets>\n+</assembly>\n+\n\ndiff --git a/src/changes/changes.xml b/src/changes/changes.xml\nindex b5359533..a05e5d52 100644\n--- a/src/changes/changes.xml\n+++ b/src/changes/changes.xml\n@@ -1,386 +1,386 @@\n-<?xml version=\"1.0\"?>\r\n-<!--\r\n-  Licensed to the Apache Software Foundation (ASF) under one or more\r\n-  contributor license agreements. See the NOTICE file distributed with\r\n-  this work for additional information regarding copyright ownership.\r\n-  The ASF licenses this file to You under the Apache License, Version 2.0\r\n-  (the \"License\"); you may not use this file except in compliance with\r\n-  the License. You may obtain a copy of the License at\r\n-\r\n-  http://www.apache.org/licenses/LICENSE-2.0\r\n-\r\n-  Unless required by applicable law or agreed to in writing, software\r\n-  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n-  See the License for the specific language governing permissions and\r\n-  limitations under the License.\r\n--->\r\n-\r\n-<!--\r\n-  This file is used by the maven-changes-plugin to generate the release notes.\r\n-  Useful ways of finding items to add to this file are:\r\n-\r\n-  1. Add items when you fix a bug or add a feature (this makes the\r\n-  release process easy :-).\r\n-\r\n-  2. Do a JIRA search for tickets closed since the previous release.\r\n-\r\n-  3. Use the report generated by the maven-changelog-plugin to see all\r\n-  SVN commits. Set the project.properties' maven.changelog.range\r\n-  property to the number of days since the last release.\r\n-\r\n-\r\n-  The <action> type attribute can be add,update,fix,remove.\r\n--->\r\n-\r\n-<document xmlns=\"http://maven.apache.org/changes/2.0.0\"\r\n-    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \r\n-    xsi:schemaLocation=\"http://maven.apache.org/changes/2.0.0 https://maven.apache.org/xsd/changes-2.0.0.xsd\">\r\n-  <properties>\r\n-    <title>Apache Commons CSV Release Notes</title>\r\n-  </properties>\r\n-  <body>\r\n-    <release version=\"1.13.1\" date=\"YYYY-MM-DD\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\r\n-      <!-- FIX -->\r\n-      <action type=\"fix\" issue=\"CSV-317\" dev=\"ggregory\" due-to=\"Filipe Roque\">Release history link changed from changes-report.html to changes.html #516.</action>\r\n-      <!-- ADD -->\r\n-      <!-- UPDATE -->\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump com.opencsv:opencsv from 5.9 to 5.10.</action>\r\n-    </release>\r\n-    <release version=\"1.13.0\" date=\"2025-01-08\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\r\n-      <!-- FIX -->\r\n-      <action type=\"fix\" issue=\"CSV-314\" dev=\"ggregory\" due-to=\"Gary Gregory\">Required OSGi Import-Package version numbers in MANIFEST.MF #504.</action>\r\n-      <action type=\"fix\" issue=\"CSV-314\" dev=\"ggregory\" due-to=\"Gary Gregory\">CSVParser.nextRecord() should throw CSVException (an IOException subclass) instead of IOException and IllegalStateException, no method signature changes needed.</action>\r\n-      <!-- ADD -->\r\n-      <action type=\"add\" issue=\"CSV-313\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add CSVPrinter.getRecordCount().</action>\r\n-      <action type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add and use CSVParser.Builder and builder() and deprecate CSVParser constructors.</action>\r\n-      <action type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">CSVFormat.Builder implements Supplier&lt;CSVFormat&gt;.</action>\r\n-      <action type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Deprecate CSVFormat.Builder.build() for get().</action>\r\n-      <action type=\"add\" issue=\"CSV-196\" dev=\"ggregory\" due-to=\"Yuzhan Jiang, Gary Gregory\">Track byte position #502.</action>\r\n-      <!-- UPDATE -->\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump org.apache.commons:commons-parent from 76 to 78 #486, #495.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump org.codehaus.mojo:taglist-maven-plugin from 3.1.0 to 3.2.1 #493.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump commons-io:commons-io from 2.17.0 to 2.18.0 #505.</action> \r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump commons-codec:commons-codec from 1.17.1 to 1.17.2.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.apache.commons:commons-parent from 78 to 79.</action>\r\n-    </release>\r\n-    <release version=\"1.12.0\" date=\"2024-09-21\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\r\n-      <!-- ADD -->\r\n-      <action type=\"add\" issue=\"CSV-270\" dev=\"ggregory\" due-to=\"Thomas Kamps, Gary Gregory\">Add CSVException that extends IOException thrown on invalid input instead of IOException.</action>\r\n-      <!-- FIX -->\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Fix PMD issues for port to PMD 7.1.0.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Dvid Szigecsn, Gary Gregory\">Fix some Javadoc links #442.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Dvid Szigecsn\">Extract duplicated code into a method #444.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Dvid Szigecsn\">Migrate CSVFormat#print(File, Charset) to NIO #445.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Dvid Szigecsn\">Fix documentation for CSVFormat private constructor #466.</action>\r\n-      <action type=\"fix\" issue=\"CSV-294\" dev=\"ggregory\" due-to=\"Joern Huxhorn, Gary Gregory\">CSVFormat does not support explicit \" as escape char.</action>\r\n-      <action type=\"fix\" issue=\"CSV-150\" dev=\"ggregory\" due-to=\"dota17, Gary Gregory, Jrn Huxhorn\">Escaping is not disableable.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Fix Javadoc warnings on Java 23.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Improve parser performance by up to 20%, YMMV.</action>\r\n-      <!-- UPDATE -->\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump commons-codec:commons-codec from 1.16.1 to 1.17.1 #422, #449.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.apache.commons:commons-parent from 69 to 76 #435, #452, #465, #468, #475, #482.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.codehaus.mojo:taglist-maven-plugin from 3.0.0 to 3.1.0 #441.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.apache.commons:commons-lang3 from 3.14.0 to 3.17.0 #450, #459, #470.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.hamcrest:hamcrest from 2.2 to 3.0 #455.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump commons-io:commons-io from 2.16.1 to 2.17.0 #476.</action>\r\n-    </release>\r\n-    <release version=\"1.11.0\" date=\"2024-04-28\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\r\n-      <!-- ADD -->\r\n-      <action issue=\"CSV-308\" type=\"add\" dev=\"ggregory\" due-to=\"Buddhi De Silva, Gary Gregory\">[Javadoc] Add example to CSVFormat#setHeaderComments() #344.</action>\r\n-      <action type=\"add\" dev=\"ggregory\" due-to=\"DamjanJovanovic, Gary Gregory\">Add and use CSVFormat#setTrailingData(boolean) in CSVFormat.EXCEL for Excel compatibility #303.</action>\r\n-      <action type=\"add\" dev=\"ggregory\" due-to=\"DamjanJovanovic, Gary Gregory\">Add and use CSVFormat#setLenientEof(boolean) in CSVFormat.EXCEL for Excel compatibility #303.</action>\r\n-      <!-- FIX -->\r\n-      <action type=\"fix\" issue=\"CSV-306\" dev=\"ggregory\" due-to=\"Sam Ng, Bruno P. Kinoshita\">Replace deprecated method in user guide, update external link #324, #325.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Seth Falco, Bruno P. Kinoshita\">Document duplicate header behavior #309.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"jkbkupczyk\">Add missing docs #328.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"step-security-bot\">[StepSecurity] CI: Harden GitHub Actions #329, #330.</action>\r\n-      <action type=\"fix\" issue=\"CSV-147\" dev=\"ggregory\" due-to=\"Steven Peterson, Benedikt Ritter, Gary Gregory, Joerg Schaible, Buddhi De Silva, Elliotte Rusty Harold\">Better error message during faulty CSV record read #347.</action>\r\n-      <action type=\"fix\" issue=\"CSV-310\" dev=\"ggregory\" due-to=\"Buddhi De Silva\">Misleading error message when QuoteMode set to None #352.</action>\r\n-      <action type=\"fix\" issue=\"CSV-311\" dev=\"ggregory\" due-to=\"Christian Feuersaenger, Gary Gregory\">OutOfMemory for very long rows despite using column value of type Reader.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Use try-with-resources to manage JDBC CLOB in CSVPrinter.printRecords(ResultSet).</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">JDBC Blob columns are now output as Base64 instead of Object#toString(), which usually is InputStream#toString().</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"DamjanJovanovic, Gary Gregory\">Support unusual Excel use cases: Add support for trailing data after the closing quote, and EOF without a final closing quote #303.</action>\r\n-      <action type=\"fix\" dev=\"ggregory\" due-to=\"Igor Kamyshnikov, Gary Gregory\">MongoDB CSV empty first column parsing fix #412.</action>\r\n-      <!-- UPDATE -->\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump commons-io:commons-io: from 2.11.0 to 2.16.1 #408, #413.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump commons-parent from 57 to 69 #410.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump h2 from 2.1.214 to 2.2.224 #333, #349, #359.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump commons-lang3 from 3.12.0 to 3.14.0.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Buddhi De Silva, Michael Osipov, Gary Gregory\">Update exception message in CSVRecord#getNextRecord() #348.</action>\r\n-      <action type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump tests using com.opencsv:opencsv from 5.8 to 5.9 #373.</action>\r\n-    </release>\r\n-    <release version=\"1.10.0\" date=\"2023-01-28\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\r\n-      <!-- FIX -->\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Minor changes #172.</action>\r\n-      <action issue=\"CSV-292\" type=\"fix\" dev=\"kinow\" due-to=\"Rob Vesse\">No Automatic-Module-Name prevents usage in JPMS projects without repacking the JAR.</action>\r\n-      <action issue=\"CSV-288\" type=\"fix\" dev=\"ggregory\" due-to=\"Santhsoh, Angus\">Fix for multi-char delimiter not working as expected #218.</action>\r\n-      <action issue=\"CSV-269\" type=\"fix\" dev=\"ggregory\" due-to=\"Auke te Winkel, Gary Gregory\">CSVRecord.get(Enum) should use Enum.name() instead of Enum.toString().</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Allow org.apache.commons.csv.IOUtils.copy(Reader, Appendable, CharBuffer) to compile on Java 11 and run on Java 8.</action>\r\n-      <action issue=\"CSV-300\" type=\"fix\" dev=\"ggregory\" due-to=\"Markus Spann, Gary Gregory\">CSVRecord.toList() does not give write access to the new List.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">CSVParser.getRecords() now throws UncheckedIOException instead of IOException.</action>\r\n-      <action issue=\"CSV-274\" type=\"fix\" dev=\"ggregory\" due-to=\"Peter Hull, Bruno P. Kinoshita, Gary Gregory\">Add comments to iterator() and stream() #270.</action>\r\n-      <action issue=\"CSV-290\" type=\"fix\" dev=\"ggregory\" due-to=\"angusdev, Gary Gregory\">Fix wrong assumptions in PostgreSQL formats #265.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Mykola Faryma\">Validate input to setDelimiter(String) for empty string #266.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Dependabot\">Bump CSVFormat#serialVersionUID from 1 to 2.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert\">CSVParser: Identify duplicates in null, empty and blank header names #279.</action>\r\n-      <!-- REMOVE -->\r\n-      <action                 type=\"remove\" dev=\"ggregory\">Serialization in CSVFormat is not supported from one version to the next.</action>\r\n-      <!-- ADD -->\r\n-      <action issue=\"CSV-291\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Make CSVRecord#values() public.</action>\r\n-      <action issue=\"CSV-264\" type=\"add\" dev=\"ggregory\" due-to=\"Sagar Tiwari, Seth Falco, Alex Herbert, Gary Gregory\">Add DuplicateHeaderMode for flexibility with header strictness. #114.</action>\r\n-      <action issue=\"CSV-295\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Support for parallelism in CSVPrinter.</action>\r\n-      <action issue=\"CSV-295\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add CSVPrinter.printRecord[s](Stream).</action>\r\n-      <action issue=\"CSV-304\" type=\"add\" dev=\"ggregory\" due-to=\"Peter Hull, Bruno P. Kinoshita, Gary Gregory\">Add accessors for header/trailer comments #257.</action>\r\n-      <action type=\"add\" dev=\"ggregory\">Add github/codeql-action.</action>\r\n-      <!-- UPDATE -->\r\n-      <action                 type=\"update\" dev=\"kinow\" due-to=\"Dependabot, Gary Gregory\">Bump actions/cache from 2.1.6 to 3.0.10 #196, #233, #243, #267, #271.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump actions/checkout from 2.3.4 to 3.1.0 #188, #195, #220, #272.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump actions/setup-java from 2 to 3.5.1.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump actions/upload-artifact from 3.1.0 to 3.1.1 #280.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump commons-parent from 52 to 57 #264, #288, #298, #323.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump checkstyle from 8.44 to 9.2.1 #180, #190, #194, #202, #207.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump junit-jupiter from 5.8.0-M1 to 5.9.1 #179, #186, #201, #244, #263.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump jmh-core from 1.32 to 1.36 #176, #208, #229, #285.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump jmh-generator-annprocess from 1.32 to 1.36 #175, #206, #226, #283.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump mockito-core from 3.11.2 to 4.11.0 #187, #197, #204, #212, #230, #237, #251, #259, #284, #292, #297.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump maven-pmd-plugin from 3.14.0 to 3.19.0 #184, #219, #238, #254, #258.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump pmd from 6.36.0 to 6.52.0 #173, #189, #193, #199, #227, #233, #214, #236, #240, #247, #255, #273.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump opencsv from 5.5.1 to 5.7.1 #182, #221, #260, #281.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump spotbugs-maven-plugin from 4.3.0 to 4.7.3.0 #192, #198, #203, #211, #225, #234, #242, #245, #261, #275, #282.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump com.github.spotbugs:spotbugs from 4.5.3 to 4.7.2.</action>\r\n-      <action                 type=\"update\" dev=\"kinow\" due-to=\"Dependabot\">Bump h2 from 1.4.200 to 2.1.214 #200, #205, #213, #239.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump maven-javadoc-plugin from 3.3.0 to 3.4.1.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump biz.aQute.bnd:biz.aQute.bndlib from 5.3.0 to 6.3.1.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump jacoco-maven-plugin from 0.8.7 to 0.8.8.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump japicmp-maven-plugin from 0.15.3 to 0.16.0.</action>\r\n-      <action                 type=\"update\" dev=\"kinow\" due-to=\"Dependabot\">Bump maven-checkstyle-plugin from 3.1.2 to 3.2.0 #253.</action>\r\n-    </release>\r\n-    <release version=\"1.9.0\" date=\"2021-07-24\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\r\n-      <!-- FIX -->\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Amey Jadiye\">Replace FindBugs with SpotBugs #56.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Javadoc typo in CSVFormat let's -> lets #57.</action>\r\n-      <action issue=\"CSV-259\" type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">CSVFormat.printWithEscapes throws StringIndexOutOfBoundsException when value is Reader #61.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Improve CSVFormat test coverage #63.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Fix CSVFileParserTest.java to allow for a null return value from record.getComment() #62.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Improve test coverage in CSVFormatTest #65.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Removed invalid Javadoc markup for CSVFormat EXCEL #64.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Improve CSVRecord and CSVPrinter code coverage #66.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Improve lexer and token coverage #67.</action>\r\n-      <action issue=\"CSV-211\" type=\"fix\" dev=\"ggregory\" due-to=\"Alpesh Kulkarni, Chen\">CSVFormat.format trims last delimiter if the delimiter is a white space #71.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Replace org.apache.commons.csv.Assertions.notNull() with Objects.requireNonNull().</action>\r\n-      <action issue=\"CSV-149\" type=\"fix\" dev=\"ggregory\" due-to=\"Kranthi, Gary Gregory, Brent Worden, dota17\">Line number is not proper at EOF.</action>\r\n-      <action issue=\"CSV-195\" type=\"fix\" dev=\"ggregory\" due-to=\"Rodolfo Duldulao, Rodolfo Duldulao, Michael Vitz, dota17\">Parser iterates over the last CSV Record twice.</action>\r\n-      <action issue=\"CSV-267\" type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Minor improvements #126, #127, #130.</action>\r\n-      <action issue=\"CSV-123\" type=\"fix\" dev=\"ggregory\" due-to=\"Emmanuel Bourg, Benedikt Ritter, shivakrishnaah, Gary Gregory\">Add possibility to use ResultSet header meta data as CSV header #11.</action>\r\n-      <action issue=\"CSV-148\" type=\"fix\" dev=\"ggregory\" due-to=\"dota17\">Add test cases for withIgnoreSurroundingSpaces() and withTrim() #70.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update CSVParser.parse(File, Charset, CSVFormat) from IO to NIO.</action>\r\n-      <action issue=\"CSV-271\" type=\"fix\" dev=\"ggregory\" due-to=\"Amar Prakash Pandey\">Missing separator with print(object) followed by printRecord(Object[]) #157.</action>\r\n-      <action issue=\"CSV-158\" type=\"fix\" dev=\"ggregory\" due-to=\"Alexander Bondarev, Benedikt Ritter, Gary Gregory, Chen\">Fix EOL checking for read array in ExtendedBufferedReader #5.</action>\r\n-      <action issue=\"CSV-263\" type=\"fix\" dev=\"ggregory\" due-to=\"Jason A. Guild, Gary Gregory\">Print from Reader with embedded quotes generates incorrect output #78.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Replace JUnit assert by simpler but equivalent calls. #159.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Seth Falco\">Update gitignore to ignore idea and vscode #160.</action>\r\n-      <action issue=\"CSV-281\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Update CSVBenchmark #165.</action>\r\n-      <action issue=\"CSV-283\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Remove Whitespace Check Determines Delimiter Twice #167.</action>\r\n-      <action issue=\"CSV-283\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Document and Automate CSV Benchmark Harness #166.</action>\r\n-      <action issue=\"CSV-279\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Optimize Lexer Delimiter Check for One Character Delimiter #163.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: org.apache.commons.csv.CSVParser.getHeaderNames() may expose internal representation by returning CSVParser.headerNames [org.apache.commons.csv.CSVParser] At CSVParser.java:[line 599] EI_EXPOSE_REP.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: new org.apache.commons.csv.CSVParser(Reader, CSVFormat, long, long) may expose internal representation by storing an externally mutable object into CSVParser.format [org.apache.commons.csv.CSVParser] At CSVParser.java:[line 433] EI_EXPOSE_REP2.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: new org.apache.commons.csv.CSVParser(Reader, CSVFormat, long, long) may expose internal representation by storing an externally mutable object into CSVParser.headerMap [org.apache.commons.csv.CSVParser] At CSVParser.java:[line 437] EI_EXPOSE_REP2.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: new org.apache.commons.csv.CSVParser(Reader, CSVFormat, long, long) may expose internal representation by storing an externally mutable object into CSVParser.headerNames [org.apache.commons.csv.CSVParser] At CSVParser.java:[line 438] EI_EXPOSE_REP2.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: new org.apache.commons.csv.CSVPrinter(Appendable, CSVFormat) may expose internal representation by storing an externally mutable object into CSVPrinter.format [org.apache.commons.csv.CSVPrinter] At CSVPrinter.java:[line 100] EI_EXPOSE_REP2.</action>\r\n-      <action issue=\"CSV-284\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Formalize PerformanceTest #168.</action>\r\n-      <action issue=\"CSV-278\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Reuse Buffers in Lexer for Delimiter Detection #162.</action>\r\n-      <action issue=\"CSV-286\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Cleanup and Document Performance Test Harness #170.</action>\r\n-      <action issue=\"CSV-265\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Update buffer position when reading line comment #120.</action>\r\n-      <!-- ADD -->\r\n-      <action issue=\"CSV-275\" type=\"add\" dev=\"ggregory\" due-to=\"Michael Wyraz, Gary Gregory\">Make CSVRecord#toList() public.</action>\r\n-      <action                 type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add CSVRecord#stream().</action>\r\n-      <action                 type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add CSVParser#stream().</action>\r\n-      <action issue=\"CSV-184\" type=\"add\" dev=\"ggregory\" due-to=\"Gaurav Agarwal, M. Steiger, Gary Gregory\">Make the method CSVRecord.putIn(Map) public.</action>\r\n-      <action                 type=\"add\" dev=\"ggregory\" due-to=\"dota17\">Add test cases for CSVRecord with get(Enum) and toString. #54.</action>\r\n-      <action                 type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, dota17\">Add and use CSVFormat.Builder, deprecated CSVFormat#with methods, based on #73.</action>\r\n-      <action issue=\"CSV-206\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, dota17\">Add support for String delimiters #76.</action>\r\n-      <!-- UPDATE -->\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update org.junit.jupiter:junit-jupiter from 5.6.0 to 5.7.0, #84 #109</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from Apache Commons Lang 3.9 to 3.12.0.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from commons-io:commons-io 2.6 to 2.11.0, #108.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump actions/checkout from v1 to v2.3.4, #79, #92, #121.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump commons-parent from 50 to 51 #80.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump tests from opencsv from 3.1 to 5.5.1 #81, #137, #158.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from super-csv from 2.2.1 to 2.4.0 #86.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump build actions/setup-java from v1.4.0 to v2, #101, #113.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump maven-pmd-plugin from 3.13.0 to 3.14.0 #122.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump tests from org.mockito:mockito-core 3.2.4 -> 3.11.2; #88, #107, #110, #123, #128, #129, #156.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump actions/cache from v2 to v2.1.6 #132, #153.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump maven-checkstyle-plugin from 3.0.0 to 3.1.2 #131.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump checkstyle from 8.29 to 8.44.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump junit-jupiter from 5.7.0 to 5.8.0-M1 #133, #149.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump commons.jacoco.version from 0.8.5 to 0.8.7 (Java 16).</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump commons.spotbugs.version from 4.0.4 to 4.3.0 (Java 16).</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump maven-javadoc-plugin from 3.2.0 to 3.3.0.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump jmh-generator-annprocess from 1.5.2 to 1.32 #151.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump PMD core from 6.29.0 to 6.36.0.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump biz.aQute.bnd:biz.aQute.bndlib from 5.1.2 to 5.3.0.</action>\r\n-    </release>\r\n-    <release version=\"1.8\" date=\"2020-02-01\" description=\"This is a feature and maintenance release. Java 8 or later is required.\r\n-\r\n-This release fixes serialization compatibility of CSVRecord with versions 1.0 to 1.6.\r\n-New fields added since 1.7 are not serialized. Support for Serializable is scheduled to be\r\n-removed in version 2.0.\r\n-\">\r\n-      <action issue=\"CSV-255\" type=\"add\" dev=\"ggregory\" due-to=\"0x100\">Add CSVRecord.isSet(int) method #52.</action>\r\n-      <action issue=\"CSV-135\" type=\"fix\" dev=\"sebb\" due-to=\"Mateusz Zakarczemny\">Char escape doesn't work properly with quoting.</action>\r\n-      <action issue=\"CSV-244\" type=\"fix\" dev=\"sebb\">Test case failures following CSVFormat#equals() update.</action>\r\n-      <action issue=\"CSV-243\" type=\"fix\" dev=\"sebb\">CSVFormat withTrim() and withIgnoreSurroundingSpaces() need better docs.</action>\r\n-      <action issue=\"CSV-242\" type=\"fix\" dev=\"sebb\">CSVFormat equals() and hashCode() don't use all fields.</action>\r\n-      <action issue=\"CSV-241\" type=\"fix\" dev=\"ggregory\" due-to=\"LuckyIlam, Gary Gregory\">CSVFormat#validate() does not account for allowDuplicateHeaderNames #43.</action>\r\n-      <action issue=\"CSV-245\" type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert\">Post 1.7 release fixes.</action>\r\n-      <action issue=\"CSV-252\" type=\"fix\" dev=\"ggregory\" due-to= \"Alex Herbert\">Upgrade test framework to JUnit 5 Jupiter #49, #50.</action>\r\n-      <action issue=\"CSV-247\" type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert, Gary Gregory\">A single empty header is allowed when not allowing empty column headers. #47.</action>\r\n-      <action issue=\"CSV-248\" type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert\">CSVRecord is not Serializable.</action>\r\n-      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert\">Use test scope for supercsv #48.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from H2 1.4.199 to 1.4.200.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from Hamcrest 2.1 to 2.2.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from Mockito 3.1.0 to 3.2.4.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Chen\">Fix typos in site and test #53.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Chen\">Fix typo performance test #55.</action>\r\n-    </release>\r\n-    <release version=\"1.7\" date=\"2019-06-01\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\r\n-      <action issue=\"CSV-233\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add predefined CSVFormats for printing MongoDB CSV and TSV.</action>\r\n-      <action issue=\"CSV-208\" type=\"fix\" dev=\"ggregory\" due-to=\"Jurrie Overgoor\">Fix escape character for POSTGRESQL_TEXT and POSTGRESQL_CSV formats.</action>\r\n-      <action issue=\"CSV-232\" type=\"fix\" dev=\"ggregory\" due-to=\"Jurrie Overgoor, Gary Gregory\">Site link \"Source Repository\" does not work.</action>\r\n-      <action issue=\"CSV-234\" type=\"add\" dev=\"ggregory\" due-to=\"Roberto Benedetti, Gary Gregory\">Add support for java.sql.Clob.</action>\r\n-      <action issue=\"CSV-237\" type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update to Java 8.</action>\r\n-      <action issue=\"CSV-238\" type=\"fix\" dev=\"ggregory\" due-to=\"Stephen Olander-Waters\">Escape quotes in CLOBs #39.</action>\r\n-      <action issue=\"CSV-239\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, Dave Moten\">Cannot get headers in column order from CSVRecord.</action>\r\n-      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from H2 1.4.198 to 1.4.199.</action>\r\n-    </release>\r\n-    <release version=\"1.6\" date=\"2018-09-22\" description=\"Feature and bug fix release (Java 7 or above)\">\r\n-      <action issue=\"CSV-231\" type=\"update\" dev=\"britter\">Add more documentation to CSVPrinter.</action>\r\n-      <action issue=\"CSV-217\" type=\"add\" dev=\"ggregory\" due-to=\"Korolyov Alexei\">Add autoFlush option for CsvPrinter. PR #24.</action>\r\n-      <action issue=\"CSV-219\" type=\"fix\" dev=\"ggregory\" due-to=\"Zhang Hongda\">The behavior of quote char using is not similar as Excel does when the first string contains CJK char(s).</action>\r\n-      <action issue=\"CSV-172\" type=\"fix\" dev=\"ggregory\" due-to=\"Andrew Pennebaker\">Don't quote cells just because they have UTF-8 encoded characters.</action>\r\n-      <action issue=\"CSV-220\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add API org.apache.commons.csv.CSVFormat.withSystemRecordSeparator().</action>\r\n-      <action issue=\"CSV-223\" type=\"fix\" dev=\"ggregory\" due-to=\"Samuel Martin\">Inconsistency between Javadoc of CSVFormat DEFAULT EXCEL.</action>\r\n-      <action issue=\"CSV-209\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Create CSVFormat.ORACLE preset.</action>\r\n-      <action issue=\"CSV-224\" type=\"fix\" dev=\"ggregory\" due-to=\"David Warshaw\">Some multi-iterator parsing peek sequences incorrectly consume elements.</action>\r\n-      <action issue=\"CSV-225\" type=\"fix\" dev=\"ggregory\" due-to=\"Anson Schwabecher\">Parse method should avoid creating a redundant BufferedReader.</action>\r\n-      <action issue=\"CSV-233\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add predefined CSVFormats for printing MongoDB CSV and TSV.</action>\r\n-    </release>\r\n-    <release version=\"1.5\" date=\"2017-09-03\" description=\"Feature and bug fix release (Java 7 or above)\">\r\n-      <action issue=\"CSV-203\" type=\"fix\" dev=\"ggregory\" due-to=\"Richard Wheeldon, Kai Paroth\">withNullString value is printed without quotes when QuoteMode.ALL is specified; add QuoteMode.ALL_NON_NULL. PR #17.</action>\r\n-      <action issue=\"CSV-194\" type=\"fix\" dev=\"ggregory\" due-to=\"Marc Prud'hommeaux\">Fix outdated comments about FileReader in CSVParser #13</action>\r\n-      <action issue=\"CSV-193\" type=\"fix\" dev=\"ggregory\" due-to=\"Matthias Wiehl\">Fix incorrect method name 'withFirstRowAsHeader' in user guide.</action>\r\n-      <action issue=\"CSV-171\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, Michael Graessle, Adrian Bridgett\">Negative numeric values in the first column are always quoted in minimal mode.</action>\r\n-      <action issue=\"CSV-187\" type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update platform requirement from Java 6 to 7.</action>\r\n-      <action issue=\"CSV-201\" type=\"update\" dev=\"ggregory\" due-to=\"Benedikt Ritter, Gary Gregory\">Do not use RuntimeException in CSVParser.iterator().new Iterator() {...}.getNextRecord()</action>\r\n-      <action issue=\"CSV-189\" type=\"add\" dev=\"ggregory\" due-to=\"Peter Holzwarth, Gary Gregory\">CSVParser: Add factory method accepting InputStream.</action>\r\n-      <action issue=\"CSV-190\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add convenience API CSVFormat.print(File, Charset)</action>\r\n-      <action issue=\"CSV-191\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add convenience API CSVFormat.print(Path, Charset)</action>\r\n-      <action issue=\"CSV-192\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add convenience API CSVParser.parse(Path, Charset, CSVFormat)</action>\r\n-      <action issue=\"CSV-205\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add convenience API CSVFormat#printer() to print to System.out</action>\r\n-      <action issue=\"CSV-207\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Provide a CSV Format for printing PostgreSQL CSV and Text formats.</action>\r\n-      <action issue=\"CSV-214\" type=\"add\" dev=\"ggregory\" due-to=\"Nitin Mahendru, Gary Gregory\">Adding a placeholder in the Lexer and CSV parser to store the end-of-line string.</action>\r\n-    </release>\r\n-    <release version=\"1.4\" date=\"2016-05-28\" description=\"Feature and bug fix release (Java 6 or above)\">\r\n-      <action issue=\"CSV-181\" type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Make CSVPrinter.print(Object) GC-free.</action>\r\n-      <action issue=\"CSV-182\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Allow some printing operations directly from CSVFormat.</action>\r\n-      <action issue=\"CSV-183\" type=\"update\" dev=\"ggregory\">Drop ferc.gov tests.</action>\r\n-    </release>\r\n-    <release version=\"1.3\" date=\"2016-05-09\" description=\"Feature and bug fix release (Java 6 or above)\">\r\n-      <action issue=\"CSV-179\" type=\"add\" dev=\"britter\">Add shortcut method for using first record as header to CSVFormat</action>\r\n-      <action issue=\"CSV-180\" type=\"add\" dev=\"britter\">Add withHeader(Class&lt;? extends Enum&gt;) to CSVFormat</action>\r\n-      <action issue=\"CSV-167\" type=\"update\" dev=\"sebb\" due-to=\"Rene\">Comment line hides next record; update Javadoc to make behavior clear</action>\r\n-      <action issue=\"CSV-153\" type=\"update\" dev=\"britter\" due-to=\"Wren\">CSVPrinter doesn't skip creation of header record if skipHeaderRecord is set to true</action>\r\n-      <action issue=\"CSV-159\" type=\"add\" dev=\"ggregory\" due-to=\"Yamil Medina\">Add IgnoreCase option for accessing header names</action>\r\n-      <action issue=\"CSV-169\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">The null string should be case-sensitive when reading records</action>\r\n-      <action issue=\"CSV-168\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, cornel creanga\">CSVFormat.nullString should not be escaped</action>\r\n-      <action issue=\"CSV-170\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, cornel creanga\">CSVFormat.MYSQL nullString should be \"\\N\"</action>\r\n-      <action issue=\"CSV-161\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, Kristof Meixner, Emmanuel Bourg\">Fix Javadoc to say CSVFormat with() methods return a new CSVFormat</action>\r\n-      <action issue=\"CSV-175\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, Chris Jones\">Support for ignoring trailing delimiter.</action>\r\n-      <action issue=\"CSV-177\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Support trimming leading and trailing blanks.</action>\r\n-      <action issue=\"CSV-178\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Create default formats for Informix UNLOAD and UNLOAD CSV.</action>\r\n-    </release>\r\n-    <release version=\"1.2\" date=\"2015-08-24\" description=\"Feature and bug fix release (Java 6 or above)\">\r\n-      <action issue=\"CSV-145\" type=\"fix\" dev=\"ggregory\" due-to=\"Frank Ulbricht\">CSVFormat.with* methods clear the header comments</action>\r\n-      <action issue=\"CSV-156\" type=\"fix\" dev=\"ggregory\" due-to=\"Jason Steenstra-Pickens\">Incorrect Javadoc on QuoteMode.NONE</action>\r\n-      <action issue=\"CSV-157\" type=\"add\" dev=\"ggregory\">Add enum CSVFormat.Predefined that contains the default CSVFormat values.</action>\r\n-    </release>\r\n-    <release version=\"1.1\" date=\"2014-11-16\" description=\"Feature and bug fix release (Java 6 or above)\">\r\n-      <action issue=\"CSV-140\" type=\"fix\" dev=\"ggregory\" due-to=\"Damjan Jovanovic\">QuoteMode.NON_NUMERIC doesn't work with CSVPrinter.printRecords(ResultSet)</action>\r\n-      <action issue=\"CSV-130\" type=\"fix\" dev=\"ggregory\" due-to=\"Sergei Lebedev\">CSVFormat#withHeader doesn't work well with #printComment, add withHeaderComments(String...)</action>\r\n-      <action issue=\"CSV-128\" type=\"fix\" dev=\"ggregory\">CSVFormat.EXCEL should ignore empty header names</action>\r\n-      <action issue=\"CSV-132\" type=\"fix\" dev=\"ggregory\" due-to=\"Sascha Szott\">Incorrect Javadoc referencing org.apache.commons.csv.CSVFormat withQuote()</action>\r\n-      <action issue=\"CSV-124\" type=\"update\" dev=\"brentworden\" due-to=\"Kalyan\">Improve toString() implementation of CSVRecord</action>\r\n-      <action issue=\"CSV-134\" type=\"update\" dev=\"ggregory\" due-to=\"wu wen\">Unified parameter validation</action>\r\n-      <action issue=\"CSV-129\" type=\"add\" dev=\"ggregory\">Add CSVFormat#with 0-arg methods matching boolean arg methods</action>\r\n-      <action issue=\"CSV-131\" type=\"add\" dev=\"ggregory\" due-to=\"Holger Stratmann\">Save positions of records to enable random access</action>\r\n-      <action issue=\"CSV-139\" type=\"add\" dev=\"ggregory\">CSVPrinter.printRecord(ResultSet) with metadata</action>\r\n-    </release>\r\n-    <release version=\"1.0\" date=\"2014-08-14\" description=\"First release (Java 6 or above)\">\r\n-      <action issue=\"CSV-125\" type=\"fix\" dev=\"britter\">No longer works with Java 6</action>\r\n-      <action issue=\"CSV-122\" type=\"fix\" dev=\"britter\" due-to=\"Mike Lewis\">NullPointerException when empty header string and null string of \"\"</action>\r\n-      <action issue=\"CSV-117\" type=\"update\" dev=\"sebb\">Validate format parameters in constructor</action>\r\n-      <action issue=\"CSV-121\" type=\"add\" dev=\"ggregory\" due-to=\"Sebastian Hardt\">IllegalArgumentException thrown when the header contains duplicate names when the column names are empty.</action>\r\n-      <action issue=\"CSV-120\" type=\"add\" dev=\"ggregory\" due-to=\"Sergei Lebedev\">CSVFormat#withHeader doesn't work with CSVPrinter</action>\r\n-      <action issue=\"CSV-119\" type=\"add\" dev=\"ggregory\" due-to=\"Sergei Lebedev\">CSVFormat is missing a print(...) method</action>\r\n-      <action issue=\"CSV-118\" type=\"fix\" dev=\"ggregory\" due-to=\"Enrique Lara\">CSVRecord.toMap() throws NPE on formats with no\r\n-        headers.</action>\r\n-      <action issue=\"CSV-113\" type=\"fix\" dev=\"sebb\">Check whether ISE/IAE are being used appropriately</action>\r\n-      <action issue=\"CSV-114\" type=\"fix\" dev=\"sebb\">CSVFormat constructor should reject a header array with duplicate\r\n-        entries\r\n-      </action>\r\n-      <action issue=\"CSV-112\" type=\"fix\" dev=\"britter\">HeaderMap is inconsistent when it is parsed from an input with\r\n-        duplicate columns names\r\n-      </action>\r\n-      <action issue=\"CSV-111\" type=\"fix\" dev=\"ggregory\">CSVRecord.toMap() fails if row length shorter than header length\r\n-      </action>\r\n-      <action issue=\"CSV-106\" type=\"fix\" dev=\"ggregory\">CSVFormat.format allways append null</action>\r\n-      <action issue=\"CSV-105\" type=\"add\" dev=\"ggregory\">Add Map conversion API to CSVRecord</action>\r\n-      <action issue=\"CSV-100\" type=\"fix\" dev=\"ggregory\">CSVParser: getHeaderMap throws NPE</action>\r\n-      <action issue=\"CSV-42\" type=\"update\" dev=\"ebourg\" due-to=\"Bob Smith\">Lots of possible changes</action>\r\n-      <action issue=\"CSV-78\" type=\"update\" dev=\"sebb\">Use Character instead of char for char fields except delimiter\r\n-      </action>\r\n-      <action issue=\"CSV-99\" type=\"update\" dev=\"britter\">Revert Builder implementation in CSVFormat</action>\r\n-      <action issue=\"CSV-53\" type=\"fix\" dev=\"britter\">CSVRecord does not verify that the length of the header mapping\r\n-        matches the number of values\r\n-      </action>\r\n-      <action issue=\"CSV-93\" type=\"update\" dev=\"ggregory\">Allow the handling of NULL values</action>\r\n-      <action issue=\"CSV-68\" type=\"update\" dev=\"ggregory\">Use the Builder pattern for CSVFormat</action>\r\n-      <action issue=\"CSV-84\" type=\"update\" dev=\"sebb\">Clarify comment handling</action>\r\n-      <action issue=\"CSV-25\" type=\"update\" dev=\"ebourg\">CSVParser.nextValue() seems pointless</action>\r\n-      <action issue=\"CSV-97\" type=\"update\" dev=\"ggregory\">Allow the String value for null to be customized for the CSV\r\n-        printer\r\n-      </action>\r\n-      <action issue=\"CSV-88\" type=\"update\" dev=\"ggregory\">Not possible to create a CSVFormat from scratch</action>\r\n-      <action issue=\"CSV-52\" type=\"add\" dev=\"ggregory\">Keep track of record number</action>\r\n-      <action issue=\"CSV-94\" type=\"update\" dev=\"sebb\">Lexer should only use char fields</action>\r\n-      <action issue=\"CSV-92\" type=\"add\" dev=\"ggregory\">Need a way to extract parsed headers, e.g. for use in formatting\r\n-        output\r\n-      </action>\r\n-      <action issue=\"CSV-65\" type=\"add\" dev=\"ebourg\">Header support</action>\r\n-      <action issue=\"CSV-54\" type=\"fix\" dev=\"sebb\">Confusing semantic of the ignore leading/trailing spaces parameters\r\n-      </action>\r\n-      <action issue=\"CSV-71\" type=\"update\" dev=\"sebb\">Add convenience methods to CSVLexer</action>\r\n-      <action issue=\"CSV-59\" type=\"update\" dev=\"ebourg\">Is CharBuffer really needed, now that StringBuilder is available?\r\n-      </action>\r\n-      <action issue=\"CSV-55\" type=\"update\" dev=\"britter\">Replace while(true)-loop in CSVParser.getRecord with do-while-loop\r\n-      </action>\r\n-      <action issue=\"CSV-34\" type=\"fix\" dev=\"sebb\">CSVFormat describes itself as immutable, but it is not - in\r\n-        particular it is not thread-safe\r\n-      </action>\r\n-      <action issue=\"CSV-36\" type=\"fix\" dev=\"yonik\">Endless loops in CSV parser</action>\r\n-      <action issue=\"CSV-13\" type=\"fix\" dev=\"ebourg\">NullPointerException in CSVPrinter.print()/println()</action>\r\n-      <action issue=\"CSV-45\" type=\"update\" dev=\"yonik\">CSVPrinter overhaul</action>\r\n-      <action issue=\"CSV-23\" type=\"fix\" dev=\"ebourg\">Excel strategy uses wrong separator</action>\r\n-      <action issue=\"CSV-49\" type=\"update\" dev=\"ebourg\" due-to=\"Bob Smith\">CSVStrategy has modifiable public static variables\r\n-      </action>\r\n-      <action issue=\"CSV-48\" type=\"add\" dev=\"ebourg\">Predefined format for MYSQL</action>\r\n-      <action issue=\"CSV-46\" type=\"update\" dev=\"ebourg\">Reduce visibility of methods in internal classes</action>\r\n-      <action issue=\"CSV-26\" type=\"update\" dev=\"jacopoc\">ExtendedBufferedReader does too much</action>\r\n-      <action issue=\"CSV-27\" type=\"update\" dev=\"ebourg\">Decide whether to keep the csv.writer subpackage</action>\r\n-    </release>\r\n-\r\n-  </body>\r\n-</document>\r\n+<?xml version=\"1.0\"?>\n+<!--\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements. See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License. You may obtain a copy of the License at\n+\n+  http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+-->\n+\n+<!--\n+  This file is used by the maven-changes-plugin to generate the release notes.\n+  Useful ways of finding items to add to this file are:\n+\n+  1. Add items when you fix a bug or add a feature (this makes the\n+  release process easy :-).\n+\n+  2. Do a JIRA search for tickets closed since the previous release.\n+\n+  3. Use the report generated by the maven-changelog-plugin to see all\n+  SVN commits. Set the project.properties' maven.changelog.range\n+  property to the number of days since the last release.\n+\n+\n+  The <action> type attribute can be add,update,fix,remove.\n+-->\n+\n+<document xmlns=\"http://maven.apache.org/changes/2.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n+    xsi:schemaLocation=\"http://maven.apache.org/changes/2.0.0 https://maven.apache.org/xsd/changes-2.0.0.xsd\">\n+  <properties>\n+    <title>Apache Commons CSV Release Notes</title>\n+  </properties>\n+  <body>\n+    <release version=\"1.13.1\" date=\"YYYY-MM-DD\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\n+      <!-- FIX -->\n+      <action type=\"fix\" issue=\"CSV-317\" dev=\"ggregory\" due-to=\"Filipe Roque\">Release history link changed from changes-report.html to changes.html #516.</action>\n+      <!-- ADD -->\n+      <!-- UPDATE -->\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump com.opencsv:opencsv from 5.9 to 5.10.</action>\n+    </release>\n+    <release version=\"1.13.0\" date=\"2025-01-08\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\n+      <!-- FIX -->\n+      <action type=\"fix\" issue=\"CSV-314\" dev=\"ggregory\" due-to=\"Gary Gregory\">Required OSGi Import-Package version numbers in MANIFEST.MF #504.</action>\n+      <action type=\"fix\" issue=\"CSV-314\" dev=\"ggregory\" due-to=\"Gary Gregory\">CSVParser.nextRecord() should throw CSVException (an IOException subclass) instead of IOException and IllegalStateException, no method signature changes needed.</action>\n+      <!-- ADD -->\n+      <action type=\"add\" issue=\"CSV-313\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add CSVPrinter.getRecordCount().</action>\n+      <action type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add and use CSVParser.Builder and builder() and deprecate CSVParser constructors.</action>\n+      <action type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">CSVFormat.Builder implements Supplier&lt;CSVFormat&gt;.</action>\n+      <action type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Deprecate CSVFormat.Builder.build() for get().</action>\n+      <action type=\"add\" issue=\"CSV-196\" dev=\"ggregory\" due-to=\"Yuzhan Jiang, Gary Gregory\">Track byte position #502.</action>\n+      <!-- UPDATE -->\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump org.apache.commons:commons-parent from 76 to 78 #486, #495.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump org.codehaus.mojo:taglist-maven-plugin from 3.1.0 to 3.2.1 #493.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump commons-io:commons-io from 2.17.0 to 2.18.0 #505.</action> \n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump commons-codec:commons-codec from 1.17.1 to 1.17.2.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.apache.commons:commons-parent from 78 to 79.</action>\n+    </release>\n+    <release version=\"1.12.0\" date=\"2024-09-21\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\n+      <!-- ADD -->\n+      <action type=\"add\" issue=\"CSV-270\" dev=\"ggregory\" due-to=\"Thomas Kamps, Gary Gregory\">Add CSVException that extends IOException thrown on invalid input instead of IOException.</action>\n+      <!-- FIX -->\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Fix PMD issues for port to PMD 7.1.0.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Dvid Szigecsn, Gary Gregory\">Fix some Javadoc links #442.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Dvid Szigecsn\">Extract duplicated code into a method #444.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Dvid Szigecsn\">Migrate CSVFormat#print(File, Charset) to NIO #445.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Dvid Szigecsn\">Fix documentation for CSVFormat private constructor #466.</action>\n+      <action type=\"fix\" issue=\"CSV-294\" dev=\"ggregory\" due-to=\"Joern Huxhorn, Gary Gregory\">CSVFormat does not support explicit \" as escape char.</action>\n+      <action type=\"fix\" issue=\"CSV-150\" dev=\"ggregory\" due-to=\"dota17, Gary Gregory, Jrn Huxhorn\">Escaping is not disableable.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Fix Javadoc warnings on Java 23.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Improve parser performance by up to 20%, YMMV.</action>\n+      <!-- UPDATE -->\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump commons-codec:commons-codec from 1.16.1 to 1.17.1 #422, #449.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.apache.commons:commons-parent from 69 to 76 #435, #452, #465, #468, #475, #482.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.codehaus.mojo:taglist-maven-plugin from 3.0.0 to 3.1.0 #441.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.apache.commons:commons-lang3 from 3.14.0 to 3.17.0 #450, #459, #470.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump org.hamcrest:hamcrest from 2.2 to 3.0 #455.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump commons-io:commons-io from 2.16.1 to 2.17.0 #476.</action>\n+    </release>\n+    <release version=\"1.11.0\" date=\"2024-04-28\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\n+      <!-- ADD -->\n+      <action issue=\"CSV-308\" type=\"add\" dev=\"ggregory\" due-to=\"Buddhi De Silva, Gary Gregory\">[Javadoc] Add example to CSVFormat#setHeaderComments() #344.</action>\n+      <action type=\"add\" dev=\"ggregory\" due-to=\"DamjanJovanovic, Gary Gregory\">Add and use CSVFormat#setTrailingData(boolean) in CSVFormat.EXCEL for Excel compatibility #303.</action>\n+      <action type=\"add\" dev=\"ggregory\" due-to=\"DamjanJovanovic, Gary Gregory\">Add and use CSVFormat#setLenientEof(boolean) in CSVFormat.EXCEL for Excel compatibility #303.</action>\n+      <!-- FIX -->\n+      <action type=\"fix\" issue=\"CSV-306\" dev=\"ggregory\" due-to=\"Sam Ng, Bruno P. Kinoshita\">Replace deprecated method in user guide, update external link #324, #325.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Seth Falco, Bruno P. Kinoshita\">Document duplicate header behavior #309.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"jkbkupczyk\">Add missing docs #328.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"step-security-bot\">[StepSecurity] CI: Harden GitHub Actions #329, #330.</action>\n+      <action type=\"fix\" issue=\"CSV-147\" dev=\"ggregory\" due-to=\"Steven Peterson, Benedikt Ritter, Gary Gregory, Joerg Schaible, Buddhi De Silva, Elliotte Rusty Harold\">Better error message during faulty CSV record read #347.</action>\n+      <action type=\"fix\" issue=\"CSV-310\" dev=\"ggregory\" due-to=\"Buddhi De Silva\">Misleading error message when QuoteMode set to None #352.</action>\n+      <action type=\"fix\" issue=\"CSV-311\" dev=\"ggregory\" due-to=\"Christian Feuersaenger, Gary Gregory\">OutOfMemory for very long rows despite using column value of type Reader.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Use try-with-resources to manage JDBC CLOB in CSVPrinter.printRecords(ResultSet).</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">JDBC Blob columns are now output as Base64 instead of Object#toString(), which usually is InputStream#toString().</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"DamjanJovanovic, Gary Gregory\">Support unusual Excel use cases: Add support for trailing data after the closing quote, and EOF without a final closing quote #303.</action>\n+      <action type=\"fix\" dev=\"ggregory\" due-to=\"Igor Kamyshnikov, Gary Gregory\">MongoDB CSV empty first column parsing fix #412.</action>\n+      <!-- UPDATE -->\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump commons-io:commons-io: from 2.11.0 to 2.16.1 #408, #413.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump commons-parent from 57 to 69 #410.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump h2 from 2.1.214 to 2.2.224 #333, #349, #359.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump commons-lang3 from 3.12.0 to 3.14.0.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Buddhi De Silva, Michael Osipov, Gary Gregory\">Update exception message in CSVRecord#getNextRecord() #348.</action>\n+      <action type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump tests using com.opencsv:opencsv from 5.8 to 5.9 #373.</action>\n+    </release>\n+    <release version=\"1.10.0\" date=\"2023-01-28\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\n+      <!-- FIX -->\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Minor changes #172.</action>\n+      <action issue=\"CSV-292\" type=\"fix\" dev=\"kinow\" due-to=\"Rob Vesse\">No Automatic-Module-Name prevents usage in JPMS projects without repacking the JAR.</action>\n+      <action issue=\"CSV-288\" type=\"fix\" dev=\"ggregory\" due-to=\"Santhsoh, Angus\">Fix for multi-char delimiter not working as expected #218.</action>\n+      <action issue=\"CSV-269\" type=\"fix\" dev=\"ggregory\" due-to=\"Auke te Winkel, Gary Gregory\">CSVRecord.get(Enum) should use Enum.name() instead of Enum.toString().</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Allow org.apache.commons.csv.IOUtils.copy(Reader, Appendable, CharBuffer) to compile on Java 11 and run on Java 8.</action>\n+      <action issue=\"CSV-300\" type=\"fix\" dev=\"ggregory\" due-to=\"Markus Spann, Gary Gregory\">CSVRecord.toList() does not give write access to the new List.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">CSVParser.getRecords() now throws UncheckedIOException instead of IOException.</action>\n+      <action issue=\"CSV-274\" type=\"fix\" dev=\"ggregory\" due-to=\"Peter Hull, Bruno P. Kinoshita, Gary Gregory\">Add comments to iterator() and stream() #270.</action>\n+      <action issue=\"CSV-290\" type=\"fix\" dev=\"ggregory\" due-to=\"angusdev, Gary Gregory\">Fix wrong assumptions in PostgreSQL formats #265.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Mykola Faryma\">Validate input to setDelimiter(String) for empty string #266.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Dependabot\">Bump CSVFormat#serialVersionUID from 1 to 2.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert\">CSVParser: Identify duplicates in null, empty and blank header names #279.</action>\n+      <!-- REMOVE -->\n+      <action                 type=\"remove\" dev=\"ggregory\">Serialization in CSVFormat is not supported from one version to the next.</action>\n+      <!-- ADD -->\n+      <action issue=\"CSV-291\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Make CSVRecord#values() public.</action>\n+      <action issue=\"CSV-264\" type=\"add\" dev=\"ggregory\" due-to=\"Sagar Tiwari, Seth Falco, Alex Herbert, Gary Gregory\">Add DuplicateHeaderMode for flexibility with header strictness. #114.</action>\n+      <action issue=\"CSV-295\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Support for parallelism in CSVPrinter.</action>\n+      <action issue=\"CSV-295\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add CSVPrinter.printRecord[s](Stream).</action>\n+      <action issue=\"CSV-304\" type=\"add\" dev=\"ggregory\" due-to=\"Peter Hull, Bruno P. Kinoshita, Gary Gregory\">Add accessors for header/trailer comments #257.</action>\n+      <action type=\"add\" dev=\"ggregory\">Add github/codeql-action.</action>\n+      <!-- UPDATE -->\n+      <action                 type=\"update\" dev=\"kinow\" due-to=\"Dependabot, Gary Gregory\">Bump actions/cache from 2.1.6 to 3.0.10 #196, #233, #243, #267, #271.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump actions/checkout from 2.3.4 to 3.1.0 #188, #195, #220, #272.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump actions/setup-java from 2 to 3.5.1.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump actions/upload-artifact from 3.1.0 to 3.1.1 #280.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump commons-parent from 52 to 57 #264, #288, #298, #323.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump checkstyle from 8.44 to 9.2.1 #180, #190, #194, #202, #207.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump junit-jupiter from 5.8.0-M1 to 5.9.1 #179, #186, #201, #244, #263.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump jmh-core from 1.32 to 1.36 #176, #208, #229, #285.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump jmh-generator-annprocess from 1.32 to 1.36 #175, #206, #226, #283.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump mockito-core from 3.11.2 to 4.11.0 #187, #197, #204, #212, #230, #237, #251, #259, #284, #292, #297.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump maven-pmd-plugin from 3.14.0 to 3.19.0 #184, #219, #238, #254, #258.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump pmd from 6.36.0 to 6.52.0 #173, #189, #193, #199, #227, #233, #214, #236, #240, #247, #255, #273.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump opencsv from 5.5.1 to 5.7.1 #182, #221, #260, #281.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump spotbugs-maven-plugin from 4.3.0 to 4.7.3.0 #192, #198, #203, #211, #225, #234, #242, #245, #261, #275, #282.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump com.github.spotbugs:spotbugs from 4.5.3 to 4.7.2.</action>\n+      <action                 type=\"update\" dev=\"kinow\" due-to=\"Dependabot\">Bump h2 from 1.4.200 to 2.1.214 #200, #205, #213, #239.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump maven-javadoc-plugin from 3.3.0 to 3.4.1.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump biz.aQute.bnd:biz.aQute.bndlib from 5.3.0 to 6.3.1.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump jacoco-maven-plugin from 0.8.7 to 0.8.8.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump japicmp-maven-plugin from 0.15.3 to 0.16.0.</action>\n+      <action                 type=\"update\" dev=\"kinow\" due-to=\"Dependabot\">Bump maven-checkstyle-plugin from 3.1.2 to 3.2.0 #253.</action>\n+    </release>\n+    <release version=\"1.9.0\" date=\"2021-07-24\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\n+      <!-- FIX -->\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Amey Jadiye\">Replace FindBugs with SpotBugs #56.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Javadoc typo in CSVFormat let's -> lets #57.</action>\n+      <action issue=\"CSV-259\" type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">CSVFormat.printWithEscapes throws StringIndexOutOfBoundsException when value is Reader #61.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Improve CSVFormat test coverage #63.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Fix CSVFileParserTest.java to allow for a null return value from record.getComment() #62.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Improve test coverage in CSVFormatTest #65.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Removed invalid Javadoc markup for CSVFormat EXCEL #64.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Improve CSVRecord and CSVPrinter code coverage #66.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Chen\">Improve lexer and token coverage #67.</action>\n+      <action issue=\"CSV-211\" type=\"fix\" dev=\"ggregory\" due-to=\"Alpesh Kulkarni, Chen\">CSVFormat.format trims last delimiter if the delimiter is a white space #71.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Replace org.apache.commons.csv.Assertions.notNull() with Objects.requireNonNull().</action>\n+      <action issue=\"CSV-149\" type=\"fix\" dev=\"ggregory\" due-to=\"Kranthi, Gary Gregory, Brent Worden, dota17\">Line number is not proper at EOF.</action>\n+      <action issue=\"CSV-195\" type=\"fix\" dev=\"ggregory\" due-to=\"Rodolfo Duldulao, Rodolfo Duldulao, Michael Vitz, dota17\">Parser iterates over the last CSV Record twice.</action>\n+      <action issue=\"CSV-267\" type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Minor improvements #126, #127, #130.</action>\n+      <action issue=\"CSV-123\" type=\"fix\" dev=\"ggregory\" due-to=\"Emmanuel Bourg, Benedikt Ritter, shivakrishnaah, Gary Gregory\">Add possibility to use ResultSet header meta data as CSV header #11.</action>\n+      <action issue=\"CSV-148\" type=\"fix\" dev=\"ggregory\" due-to=\"dota17\">Add test cases for withIgnoreSurroundingSpaces() and withTrim() #70.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update CSVParser.parse(File, Charset, CSVFormat) from IO to NIO.</action>\n+      <action issue=\"CSV-271\" type=\"fix\" dev=\"ggregory\" due-to=\"Amar Prakash Pandey\">Missing separator with print(object) followed by printRecord(Object[]) #157.</action>\n+      <action issue=\"CSV-158\" type=\"fix\" dev=\"ggregory\" due-to=\"Alexander Bondarev, Benedikt Ritter, Gary Gregory, Chen\">Fix EOL checking for read array in ExtendedBufferedReader #5.</action>\n+      <action issue=\"CSV-263\" type=\"fix\" dev=\"ggregory\" due-to=\"Jason A. Guild, Gary Gregory\">Print from Reader with embedded quotes generates incorrect output #78.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Replace JUnit assert by simpler but equivalent calls. #159.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Seth Falco\">Update gitignore to ignore idea and vscode #160.</action>\n+      <action issue=\"CSV-281\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Update CSVBenchmark #165.</action>\n+      <action issue=\"CSV-283\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Remove Whitespace Check Determines Delimiter Twice #167.</action>\n+      <action issue=\"CSV-283\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Document and Automate CSV Benchmark Harness #166.</action>\n+      <action issue=\"CSV-279\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Optimize Lexer Delimiter Check for One Character Delimiter #163.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: org.apache.commons.csv.CSVParser.getHeaderNames() may expose internal representation by returning CSVParser.headerNames [org.apache.commons.csv.CSVParser] At CSVParser.java:[line 599] EI_EXPOSE_REP.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: new org.apache.commons.csv.CSVParser(Reader, CSVFormat, long, long) may expose internal representation by storing an externally mutable object into CSVParser.format [org.apache.commons.csv.CSVParser] At CSVParser.java:[line 433] EI_EXPOSE_REP2.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: new org.apache.commons.csv.CSVParser(Reader, CSVFormat, long, long) may expose internal representation by storing an externally mutable object into CSVParser.headerMap [org.apache.commons.csv.CSVParser] At CSVParser.java:[line 437] EI_EXPOSE_REP2.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: new org.apache.commons.csv.CSVParser(Reader, CSVFormat, long, long) may expose internal representation by storing an externally mutable object into CSVParser.headerNames [org.apache.commons.csv.CSVParser] At CSVParser.java:[line 438] EI_EXPOSE_REP2.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">SpotBugs Error: Medium: new org.apache.commons.csv.CSVPrinter(Appendable, CSVFormat) may expose internal representation by storing an externally mutable object into CSVPrinter.format [org.apache.commons.csv.CSVPrinter] At CSVPrinter.java:[line 100] EI_EXPOSE_REP2.</action>\n+      <action issue=\"CSV-284\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Formalize PerformanceTest #168.</action>\n+      <action issue=\"CSV-278\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Reuse Buffers in Lexer for Delimiter Detection #162.</action>\n+      <action issue=\"CSV-286\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Cleanup and Document Performance Test Harness #170.</action>\n+      <action issue=\"CSV-265\" type=\"fix\" dev=\"ggregory\" due-to=\"belugabehr\">Update buffer position when reading line comment #120.</action>\n+      <!-- ADD -->\n+      <action issue=\"CSV-275\" type=\"add\" dev=\"ggregory\" due-to=\"Michael Wyraz, Gary Gregory\">Make CSVRecord#toList() public.</action>\n+      <action                 type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add CSVRecord#stream().</action>\n+      <action                 type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add CSVParser#stream().</action>\n+      <action issue=\"CSV-184\" type=\"add\" dev=\"ggregory\" due-to=\"Gaurav Agarwal, M. Steiger, Gary Gregory\">Make the method CSVRecord.putIn(Map) public.</action>\n+      <action                 type=\"add\" dev=\"ggregory\" due-to=\"dota17\">Add test cases for CSVRecord with get(Enum) and toString. #54.</action>\n+      <action                 type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, dota17\">Add and use CSVFormat.Builder, deprecated CSVFormat#with methods, based on #73.</action>\n+      <action issue=\"CSV-206\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, dota17\">Add support for String delimiters #76.</action>\n+      <!-- UPDATE -->\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update org.junit.jupiter:junit-jupiter from 5.6.0 to 5.7.0, #84 #109</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from Apache Commons Lang 3.9 to 3.12.0.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from commons-io:commons-io 2.6 to 2.11.0, #108.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump actions/checkout from v1 to v2.3.4, #79, #92, #121.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump commons-parent from 50 to 51 #80.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump tests from opencsv from 3.1 to 5.5.1 #81, #137, #158.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from super-csv from 2.2.1 to 2.4.0 #86.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump build actions/setup-java from v1.4.0 to v2, #101, #113.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump maven-pmd-plugin from 3.13.0 to 3.14.0 #122.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump tests from org.mockito:mockito-core 3.2.4 -> 3.11.2; #88, #107, #110, #123, #128, #129, #156.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump actions/cache from v2 to v2.1.6 #132, #153.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, Dependabot\">Bump maven-checkstyle-plugin from 3.0.0 to 3.1.2 #131.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump checkstyle from 8.29 to 8.44.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot, Gary Gregory\">Bump junit-jupiter from 5.7.0 to 5.8.0-M1 #133, #149.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump commons.jacoco.version from 0.8.5 to 0.8.7 (Java 16).</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump commons.spotbugs.version from 4.0.4 to 4.3.0 (Java 16).</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Bump maven-javadoc-plugin from 3.2.0 to 3.3.0.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump jmh-generator-annprocess from 1.5.2 to 1.32 #151.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump PMD core from 6.29.0 to 6.36.0.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump biz.aQute.bnd:biz.aQute.bndlib from 5.1.2 to 5.3.0.</action>\n+    </release>\n+    <release version=\"1.8\" date=\"2020-02-01\" description=\"This is a feature and maintenance release. Java 8 or later is required.\n+\n+This release fixes serialization compatibility of CSVRecord with versions 1.0 to 1.6.\n+New fields added since 1.7 are not serialized. Support for Serializable is scheduled to be\n+removed in version 2.0.\n+\">\n+      <action issue=\"CSV-255\" type=\"add\" dev=\"ggregory\" due-to=\"0x100\">Add CSVRecord.isSet(int) method #52.</action>\n+      <action issue=\"CSV-135\" type=\"fix\" dev=\"sebb\" due-to=\"Mateusz Zakarczemny\">Char escape doesn't work properly with quoting.</action>\n+      <action issue=\"CSV-244\" type=\"fix\" dev=\"sebb\">Test case failures following CSVFormat#equals() update.</action>\n+      <action issue=\"CSV-243\" type=\"fix\" dev=\"sebb\">CSVFormat withTrim() and withIgnoreSurroundingSpaces() need better docs.</action>\n+      <action issue=\"CSV-242\" type=\"fix\" dev=\"sebb\">CSVFormat equals() and hashCode() don't use all fields.</action>\n+      <action issue=\"CSV-241\" type=\"fix\" dev=\"ggregory\" due-to=\"LuckyIlam, Gary Gregory\">CSVFormat#validate() does not account for allowDuplicateHeaderNames #43.</action>\n+      <action issue=\"CSV-245\" type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert\">Post 1.7 release fixes.</action>\n+      <action issue=\"CSV-252\" type=\"fix\" dev=\"ggregory\" due-to= \"Alex Herbert\">Upgrade test framework to JUnit 5 Jupiter #49, #50.</action>\n+      <action issue=\"CSV-247\" type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert, Gary Gregory\">A single empty header is allowed when not allowing empty column headers. #47.</action>\n+      <action issue=\"CSV-248\" type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert\">CSVRecord is not Serializable.</action>\n+      <action                 type=\"fix\" dev=\"ggregory\" due-to=\"Alex Herbert\">Use test scope for supercsv #48.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from H2 1.4.199 to 1.4.200.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from Hamcrest 2.1 to 2.2.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from Mockito 3.1.0 to 3.2.4.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Chen\">Fix typos in site and test #53.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Chen\">Fix typo performance test #55.</action>\n+    </release>\n+    <release version=\"1.7\" date=\"2019-06-01\" description=\"This is a feature and maintenance release. Java 8 or later is required.\">\n+      <action issue=\"CSV-233\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add predefined CSVFormats for printing MongoDB CSV and TSV.</action>\n+      <action issue=\"CSV-208\" type=\"fix\" dev=\"ggregory\" due-to=\"Jurrie Overgoor\">Fix escape character for POSTGRESQL_TEXT and POSTGRESQL_CSV formats.</action>\n+      <action issue=\"CSV-232\" type=\"fix\" dev=\"ggregory\" due-to=\"Jurrie Overgoor, Gary Gregory\">Site link \"Source Repository\" does not work.</action>\n+      <action issue=\"CSV-234\" type=\"add\" dev=\"ggregory\" due-to=\"Roberto Benedetti, Gary Gregory\">Add support for java.sql.Clob.</action>\n+      <action issue=\"CSV-237\" type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update to Java 8.</action>\n+      <action issue=\"CSV-238\" type=\"fix\" dev=\"ggregory\" due-to=\"Stephen Olander-Waters\">Escape quotes in CLOBs #39.</action>\n+      <action issue=\"CSV-239\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, Dave Moten\">Cannot get headers in column order from CSVRecord.</action>\n+      <action                 type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update tests from H2 1.4.198 to 1.4.199.</action>\n+    </release>\n+    <release version=\"1.6\" date=\"2018-09-22\" description=\"Feature and bug fix release (Java 7 or above)\">\n+      <action issue=\"CSV-231\" type=\"update\" dev=\"britter\">Add more documentation to CSVPrinter.</action>\n+      <action issue=\"CSV-217\" type=\"add\" dev=\"ggregory\" due-to=\"Korolyov Alexei\">Add autoFlush option for CsvPrinter. PR #24.</action>\n+      <action issue=\"CSV-219\" type=\"fix\" dev=\"ggregory\" due-to=\"Zhang Hongda\">The behavior of quote char using is not similar as Excel does when the first string contains CJK char(s).</action>\n+      <action issue=\"CSV-172\" type=\"fix\" dev=\"ggregory\" due-to=\"Andrew Pennebaker\">Don't quote cells just because they have UTF-8 encoded characters.</action>\n+      <action issue=\"CSV-220\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add API org.apache.commons.csv.CSVFormat.withSystemRecordSeparator().</action>\n+      <action issue=\"CSV-223\" type=\"fix\" dev=\"ggregory\" due-to=\"Samuel Martin\">Inconsistency between Javadoc of CSVFormat DEFAULT EXCEL.</action>\n+      <action issue=\"CSV-209\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Create CSVFormat.ORACLE preset.</action>\n+      <action issue=\"CSV-224\" type=\"fix\" dev=\"ggregory\" due-to=\"David Warshaw\">Some multi-iterator parsing peek sequences incorrectly consume elements.</action>\n+      <action issue=\"CSV-225\" type=\"fix\" dev=\"ggregory\" due-to=\"Anson Schwabecher\">Parse method should avoid creating a redundant BufferedReader.</action>\n+      <action issue=\"CSV-233\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add predefined CSVFormats for printing MongoDB CSV and TSV.</action>\n+    </release>\n+    <release version=\"1.5\" date=\"2017-09-03\" description=\"Feature and bug fix release (Java 7 or above)\">\n+      <action issue=\"CSV-203\" type=\"fix\" dev=\"ggregory\" due-to=\"Richard Wheeldon, Kai Paroth\">withNullString value is printed without quotes when QuoteMode.ALL is specified; add QuoteMode.ALL_NON_NULL. PR #17.</action>\n+      <action issue=\"CSV-194\" type=\"fix\" dev=\"ggregory\" due-to=\"Marc Prud'hommeaux\">Fix outdated comments about FileReader in CSVParser #13</action>\n+      <action issue=\"CSV-193\" type=\"fix\" dev=\"ggregory\" due-to=\"Matthias Wiehl\">Fix incorrect method name 'withFirstRowAsHeader' in user guide.</action>\n+      <action issue=\"CSV-171\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, Michael Graessle, Adrian Bridgett\">Negative numeric values in the first column are always quoted in minimal mode.</action>\n+      <action issue=\"CSV-187\" type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update platform requirement from Java 6 to 7.</action>\n+      <action issue=\"CSV-201\" type=\"update\" dev=\"ggregory\" due-to=\"Benedikt Ritter, Gary Gregory\">Do not use RuntimeException in CSVParser.iterator().new Iterator() {...}.getNextRecord()</action>\n+      <action issue=\"CSV-189\" type=\"add\" dev=\"ggregory\" due-to=\"Peter Holzwarth, Gary Gregory\">CSVParser: Add factory method accepting InputStream.</action>\n+      <action issue=\"CSV-190\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add convenience API CSVFormat.print(File, Charset)</action>\n+      <action issue=\"CSV-191\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add convenience API CSVFormat.print(Path, Charset)</action>\n+      <action issue=\"CSV-192\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add convenience API CSVParser.parse(Path, Charset, CSVFormat)</action>\n+      <action issue=\"CSV-205\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add convenience API CSVFormat#printer() to print to System.out</action>\n+      <action issue=\"CSV-207\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Provide a CSV Format for printing PostgreSQL CSV and Text formats.</action>\n+      <action issue=\"CSV-214\" type=\"add\" dev=\"ggregory\" due-to=\"Nitin Mahendru, Gary Gregory\">Adding a placeholder in the Lexer and CSV parser to store the end-of-line string.</action>\n+    </release>\n+    <release version=\"1.4\" date=\"2016-05-28\" description=\"Feature and bug fix release (Java 6 or above)\">\n+      <action issue=\"CSV-181\" type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Make CSVPrinter.print(Object) GC-free.</action>\n+      <action issue=\"CSV-182\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Allow some printing operations directly from CSVFormat.</action>\n+      <action issue=\"CSV-183\" type=\"update\" dev=\"ggregory\">Drop ferc.gov tests.</action>\n+    </release>\n+    <release version=\"1.3\" date=\"2016-05-09\" description=\"Feature and bug fix release (Java 6 or above)\">\n+      <action issue=\"CSV-179\" type=\"add\" dev=\"britter\">Add shortcut method for using first record as header to CSVFormat</action>\n+      <action issue=\"CSV-180\" type=\"add\" dev=\"britter\">Add withHeader(Class&lt;? extends Enum&gt;) to CSVFormat</action>\n+      <action issue=\"CSV-167\" type=\"update\" dev=\"sebb\" due-to=\"Rene\">Comment line hides next record; update Javadoc to make behavior clear</action>\n+      <action issue=\"CSV-153\" type=\"update\" dev=\"britter\" due-to=\"Wren\">CSVPrinter doesn't skip creation of header record if skipHeaderRecord is set to true</action>\n+      <action issue=\"CSV-159\" type=\"add\" dev=\"ggregory\" due-to=\"Yamil Medina\">Add IgnoreCase option for accessing header names</action>\n+      <action issue=\"CSV-169\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">The null string should be case-sensitive when reading records</action>\n+      <action issue=\"CSV-168\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, cornel creanga\">CSVFormat.nullString should not be escaped</action>\n+      <action issue=\"CSV-170\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, cornel creanga\">CSVFormat.MYSQL nullString should be \"\\N\"</action>\n+      <action issue=\"CSV-161\" type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory, Kristof Meixner, Emmanuel Bourg\">Fix Javadoc to say CSVFormat with() methods return a new CSVFormat</action>\n+      <action issue=\"CSV-175\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, Chris Jones\">Support for ignoring trailing delimiter.</action>\n+      <action issue=\"CSV-177\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Support trimming leading and trailing blanks.</action>\n+      <action issue=\"CSV-178\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Create default formats for Informix UNLOAD and UNLOAD CSV.</action>\n+    </release>\n+    <release version=\"1.2\" date=\"2015-08-24\" description=\"Feature and bug fix release (Java 6 or above)\">\n+      <action issue=\"CSV-145\" type=\"fix\" dev=\"ggregory\" due-to=\"Frank Ulbricht\">CSVFormat.with* methods clear the header comments</action>\n+      <action issue=\"CSV-156\" type=\"fix\" dev=\"ggregory\" due-to=\"Jason Steenstra-Pickens\">Incorrect Javadoc on QuoteMode.NONE</action>\n+      <action issue=\"CSV-157\" type=\"add\" dev=\"ggregory\">Add enum CSVFormat.Predefined that contains the default CSVFormat values.</action>\n+    </release>\n+    <release version=\"1.1\" date=\"2014-11-16\" description=\"Feature and bug fix release (Java 6 or above)\">\n+      <action issue=\"CSV-140\" type=\"fix\" dev=\"ggregory\" due-to=\"Damjan Jovanovic\">QuoteMode.NON_NUMERIC doesn't work with CSVPrinter.printRecords(ResultSet)</action>\n+      <action issue=\"CSV-130\" type=\"fix\" dev=\"ggregory\" due-to=\"Sergei Lebedev\">CSVFormat#withHeader doesn't work well with #printComment, add withHeaderComments(String...)</action>\n+      <action issue=\"CSV-128\" type=\"fix\" dev=\"ggregory\">CSVFormat.EXCEL should ignore empty header names</action>\n+      <action issue=\"CSV-132\" type=\"fix\" dev=\"ggregory\" due-to=\"Sascha Szott\">Incorrect Javadoc referencing org.apache.commons.csv.CSVFormat withQuote()</action>\n+      <action issue=\"CSV-124\" type=\"update\" dev=\"brentworden\" due-to=\"Kalyan\">Improve toString() implementation of CSVRecord</action>\n+      <action issue=\"CSV-134\" type=\"update\" dev=\"ggregory\" due-to=\"wu wen\">Unified parameter validation</action>\n+      <action issue=\"CSV-129\" type=\"add\" dev=\"ggregory\">Add CSVFormat#with 0-arg methods matching boolean arg methods</action>\n+      <action issue=\"CSV-131\" type=\"add\" dev=\"ggregory\" due-to=\"Holger Stratmann\">Save positions of records to enable random access</action>\n+      <action issue=\"CSV-139\" type=\"add\" dev=\"ggregory\">CSVPrinter.printRecord(ResultSet) with metadata</action>\n+    </release>\n+    <release version=\"1.0\" date=\"2014-08-14\" description=\"First release (Java 6 or above)\">\n+      <action issue=\"CSV-125\" type=\"fix\" dev=\"britter\">No longer works with Java 6</action>\n+      <action issue=\"CSV-122\" type=\"fix\" dev=\"britter\" due-to=\"Mike Lewis\">NullPointerException when empty header string and null string of \"\"</action>\n+      <action issue=\"CSV-117\" type=\"update\" dev=\"sebb\">Validate format parameters in constructor</action>\n+      <action issue=\"CSV-121\" type=\"add\" dev=\"ggregory\" due-to=\"Sebastian Hardt\">IllegalArgumentException thrown when the header contains duplicate names when the column names are empty.</action>\n+      <action issue=\"CSV-120\" type=\"add\" dev=\"ggregory\" due-to=\"Sergei Lebedev\">CSVFormat#withHeader doesn't work with CSVPrinter</action>\n+      <action issue=\"CSV-119\" type=\"add\" dev=\"ggregory\" due-to=\"Sergei Lebedev\">CSVFormat is missing a print(...) method</action>\n+      <action issue=\"CSV-118\" type=\"fix\" dev=\"ggregory\" due-to=\"Enrique Lara\">CSVRecord.toMap() throws NPE on formats with no\n+        headers.</action>\n+      <action issue=\"CSV-113\" type=\"fix\" dev=\"sebb\">Check whether ISE/IAE are being used appropriately</action>\n+      <action issue=\"CSV-114\" type=\"fix\" dev=\"sebb\">CSVFormat constructor should reject a header array with duplicate\n+        entries\n+      </action>\n+      <action issue=\"CSV-112\" type=\"fix\" dev=\"britter\">HeaderMap is inconsistent when it is parsed from an input with\n+        duplicate columns names\n+      </action>\n+      <action issue=\"CSV-111\" type=\"fix\" dev=\"ggregory\">CSVRecord.toMap() fails if row length shorter than header length\n+      </action>\n+      <action issue=\"CSV-106\" type=\"fix\" dev=\"ggregory\">CSVFormat.format allways append null</action>\n+      <action issue=\"CSV-105\" type=\"add\" dev=\"ggregory\">Add Map conversion API to CSVRecord</action>\n+      <action issue=\"CSV-100\" type=\"fix\" dev=\"ggregory\">CSVParser: getHeaderMap throws NPE</action>\n+      <action issue=\"CSV-42\" type=\"update\" dev=\"ebourg\" due-to=\"Bob Smith\">Lots of possible changes</action>\n+      <action issue=\"CSV-78\" type=\"update\" dev=\"sebb\">Use Character instead of char for char fields except delimiter\n+      </action>\n+      <action issue=\"CSV-99\" type=\"update\" dev=\"britter\">Revert Builder implementation in CSVFormat</action>\n+      <action issue=\"CSV-53\" type=\"fix\" dev=\"britter\">CSVRecord does not verify that the length of the header mapping\n+        matches the number of values\n+      </action>\n+      <action issue=\"CSV-93\" type=\"update\" dev=\"ggregory\">Allow the handling of NULL values</action>\n+      <action issue=\"CSV-68\" type=\"update\" dev=\"ggregory\">Use the Builder pattern for CSVFormat</action>\n+      <action issue=\"CSV-84\" type=\"update\" dev=\"sebb\">Clarify comment handling</action>\n+      <action issue=\"CSV-25\" type=\"update\" dev=\"ebourg\">CSVParser.nextValue() seems pointless</action>\n+      <action issue=\"CSV-97\" type=\"update\" dev=\"ggregory\">Allow the String value for null to be customized for the CSV\n+        printer\n+      </action>\n+      <action issue=\"CSV-88\" type=\"update\" dev=\"ggregory\">Not possible to create a CSVFormat from scratch</action>\n+      <action issue=\"CSV-52\" type=\"add\" dev=\"ggregory\">Keep track of record number</action>\n+      <action issue=\"CSV-94\" type=\"update\" dev=\"sebb\">Lexer should only use char fields</action>\n+      <action issue=\"CSV-92\" type=\"add\" dev=\"ggregory\">Need a way to extract parsed headers, e.g. for use in formatting\n+        output\n+      </action>\n+      <action issue=\"CSV-65\" type=\"add\" dev=\"ebourg\">Header support</action>\n+      <action issue=\"CSV-54\" type=\"fix\" dev=\"sebb\">Confusing semantic of the ignore leading/trailing spaces parameters\n+      </action>\n+      <action issue=\"CSV-71\" type=\"update\" dev=\"sebb\">Add convenience methods to CSVLexer</action>\n+      <action issue=\"CSV-59\" type=\"update\" dev=\"ebourg\">Is CharBuffer really needed, now that StringBuilder is available?\n+      </action>\n+      <action issue=\"CSV-55\" type=\"update\" dev=\"britter\">Replace while(true)-loop in CSVParser.getRecord with do-while-loop\n+      </action>\n+      <action issue=\"CSV-34\" type=\"fix\" dev=\"sebb\">CSVFormat describes itself as immutable, but it is not - in\n+        particular it is not thread-safe\n+      </action>\n+      <action issue=\"CSV-36\" type=\"fix\" dev=\"yonik\">Endless loops in CSV parser</action>\n+      <action issue=\"CSV-13\" type=\"fix\" dev=\"ebourg\">NullPointerException in CSVPrinter.print()/println()</action>\n+      <action issue=\"CSV-45\" type=\"update\" dev=\"yonik\">CSVPrinter overhaul</action>\n+      <action issue=\"CSV-23\" type=\"fix\" dev=\"ebourg\">Excel strategy uses wrong separator</action>\n+      <action issue=\"CSV-49\" type=\"update\" dev=\"ebourg\" due-to=\"Bob Smith\">CSVStrategy has modifiable public static variables\n+      </action>\n+      <action issue=\"CSV-48\" type=\"add\" dev=\"ebourg\">Predefined format for MYSQL</action>\n+      <action issue=\"CSV-46\" type=\"update\" dev=\"ebourg\">Reduce visibility of methods in internal classes</action>\n+      <action issue=\"CSV-26\" type=\"update\" dev=\"jacopoc\">ExtendedBufferedReader does too much</action>\n+      <action issue=\"CSV-27\" type=\"update\" dev=\"ebourg\">Decide whether to keep the csv.writer subpackage</action>\n+    </release>\n+\n+  </body>\n+</document>\n\ndiff --git a/src/main/java/org/apache/commons/csv/CSVPrinter.java b/src/main/java/org/apache/commons/csv/CSVPrinter.java\nindex dce94692..67088c38 100644\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n@@ -1,520 +1,520 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv;\r\n-\r\n-import static org.apache.commons.csv.Constants.CR;\r\n-import static org.apache.commons.csv.Constants.LF;\r\n-import static org.apache.commons.csv.Constants.SP;\r\n-\r\n-import java.io.Closeable;\r\n-import java.io.Flushable;\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.Reader;\r\n-import java.sql.Blob;\r\n-import java.sql.Clob;\r\n-import java.sql.ResultSet;\r\n-import java.sql.SQLException;\r\n-import java.util.Arrays;\r\n-import java.util.Objects;\r\n-import java.util.stream.Stream;\r\n-\r\n-import org.apache.commons.io.function.IOStream;\r\n-\r\n-/**\r\n- * Prints values in a {@link CSVFormat CSV format}.\r\n- *\r\n- * <p>Values can be appended to the output by calling the {@link #print(Object)} method.\r\n- * Values are printed according to {@link String#valueOf(Object)}.\r\n- * To complete a record the {@link #println()} method has to be called.\r\n- * Comments can be appended by calling {@link #printComment(String)}.\r\n- * However a comment will only be written to the output if the {@link CSVFormat} supports comments.\r\n- * </p>\r\n- *\r\n- * <p>The printer also supports appending a complete record at once by calling {@link #printRecord(Object...)}\r\n- * or {@link #printRecord(Iterable)}.\r\n- * Furthermore {@link #printRecords(Object...)}, {@link #printRecords(Iterable)} and {@link #printRecords(ResultSet)}\r\n- * methods can be used to print several records at once.\r\n- * </p>\r\n- *\r\n- * <p>Example:</p>\r\n- *\r\n- * <pre>\r\n- * try (CSVPrinter printer = new CSVPrinter(new FileWriter(\"csv.txt\"), CSVFormat.EXCEL)) {\r\n- *     printer.printRecord(\"id\", \"userName\", \"firstName\", \"lastName\", \"birthday\");\r\n- *     printer.printRecord(1, \"john73\", \"John\", \"Doe\", LocalDate.of(1973, 9, 15));\r\n- *     printer.println();\r\n- *     printer.printRecord(2, \"mary\", \"Mary\", \"Meyer\", LocalDate.of(1985, 3, 29));\r\n- * } catch (IOException ex) {\r\n- *     ex.printStackTrace();\r\n- * }\r\n- * </pre>\r\n- *\r\n- * <p>This code will write the following to csv.txt:</p>\r\n- * <pre>\r\n- * id,userName,firstName,lastName,birthday\r\n- * 1,john73,John,Doe,1973-09-15\r\n- *\r\n- * 2,mary,Mary,Meyer,1985-03-29\r\n- * </pre>\r\n- */\r\n-public final class CSVPrinter implements Flushable, Closeable {\r\n-\r\n-    /** The place that the values get written. */\r\n-    private final Appendable appendable;\r\n-\r\n-    private final CSVFormat format;\r\n-\r\n-    /** True if we just began a new record. */\r\n-    private boolean newRecord = true;\r\n-\r\n-    private long recordCount;\r\n-\r\n-    /**\r\n-     * Creates a printer that will print values to the given stream following the CSVFormat.\r\n-     * <p>\r\n-     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\r\n-     * and escaping with a different character) are not supported.\r\n-     * </p>\r\n-     *\r\n-     * @param appendable\r\n-     *            stream to which to print. Must not be null.\r\n-     * @param format\r\n-     *            the CSV format. Must not be null.\r\n-     * @throws IOException\r\n-     *             thrown if the optional header cannot be printed.\r\n-     * @throws IllegalArgumentException\r\n-     *             thrown if the parameters of the format are inconsistent or if either out or format are null.\r\n-     */\r\n-    public CSVPrinter(final Appendable appendable, final CSVFormat format) throws IOException {\r\n-        Objects.requireNonNull(appendable, \"appendable\");\r\n-        Objects.requireNonNull(format, \"format\");\r\n-\r\n-        this.appendable = appendable;\r\n-        this.format = format.copy();\r\n-        // TODO: Is it a good idea to do this here instead of on the first call to a print method?\r\n-        // It seems a pain to have to track whether the header has already been printed or not.\r\n-        final String[] headerComments = format.getHeaderComments();\r\n-        if (headerComments != null) {\r\n-            for (final String line : headerComments) {\r\n-                printComment(line);\r\n-            }\r\n-        }\r\n-        if (format.getHeader() != null && !format.getSkipHeaderRecord()) {\r\n-            this.printRecord((Object[]) format.getHeader());\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void close() throws IOException {\r\n-        close(false);\r\n-    }\r\n-\r\n-    /**\r\n-     * Closes the underlying stream with an optional flush first.\r\n-     * @param flush whether to flush before the actual close.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     * @since 1.6\r\n-     */\r\n-    public void close(final boolean flush) throws IOException {\r\n-        if (flush || format.getAutoFlush()) {\r\n-            flush();\r\n-        }\r\n-        if (appendable instanceof Closeable) {\r\n-            ((Closeable) appendable).close();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Outputs the record separator and increments the record count.\r\n-     *\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    private synchronized void endOfRecord() throws IOException {\r\n-        println();\r\n-        recordCount++;\r\n-    }\r\n-\r\n-    /**\r\n-     * Flushes the underlying stream.\r\n-     *\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    @Override\r\n-    public void flush() throws IOException {\r\n-        if (appendable instanceof Flushable) {\r\n-            ((Flushable) appendable).flush();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Gets the target Appendable.\r\n-     *\r\n-     * @return the target Appendable.\r\n-     */\r\n-    public Appendable getOut() {\r\n-        return this.appendable;\r\n-    }\r\n-\r\n-    /**\r\n-     * Gets the record count printed, this does not include comments or headers.\r\n-     *\r\n-     * @return the record count, this does not include comments or headers.\r\n-     * @since 1.13.0\r\n-     */\r\n-    public long getRecordCount() {\r\n-        return recordCount;\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\r\n-     *\r\n-     * @param value\r\n-     *            value to be output.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    public synchronized void print(final Object value) throws IOException {\r\n-        format.print(value, appendable, newRecord);\r\n-        newRecord = false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints a comment on a new line among the delimiter-separated values.\r\n-     *\r\n-     * <p>\r\n-     * Comments will always begin on a new line and occupy at least one full line. The character specified to start\r\n-     * comments and a space will be inserted at the beginning of each new line in the comment.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If comments are disabled in the current CSV format this method does nothing.\r\n-     * </p>\r\n-     *\r\n-     * <p>This method detects line breaks inside the comment string and inserts {@link CSVFormat#getRecordSeparator()}\r\n-     * to start a new line of the comment. Note that this might produce unexpected results for formats that do not use\r\n-     * line breaks as record separators.</p>\r\n-     *\r\n-     * @param comment\r\n-     *            the comment to output\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    public synchronized void printComment(final String comment) throws IOException {\r\n-        if (comment == null || !format.isCommentMarkerSet()) {\r\n-            return;\r\n-        }\r\n-        if (!newRecord) {\r\n-            println();\r\n-        }\r\n-        appendable.append(format.getCommentMarker().charValue()); // N.B. Explicit (un)boxing is intentional\r\n-        appendable.append(SP);\r\n-        for (int i = 0; i < comment.length(); i++) {\r\n-            final char c = comment.charAt(i);\r\n-            switch (c) {\r\n-            case CR:\r\n-                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\r\n-                    i++;\r\n-                }\r\n-                // falls-through: break intentionally excluded.\r\n-            case LF:\r\n-                println();\r\n-                appendable.append(format.getCommentMarker().charValue()); // N.B. Explicit (un)boxing is intentional\r\n-                appendable.append(SP);\r\n-                break;\r\n-            default:\r\n-                appendable.append(c);\r\n-                break;\r\n-            }\r\n-        }\r\n-        println();\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints headers for a result set based on its metadata.\r\n-     *\r\n-     * @param resultSet The ResultSet to query for metadata.\r\n-     * @throws IOException If an I/O error occurs.\r\n-     * @throws SQLException If a database access error occurs or this method is called on a closed result set.\r\n-     * @since 1.9.0\r\n-     */\r\n-    public synchronized void printHeaders(final ResultSet resultSet) throws IOException, SQLException {\r\n-        try (IOStream<String> stream = IOStream.of(format.builder().setHeader(resultSet).get().getHeader())) {\r\n-            stream.forEachOrdered(this::print);\r\n-        }\r\n-        println();\r\n-    }\r\n-\r\n-    /**\r\n-     * Outputs the record separator.\r\n-     *\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    public synchronized void println() throws IOException {\r\n-        format.println(appendable);\r\n-        newRecord = true;\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints the given values as a single record of delimiter-separated values followed by the record separator.\r\n-     *\r\n-     * <p>\r\n-     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\r\n-     * separator to the output after printing the record, so there is no need to call {@link #println()}.\r\n-     * </p>\r\n-     *\r\n-     * @param values\r\n-     *            values to output.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    @SuppressWarnings(\"resource\")\r\n-    public synchronized void printRecord(final Iterable<?> values) throws IOException {\r\n-        IOStream.of(values).forEachOrdered(this::print);\r\n-        endOfRecord();\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints the given values as a single record of delimiter-separated values followed by the record separator.\r\n-     *\r\n-     * <p>\r\n-     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\r\n-     * separator to the output after printing the record, so there is no need to call {@link #println()}.\r\n-     * </p>\r\n-     *\r\n-     * @param values\r\n-     *            values to output.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    public void printRecord(final Object... values) throws IOException {\r\n-        printRecord(Arrays.asList(values));\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints the given values as a single record of delimiter-separated values followed by the record separator.\r\n-     *\r\n-     * <p>\r\n-     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\r\n-     * separator to the output after printing the record, so there is no need to call {@link #println()}.\r\n-     * </p>\r\n-     *\r\n-     * @param values\r\n-     *            values to output.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     * @since 1.10.0\r\n-     */\r\n-    @SuppressWarnings(\"resource\") // caller closes.\r\n-    public synchronized void printRecord(final Stream<?> values) throws IOException {\r\n-        IOStream.adapt(values).forEachOrdered(this::print);\r\n-        endOfRecord();\r\n-    }\r\n-\r\n-    private void printRecordObject(final Object value) throws IOException {\r\n-        if (value instanceof Object[]) {\r\n-            this.printRecord((Object[]) value);\r\n-        } else if (value instanceof Iterable) {\r\n-            this.printRecord((Iterable<?>) value);\r\n-        } else {\r\n-            this.printRecord(value);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints all the objects in the given {@link Iterable} handling nested collections/arrays as records.\r\n-     *\r\n-     * <p>\r\n-     * If the given Iterable only contains simple objects, this method will print a single record like\r\n-     * {@link #printRecord(Iterable)}. If the given Iterable contains nested collections/arrays those nested elements\r\n-     * will each be printed as records using {@link #printRecord(Object...)}.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Given the following data structure:\r\n-     * </p>\r\n-     *\r\n-     * <pre>{@code\r\n-     * List<String[]> data = new ArrayList<>();\r\n-     * data.add(new String[]{ \"A\", \"B\", \"C\" });\r\n-     * data.add(new String[]{ \"1\", \"2\", \"3\" });\r\n-     * data.add(new String[]{ \"A1\", \"B2\", \"C3\" });\r\n-     * }\r\n-     * </pre>\r\n-     *\r\n-     * <p>\r\n-     * Calling this method will print:\r\n-     * </p>\r\n-     *\r\n-     * <pre>\r\n-     * {@code\r\n-     * A, B, C\r\n-     * 1, 2, 3\r\n-     * A1, B2, C3\r\n-     * }\r\n-     * </pre>\r\n-     *\r\n-     * @param values\r\n-     *            the values to print.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    @SuppressWarnings(\"resource\")\r\n-    public void printRecords(final Iterable<?> values) throws IOException {\r\n-        IOStream.of(values).forEachOrdered(this::printRecordObject);\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints all the objects in the given array handling nested collections/arrays as records.\r\n-     *\r\n-     * <p>\r\n-     * If the given array only contains simple objects, this method will print a single record like\r\n-     * {@link #printRecord(Object...)}. If the given collections contain nested collections or arrays, those nested\r\n-     * elements will each be printed as records using {@link #printRecord(Object...)}.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Given the following data structure:\r\n-     * </p>\r\n-     *\r\n-     * <pre>{@code\r\n-     * String[][] data = new String[3][]\r\n-     * data[0] = String[]{ \"A\", \"B\", \"C\" };\r\n-     * data[1] = new String[]{ \"1\", \"2\", \"3\" };\r\n-     * data[2] = new String[]{ \"A1\", \"B2\", \"C3\" };\r\n-     * }\r\n-     * </pre>\r\n-     *\r\n-     * <p>\r\n-     * Calling this method will print:\r\n-     * </p>\r\n-     *\r\n-     * <pre>{@code\r\n-     * A, B, C\r\n-     * 1, 2, 3\r\n-     * A1, B2, C3\r\n-     * }\r\n-     * </pre>\r\n-     *\r\n-     * @param values\r\n-     *            the values to print.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     */\r\n-    public void printRecords(final Object... values) throws IOException {\r\n-        printRecords(Arrays.asList(values));\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints all the objects in the given JDBC result set.\r\n-     *\r\n-     * @param resultSet\r\n-     *             The values to print.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs.\r\n-     * @throws SQLException\r\n-     *             Thrown when a database access error occurs.\r\n-     */\r\n-    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\r\n-        final int columnCount = resultSet.getMetaData().getColumnCount();\r\n-        while (resultSet.next()) {\r\n-            for (int i = 1; i <= columnCount; i++) {\r\n-                final Object object = resultSet.getObject(i);\r\n-                if (object instanceof Clob) {\r\n-                    try (Reader reader = ((Clob) object).getCharacterStream()) {\r\n-                        print(reader);\r\n-                    }\r\n-                } else if (object instanceof Blob) {\r\n-                    try (InputStream inputStream = ((Blob) object).getBinaryStream()) {\r\n-                        print(inputStream);\r\n-                    }\r\n-                } else {\r\n-                    print(object);\r\n-                }\r\n-            }\r\n-            endOfRecord();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints all the objects with metadata in the given JDBC result set based on the header boolean.\r\n-     *\r\n-     * @param resultSet source of row data.\r\n-     * @param printHeader whether to print headers.\r\n-     * @throws IOException If an I/O error occurs\r\n-     * @throws SQLException if a database access error occurs\r\n-     * @since 1.9.0\r\n-     */\r\n-    public void printRecords(final ResultSet resultSet, final boolean printHeader) throws SQLException, IOException {\r\n-        if (printHeader) {\r\n-            printHeaders(resultSet);\r\n-        }\r\n-        printRecords(resultSet);\r\n-    }\r\n-\r\n-    /**\r\n-     * Prints all the objects in the given {@link Stream} handling nested collections/arrays as records.\r\n-     *\r\n-     * <p>\r\n-     * If the given Stream only contains simple objects, this method will print a single record like\r\n-     * {@link #printRecord(Iterable)}. If the given Stream contains nested collections/arrays those nested elements\r\n-     * will each be printed as records using {@link #printRecord(Object...)}.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Given the following data structure:\r\n-     * </p>\r\n-     *\r\n-     * <pre>{@code\r\n-     * List<String[]> data = new ArrayList<>();\r\n-     * data.add(new String[]{ \"A\", \"B\", \"C\" });\r\n-     * data.add(new String[]{ \"1\", \"2\", \"3\" });\r\n-     * data.add(new String[]{ \"A1\", \"B2\", \"C3\" });\r\n-     * Stream<String[]> stream = data.stream();\r\n-     * }\r\n-     * </pre>\r\n-     *\r\n-     * <p>\r\n-     * Calling this method will print:\r\n-     * </p>\r\n-     *\r\n-     * <pre>\r\n-     * {@code\r\n-     * A, B, C\r\n-     * 1, 2, 3\r\n-     * A1, B2, C3\r\n-     * }\r\n-     * </pre>\r\n-     *\r\n-     * @param values\r\n-     *            the values to print.\r\n-     * @throws IOException\r\n-     *             If an I/O error occurs\r\n-     * @since 1.10.0\r\n-     */\r\n-    @SuppressWarnings({ \"resource\" }) // Caller closes.\r\n-    public void printRecords(final Stream<?> values) throws IOException {\r\n-        IOStream.adapt(values).forEachOrdered(this::printRecordObject);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import static org.apache.commons.csv.Constants.CR;\n+import static org.apache.commons.csv.Constants.LF;\n+import static org.apache.commons.csv.Constants.SP;\n+\n+import java.io.Closeable;\n+import java.io.Flushable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.function.IOStream;\n+\n+/**\n+ * Prints values in a {@link CSVFormat CSV format}.\n+ *\n+ * <p>Values can be appended to the output by calling the {@link #print(Object)} method.\n+ * Values are printed according to {@link String#valueOf(Object)}.\n+ * To complete a record the {@link #println()} method has to be called.\n+ * Comments can be appended by calling {@link #printComment(String)}.\n+ * However a comment will only be written to the output if the {@link CSVFormat} supports comments.\n+ * </p>\n+ *\n+ * <p>The printer also supports appending a complete record at once by calling {@link #printRecord(Object...)}\n+ * or {@link #printRecord(Iterable)}.\n+ * Furthermore {@link #printRecords(Object...)}, {@link #printRecords(Iterable)} and {@link #printRecords(ResultSet)}\n+ * methods can be used to print several records at once.\n+ * </p>\n+ *\n+ * <p>Example:</p>\n+ *\n+ * <pre>\n+ * try (CSVPrinter printer = new CSVPrinter(new FileWriter(\"csv.txt\"), CSVFormat.EXCEL)) {\n+ *     printer.printRecord(\"id\", \"userName\", \"firstName\", \"lastName\", \"birthday\");\n+ *     printer.printRecord(1, \"john73\", \"John\", \"Doe\", LocalDate.of(1973, 9, 15));\n+ *     printer.println();\n+ *     printer.printRecord(2, \"mary\", \"Mary\", \"Meyer\", LocalDate.of(1985, 3, 29));\n+ * } catch (IOException ex) {\n+ *     ex.printStackTrace();\n+ * }\n+ * </pre>\n+ *\n+ * <p>This code will write the following to csv.txt:</p>\n+ * <pre>\n+ * id,userName,firstName,lastName,birthday\n+ * 1,john73,John,Doe,1973-09-15\n+ *\n+ * 2,mary,Mary,Meyer,1985-03-29\n+ * </pre>\n+ */\n+public final class CSVPrinter implements Flushable, Closeable {\n+\n+    /** The place that the values get written. */\n+    private final Appendable appendable;\n+\n+    private final CSVFormat format;\n+\n+    /** True if we just began a new record. */\n+    private boolean newRecord = true;\n+\n+    private long recordCount;\n+\n+    /**\n+     * Creates a printer that will print values to the given stream following the CSVFormat.\n+     * <p>\n+     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\n+     * and escaping with a different character) are not supported.\n+     * </p>\n+     *\n+     * @param appendable\n+     *            stream to which to print. Must not be null.\n+     * @param format\n+     *            the CSV format. Must not be null.\n+     * @throws IOException\n+     *             thrown if the optional header cannot be printed.\n+     * @throws IllegalArgumentException\n+     *             thrown if the parameters of the format are inconsistent or if either out or format are null.\n+     */\n+    public CSVPrinter(final Appendable appendable, final CSVFormat format) throws IOException {\n+        Objects.requireNonNull(appendable, \"appendable\");\n+        Objects.requireNonNull(format, \"format\");\n+\n+        this.appendable = appendable;\n+        this.format = format.copy();\n+        // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n+        // It seems a pain to have to track whether the header has already been printed or not.\n+        final String[] headerComments = format.getHeaderComments();\n+        if (headerComments != null) {\n+            for (final String line : headerComments) {\n+                printComment(line);\n+            }\n+        }\n+        if (format.getHeader() != null && !format.getSkipHeaderRecord()) {\n+            this.printRecord((Object[]) format.getHeader());\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        close(false);\n+    }\n+\n+    /**\n+     * Closes the underlying stream with an optional flush first.\n+     * @param flush whether to flush before the actual close.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     * @since 1.6\n+     */\n+    public void close(final boolean flush) throws IOException {\n+        if (flush || format.getAutoFlush()) {\n+            flush();\n+        }\n+        if (appendable instanceof Closeable) {\n+            ((Closeable) appendable).close();\n+        }\n+    }\n+\n+    /**\n+     * Outputs the record separator and increments the record count.\n+     *\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    private synchronized void endOfRecord() throws IOException {\n+        println();\n+        recordCount++;\n+    }\n+\n+    /**\n+     * Flushes the underlying stream.\n+     *\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    @Override\n+    public void flush() throws IOException {\n+        if (appendable instanceof Flushable) {\n+            ((Flushable) appendable).flush();\n+        }\n+    }\n+\n+    /**\n+     * Gets the target Appendable.\n+     *\n+     * @return the target Appendable.\n+     */\n+    public Appendable getOut() {\n+        return this.appendable;\n+    }\n+\n+    /**\n+     * Gets the record count printed, this does not include comments or headers.\n+     *\n+     * @return the record count, this does not include comments or headers.\n+     * @since 1.13.0\n+     */\n+    public long getRecordCount() {\n+        return recordCount;\n+    }\n+\n+    /**\n+     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n+     *\n+     * @param value\n+     *            value to be output.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public synchronized void print(final Object value) throws IOException {\n+        format.print(value, appendable, newRecord);\n+        newRecord = false;\n+    }\n+\n+    /**\n+     * Prints a comment on a new line among the delimiter-separated values.\n+     *\n+     * <p>\n+     * Comments will always begin on a new line and occupy at least one full line. The character specified to start\n+     * comments and a space will be inserted at the beginning of each new line in the comment.\n+     * </p>\n+     *\n+     * <p>\n+     * If comments are disabled in the current CSV format this method does nothing.\n+     * </p>\n+     *\n+     * <p>This method detects line breaks inside the comment string and inserts {@link CSVFormat#getRecordSeparator()}\n+     * to start a new line of the comment. Note that this might produce unexpected results for formats that do not use\n+     * line breaks as record separators.</p>\n+     *\n+     * @param comment\n+     *            the comment to output\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public synchronized void printComment(final String comment) throws IOException {\n+        if (comment == null || !format.isCommentMarkerSet()) {\n+            return;\n+        }\n+        if (!newRecord) {\n+            println();\n+        }\n+        appendable.append(format.getCommentMarker().charValue()); // N.B. Explicit (un)boxing is intentional\n+        appendable.append(SP);\n+        for (int i = 0; i < comment.length(); i++) {\n+            final char c = comment.charAt(i);\n+            switch (c) {\n+            case CR:\n+                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n+                    i++;\n+                }\n+                // falls-through: break intentionally excluded.\n+            case LF:\n+                println();\n+                appendable.append(format.getCommentMarker().charValue()); // N.B. Explicit (un)boxing is intentional\n+                appendable.append(SP);\n+                break;\n+            default:\n+                appendable.append(c);\n+                break;\n+            }\n+        }\n+        println();\n+    }\n+\n+    /**\n+     * Prints headers for a result set based on its metadata.\n+     *\n+     * @param resultSet The ResultSet to query for metadata.\n+     * @throws IOException If an I/O error occurs.\n+     * @throws SQLException If a database access error occurs or this method is called on a closed result set.\n+     * @since 1.9.0\n+     */\n+    public synchronized void printHeaders(final ResultSet resultSet) throws IOException, SQLException {\n+        try (IOStream<String> stream = IOStream.of(format.builder().setHeader(resultSet).get().getHeader())) {\n+            stream.forEachOrdered(this::print);\n+        }\n+        println();\n+    }\n+\n+    /**\n+     * Outputs the record separator.\n+     *\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public synchronized void println() throws IOException {\n+        format.println(appendable);\n+        newRecord = true;\n+    }\n+\n+    /**\n+     * Prints the given values as a single record of delimiter-separated values followed by the record separator.\n+     *\n+     * <p>\n+     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n+     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n+     * </p>\n+     *\n+     * @param values\n+     *            values to output.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    @SuppressWarnings(\"resource\")\n+    public synchronized void printRecord(final Iterable<?> values) throws IOException {\n+        IOStream.of(values).forEachOrdered(this::print);\n+        endOfRecord();\n+    }\n+\n+    /**\n+     * Prints the given values as a single record of delimiter-separated values followed by the record separator.\n+     *\n+     * <p>\n+     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n+     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n+     * </p>\n+     *\n+     * @param values\n+     *            values to output.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public void printRecord(final Object... values) throws IOException {\n+        printRecord(Arrays.asList(values));\n+    }\n+\n+    /**\n+     * Prints the given values as a single record of delimiter-separated values followed by the record separator.\n+     *\n+     * <p>\n+     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n+     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n+     * </p>\n+     *\n+     * @param values\n+     *            values to output.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     * @since 1.10.0\n+     */\n+    @SuppressWarnings(\"resource\") // caller closes.\n+    public synchronized void printRecord(final Stream<?> values) throws IOException {\n+        IOStream.adapt(values).forEachOrdered(this::print);\n+        endOfRecord();\n+    }\n+\n+    private void printRecordObject(final Object value) throws IOException {\n+        if (value instanceof Object[]) {\n+            this.printRecord((Object[]) value);\n+        } else if (value instanceof Iterable) {\n+            this.printRecord((Iterable<?>) value);\n+        } else {\n+            this.printRecord(value);\n+        }\n+    }\n+\n+    /**\n+     * Prints all the objects in the given {@link Iterable} handling nested collections/arrays as records.\n+     *\n+     * <p>\n+     * If the given Iterable only contains simple objects, this method will print a single record like\n+     * {@link #printRecord(Iterable)}. If the given Iterable contains nested collections/arrays those nested elements\n+     * will each be printed as records using {@link #printRecord(Object...)}.\n+     * </p>\n+     *\n+     * <p>\n+     * Given the following data structure:\n+     * </p>\n+     *\n+     * <pre>{@code\n+     * List<String[]> data = new ArrayList<>();\n+     * data.add(new String[]{ \"A\", \"B\", \"C\" });\n+     * data.add(new String[]{ \"1\", \"2\", \"3\" });\n+     * data.add(new String[]{ \"A1\", \"B2\", \"C3\" });\n+     * }\n+     * </pre>\n+     *\n+     * <p>\n+     * Calling this method will print:\n+     * </p>\n+     *\n+     * <pre>\n+     * {@code\n+     * A, B, C\n+     * 1, 2, 3\n+     * A1, B2, C3\n+     * }\n+     * </pre>\n+     *\n+     * @param values\n+     *            the values to print.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    @SuppressWarnings(\"resource\")\n+    public void printRecords(final Iterable<?> values) throws IOException {\n+        IOStream.of(values).forEachOrdered(this::printRecordObject);\n+    }\n+\n+    /**\n+     * Prints all the objects in the given array handling nested collections/arrays as records.\n+     *\n+     * <p>\n+     * If the given array only contains simple objects, this method will print a single record like\n+     * {@link #printRecord(Object...)}. If the given collections contain nested collections or arrays, those nested\n+     * elements will each be printed as records using {@link #printRecord(Object...)}.\n+     * </p>\n+     *\n+     * <p>\n+     * Given the following data structure:\n+     * </p>\n+     *\n+     * <pre>{@code\n+     * String[][] data = new String[3][]\n+     * data[0] = String[]{ \"A\", \"B\", \"C\" };\n+     * data[1] = new String[]{ \"1\", \"2\", \"3\" };\n+     * data[2] = new String[]{ \"A1\", \"B2\", \"C3\" };\n+     * }\n+     * </pre>\n+     *\n+     * <p>\n+     * Calling this method will print:\n+     * </p>\n+     *\n+     * <pre>{@code\n+     * A, B, C\n+     * 1, 2, 3\n+     * A1, B2, C3\n+     * }\n+     * </pre>\n+     *\n+     * @param values\n+     *            the values to print.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public void printRecords(final Object... values) throws IOException {\n+        printRecords(Arrays.asList(values));\n+    }\n+\n+    /**\n+     * Prints all the objects in the given JDBC result set.\n+     *\n+     * @param resultSet\n+     *             The values to print.\n+     * @throws IOException\n+     *             If an I/O error occurs.\n+     * @throws SQLException\n+     *             Thrown when a database access error occurs.\n+     */\n+    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n+        final int columnCount = resultSet.getMetaData().getColumnCount();\n+        while (resultSet.next()) {\n+            for (int i = 1; i <= columnCount; i++) {\n+                final Object object = resultSet.getObject(i);\n+                if (object instanceof Clob) {\n+                    try (Reader reader = ((Clob) object).getCharacterStream()) {\n+                        print(reader);\n+                    }\n+                } else if (object instanceof Blob) {\n+                    try (InputStream inputStream = ((Blob) object).getBinaryStream()) {\n+                        print(inputStream);\n+                    }\n+                } else {\n+                    print(object);\n+                }\n+            }\n+            endOfRecord();\n+        }\n+    }\n+\n+    /**\n+     * Prints all the objects with metadata in the given JDBC result set based on the header boolean.\n+     *\n+     * @param resultSet source of row data.\n+     * @param printHeader whether to print headers.\n+     * @throws IOException If an I/O error occurs\n+     * @throws SQLException if a database access error occurs\n+     * @since 1.9.0\n+     */\n+    public void printRecords(final ResultSet resultSet, final boolean printHeader) throws SQLException, IOException {\n+        if (printHeader) {\n+            printHeaders(resultSet);\n+        }\n+        printRecords(resultSet);\n+    }\n+\n+    /**\n+     * Prints all the objects in the given {@link Stream} handling nested collections/arrays as records.\n+     *\n+     * <p>\n+     * If the given Stream only contains simple objects, this method will print a single record like\n+     * {@link #printRecord(Iterable)}. If the given Stream contains nested collections/arrays those nested elements\n+     * will each be printed as records using {@link #printRecord(Object...)}.\n+     * </p>\n+     *\n+     * <p>\n+     * Given the following data structure:\n+     * </p>\n+     *\n+     * <pre>{@code\n+     * List<String[]> data = new ArrayList<>();\n+     * data.add(new String[]{ \"A\", \"B\", \"C\" });\n+     * data.add(new String[]{ \"1\", \"2\", \"3\" });\n+     * data.add(new String[]{ \"A1\", \"B2\", \"C3\" });\n+     * Stream<String[]> stream = data.stream();\n+     * }\n+     * </pre>\n+     *\n+     * <p>\n+     * Calling this method will print:\n+     * </p>\n+     *\n+     * <pre>\n+     * {@code\n+     * A, B, C\n+     * 1, 2, 3\n+     * A1, B2, C3\n+     * }\n+     * </pre>\n+     *\n+     * @param values\n+     *            the values to print.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     * @since 1.10.0\n+     */\n+    @SuppressWarnings({ \"resource\" }) // Caller closes.\n+    public void printRecords(final Stream<?> values) throws IOException {\n+        IOStream.adapt(values).forEachOrdered(this::printRecordObject);\n+    }\n+}\n\ndiff --git a/src/main/java/org/apache/commons/csv/Constants.java b/src/main/java/org/apache/commons/csv/Constants.java\nindex 5f8a5cf4..e8557846 100644\n--- a/src/main/java/org/apache/commons/csv/Constants.java\n+++ b/src/main/java/org/apache/commons/csv/Constants.java\n@@ -1,90 +1,90 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv;\r\n-\r\n-/**\r\n- * Private constants to this package.\r\n- */\r\n-final class Constants {\r\n-\r\n-    static final char BACKSLASH = '\\\\';\r\n-\r\n-    static final char BACKSPACE = '\\b';\r\n-\r\n-    static final String COMMA = \",\";\r\n-\r\n-    /**\r\n-     * Starts a comment, the remainder of the line is the comment.\r\n-     */\r\n-    static final char COMMENT = '#';\r\n-\r\n-    static final char CR = '\\r';\r\n-\r\n-    /** RFC 4180 defines line breaks as CRLF */\r\n-    static final String CRLF = \"\\r\\n\";\r\n-\r\n-    static final Character DOUBLE_QUOTE_CHAR = Character.valueOf('\"');  // N.B. Explicit (un)boxing is intentional\r\n-\r\n-    static final String EMPTY = \"\";\r\n-\r\n-    static final String[] EMPTY_STRING_ARRAY = {};\r\n-\r\n-    static final char FF = '\\f';\r\n-\r\n-    static final char LF = '\\n';\r\n-\r\n-    /**\r\n-     * Unicode line separator.\r\n-     */\r\n-    static final String LINE_SEPARATOR = \"\\u2028\";\r\n-\r\n-    /**\r\n-     * Unicode next line.\r\n-     */\r\n-    static final String NEXT_LINE = \"\\u0085\";\r\n-\r\n-    /**\r\n-     * Unicode paragraph separator.\r\n-     */\r\n-    static final String PARAGRAPH_SEPARATOR = \"\\u2029\";\r\n-\r\n-    static final char PIPE = '|';\r\n-\r\n-    /** ASCII record separator */\r\n-    static final char RS = 30;\r\n-\r\n-    static final char SP = ' ';\r\n-\r\n-    static final String SQL_NULL_STRING = \"\\\\N\";\r\n-\r\n-    static final char TAB = '\\t';\r\n-\r\n-    /** Undefined state for the lookahead char */\r\n-    static final int UNDEFINED = -2;\r\n-\r\n-    /** ASCII unit separator */\r\n-    static final char US = 31;\r\n-\r\n-    /** No instances. */\r\n-    private Constants() {\r\n-        // noop\r\n-    }\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+/**\n+ * Private constants to this package.\n+ */\n+final class Constants {\n+\n+    static final char BACKSLASH = '\\\\';\n+\n+    static final char BACKSPACE = '\\b';\n+\n+    static final String COMMA = \",\";\n+\n+    /**\n+     * Starts a comment, the remainder of the line is the comment.\n+     */\n+    static final char COMMENT = '#';\n+\n+    static final char CR = '\\r';\n+\n+    /** RFC 4180 defines line breaks as CRLF */\n+    static final String CRLF = \"\\r\\n\";\n+\n+    static final Character DOUBLE_QUOTE_CHAR = Character.valueOf('\"');  // N.B. Explicit (un)boxing is intentional\n+\n+    static final String EMPTY = \"\";\n+\n+    static final String[] EMPTY_STRING_ARRAY = {};\n+\n+    static final char FF = '\\f';\n+\n+    static final char LF = '\\n';\n+\n+    /**\n+     * Unicode line separator.\n+     */\n+    static final String LINE_SEPARATOR = \"\\u2028\";\n+\n+    /**\n+     * Unicode next line.\n+     */\n+    static final String NEXT_LINE = \"\\u0085\";\n+\n+    /**\n+     * Unicode paragraph separator.\n+     */\n+    static final String PARAGRAPH_SEPARATOR = \"\\u2029\";\n+\n+    static final char PIPE = '|';\n+\n+    /** ASCII record separator */\n+    static final char RS = 30;\n+\n+    static final char SP = ' ';\n+\n+    static final String SQL_NULL_STRING = \"\\\\N\";\n+\n+    static final char TAB = '\\t';\n+\n+    /** Undefined state for the lookahead char */\n+    static final int UNDEFINED = -2;\n+\n+    /** ASCII unit separator */\n+    static final char US = 31;\n+\n+    /** No instances. */\n+    private Constants() {\n+        // noop\n+    }\n+\n+}\n",
    "test_only_diff": "diff --git a/src/test/java/org/apache/commons/csv/CSVFormatTest.java b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\nindex 50dfd0f8..9677d8ec 100644\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n@@ -1,1533 +1,1533 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv;\r\n-\r\n-import static org.apache.commons.csv.CSVFormat.RFC4180;\r\n-import static org.apache.commons.csv.Constants.CR;\r\n-import static org.apache.commons.csv.Constants.CRLF;\r\n-import static org.apache.commons.csv.Constants.LF;\r\n-import static org.junit.jupiter.api.Assertions.assertArrayEquals;\r\n-import static org.junit.jupiter.api.Assertions.assertEquals;\r\n-import static org.junit.jupiter.api.Assertions.assertFalse;\r\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\r\n-import static org.junit.jupiter.api.Assertions.assertNotSame;\r\n-import static org.junit.jupiter.api.Assertions.assertNull;\r\n-import static org.junit.jupiter.api.Assertions.assertThrows;\r\n-import static org.junit.jupiter.api.Assertions.assertTrue;\r\n-import static org.junit.jupiter.api.Assertions.fail;\r\n-\r\n-import java.io.ByteArrayInputStream;\r\n-import java.io.ByteArrayOutputStream;\r\n-import java.io.IOException;\r\n-import java.io.ObjectInputStream;\r\n-import java.io.ObjectOutputStream;\r\n-import java.io.Reader;\r\n-import java.io.StringReader;\r\n-import java.lang.reflect.Method;\r\n-import java.lang.reflect.Modifier;\r\n-import java.sql.ResultSet;\r\n-import java.sql.SQLException;\r\n-import java.util.Arrays;\r\n-import java.util.Objects;\r\n-\r\n-import org.apache.commons.csv.CSVFormat.Builder;\r\n-import org.junit.jupiter.api.Assertions;\r\n-import org.junit.jupiter.api.Test;\r\n-\r\n-/**\r\n- * Tests {@link CSVFormat}.\r\n- */\r\n-public class CSVFormatTest {\r\n-\r\n-    public enum EmptyEnum {\r\n-        // empty enum.\r\n-    }\r\n-\r\n-    public enum Header {\r\n-        Name, Email, Phone\r\n-    }\r\n-\r\n-    private static void assertNotEquals(final Object right, final Object left) {\r\n-        Assertions.assertNotEquals(right, left);\r\n-        Assertions.assertNotEquals(left, right);\r\n-    }\r\n-\r\n-    private static CSVFormat copy(final CSVFormat format) {\r\n-        return format.builder().setDelimiter(format.getDelimiter()).get();\r\n-    }\r\n-\r\n-    private void assertNotEquals(final String name, final String type, final Object left, final Object right) {\r\n-        if (left.equals(right) || right.equals(left)) {\r\n-            fail(\"Objects must not compare equal for \" + name + \"(\" + type + \")\");\r\n-        }\r\n-        if (left.hashCode() == right.hashCode()) {\r\n-            fail(\"Hash code should not be equal for \" + name + \"(\" + type + \")\");\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testBuildVsGet() {\r\n-        final Builder builder = CSVFormat.DEFAULT.builder();\r\n-        assertNotSame(builder.get(), builder.build());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimiterEmptyStringThrowsException1() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter(\"\").get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testDelimiterSameAsCommentStartThrowsException_Deprecated() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter('!').withCommentMarker('!'));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimiterSameAsCommentStartThrowsException1() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter('!').setCommentMarker('!').get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testDelimiterSameAsEscapeThrowsException_Deprecated() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter('!').withEscape('!'));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimiterSameAsEscapeThrowsException1() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter('!').setEscape('!').get());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimiterSameAsRecordSeparatorThrowsException() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat(CR));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDuplicateHeaderElements() {\r\n-        final String[] header = { \"A\", \"A\" };\r\n-        final CSVFormat format = CSVFormat.DEFAULT.builder().setHeader(header).get();\r\n-        assertEquals(2, format.getHeader().length);\r\n-        assertArrayEquals(header, format.getHeader());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testDuplicateHeaderElements_Deprecated() {\r\n-        final String[] header = { \"A\", \"A\" };\r\n-        final CSVFormat format = CSVFormat.DEFAULT.withHeader(header);\r\n-        assertEquals(2, format.getHeader().length);\r\n-        assertArrayEquals(header, format.getHeader());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDuplicateHeaderElementsFalse() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(false).setHeader(\"A\", \"A\").get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testDuplicateHeaderElementsFalse_Deprecated() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withAllowDuplicateHeaderNames(false).withHeader(\"A\", \"A\"));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDuplicateHeaderElementsTrue() {\r\n-        CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(true).setHeader(\"A\", \"A\").get();\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testDuplicateHeaderElementsTrue_Deprecated() {\r\n-        CSVFormat.DEFAULT.withAllowDuplicateHeaderNames(true).withHeader(\"A\", \"A\");\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDuplicateHeaderElementsTrueContainsEmpty1() {\r\n-        CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(false).setHeader(\"A\", \"\", \"B\", \"\").get();\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDuplicateHeaderElementsTrueContainsEmpty2() {\r\n-        CSVFormat.DEFAULT.builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).setHeader(\"A\", \"\", \"B\", \"\").get();\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDuplicateHeaderElementsTrueContainsEmpty3() {\r\n-        CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(false).setAllowMissingColumnNames(true).setHeader(\"A\", \"\", \"B\", \"\").get();\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEquals() {\r\n-        final CSVFormat right = CSVFormat.DEFAULT;\r\n-        final CSVFormat left = copy(right);\r\n-        Assertions.assertNotEquals(null, right);\r\n-        Assertions.assertNotEquals(\"A String Instance\", right);\r\n-        assertEquals(right, right);\r\n-        assertEquals(right, left);\r\n-        assertEquals(left, right);\r\n-        assertEquals(right.hashCode(), right.hashCode());\r\n-        assertEquals(right.hashCode(), left.hashCode());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsCommentStart() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').setCommentMarker('#').setQuoteMode(QuoteMode.ALL).get();\r\n-        final CSVFormat left = right.builder().setCommentMarker('!').get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsCommentStart_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"').withCommentMarker('#').withQuoteMode(QuoteMode.ALL);\r\n-        final CSVFormat left = right.withCommentMarker('!');\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsDelimiter() {\r\n-        final CSVFormat right = CSVFormat.newFormat('!');\r\n-        final CSVFormat left = CSVFormat.newFormat('?');\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsEscape() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').setCommentMarker('#').setEscape('+').setQuoteMode(QuoteMode.ALL).get();\r\n-        final CSVFormat left = right.builder().setEscape('!').get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsEscape_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"').withCommentMarker('#').withEscape('+').withQuoteMode(QuoteMode.ALL);\r\n-        final CSVFormat left = right.withEscape('!');\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsHash() throws Exception {\r\n-        final Method[] methods = CSVFormat.class.getDeclaredMethods();\r\n-        for (final Method method : methods) {\r\n-            if (Modifier.isPublic(method.getModifiers())) {\r\n-                final String name = method.getName();\r\n-                if (name.startsWith(\"with\")) {\r\n-                    for (final Class<?> cls : method.getParameterTypes()) {\r\n-                        final String type = cls.getCanonicalName();\r\n-                        switch (type) {\r\n-                        case \"boolean\": {\r\n-                            final Object defTrue = method.invoke(CSVFormat.DEFAULT, Boolean.TRUE);\r\n-                            final Object defFalse = method.invoke(CSVFormat.DEFAULT, Boolean.FALSE);\r\n-                            assertNotEquals(name, type, defTrue, defFalse);\r\n-                            break;\r\n-                        }\r\n-                        case \"char\": {\r\n-                            final Object a = method.invoke(CSVFormat.DEFAULT, 'a');\r\n-                            final Object b = method.invoke(CSVFormat.DEFAULT, 'b');\r\n-                            assertNotEquals(name, type, a, b);\r\n-                            break;\r\n-                        }\r\n-                        case \"java.lang.Character\": {\r\n-                            final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { null });\r\n-                            final Object b = method.invoke(CSVFormat.DEFAULT, Character.valueOf('d'));\r\n-                            assertNotEquals(name, type, a, b);\r\n-                            break;\r\n-                        }\r\n-                        case \"java.lang.String\": {\r\n-                            final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { null });\r\n-                            final Object b = method.invoke(CSVFormat.DEFAULT, \"e\");\r\n-                            assertNotEquals(name, type, a, b);\r\n-                            break;\r\n-                        }\r\n-                        case \"java.lang.String[]\": {\r\n-                            final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { new String[] { null, null } });\r\n-                            final Object b = method.invoke(CSVFormat.DEFAULT, new Object[] { new String[] { \"f\", \"g\" } });\r\n-                            assertNotEquals(name, type, a, b);\r\n-                            break;\r\n-                        }\r\n-                        case \"org.apache.commons.csv.QuoteMode\": {\r\n-                            final Object a = method.invoke(CSVFormat.DEFAULT, QuoteMode.MINIMAL);\r\n-                            final Object b = method.invoke(CSVFormat.DEFAULT, QuoteMode.ALL);\r\n-                            assertNotEquals(name, type, a, b);\r\n-                            break;\r\n-                        }\r\n-                        case \"org.apache.commons.csv.DuplicateHeaderMode\": {\r\n-                            final Object a = method.invoke(CSVFormat.DEFAULT, DuplicateHeaderMode.ALLOW_ALL);\r\n-                            final Object b = method.invoke(CSVFormat.DEFAULT, DuplicateHeaderMode.DISALLOW);\r\n-                            assertNotEquals(name, type, a, b);\r\n-                            break;\r\n-                        }\r\n-                        case \"java.lang.Object[]\": {\r\n-                            final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { new Object[] { null, null } });\r\n-                            final Object b = method.invoke(CSVFormat.DEFAULT, new Object[] { new Object[] { new Object(), new Object() } });\r\n-                            assertNotEquals(name, type, a, b);\r\n-                            break;\r\n-                        }\r\n-                        default:\r\n-                            if (\"withHeader\".equals(name)) { // covered above by String[]\r\n-                                // ignored\r\n-                            } else {\r\n-                                fail(\"Unhandled method: \" + name + \"(\" + type + \")\");\r\n-                            }\r\n-                            break;\r\n-                        }\r\n-                    }\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsHeader() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setHeader(\"One\", \"Two\", \"Three\")\r\n-                .setIgnoreEmptyLines(true).setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\r\n-        final CSVFormat left = right.builder().setHeader(\"Three\", \"Two\", \"One\").get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsHeader_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withHeader(\"One\", \"Two\", \"Three\")\r\n-                .withIgnoreEmptyLines().withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL);\r\n-        final CSVFormat left = right.withHeader(\"Three\", \"Two\", \"One\");\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsIgnoreEmptyLines() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true)\r\n-                .setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\r\n-        final CSVFormat left = right.builder().setIgnoreEmptyLines(false).get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsIgnoreEmptyLines_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withCommentMarker('#').withEscape('+').withIgnoreEmptyLines().withIgnoreSurroundingSpaces()\r\n-                .withQuote('\"').withQuoteMode(QuoteMode.ALL);\r\n-        final CSVFormat left = right.withIgnoreEmptyLines(false);\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsIgnoreSurroundingSpaces() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setCommentMarker('#').setEscape('+').setIgnoreSurroundingSpaces(true).setQuote('\"')\r\n-                .setQuoteMode(QuoteMode.ALL).get();\r\n-        final CSVFormat left = right.builder().setIgnoreSurroundingSpaces(false).get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsIgnoreSurroundingSpaces_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withCommentMarker('#').withEscape('+').withIgnoreSurroundingSpaces().withQuote('\"')\r\n-                .withQuoteMode(QuoteMode.ALL);\r\n-        final CSVFormat left = right.withIgnoreSurroundingSpaces(false);\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsLeftNoQuoteRightQuote() {\r\n-        final CSVFormat left = CSVFormat.newFormat(',').builder().setQuote(null).get();\r\n-        final CSVFormat right = left.builder().setQuote('#').get();\r\n-\r\n-        assertNotEquals(left, right);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsLeftNoQuoteRightQuote_Deprecated() {\r\n-        final CSVFormat left = CSVFormat.newFormat(',').withQuote(null);\r\n-        final CSVFormat right = left.withQuote('#');\r\n-\r\n-        assertNotEquals(left, right);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsNoQuotes() {\r\n-        final CSVFormat left = CSVFormat.newFormat(',').builder().setQuote(null).get();\r\n-        final CSVFormat right = left.builder().setQuote(null).get();\r\n-\r\n-        assertEquals(left, right);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsNoQuotes_Deprecated() {\r\n-        final CSVFormat left = CSVFormat.newFormat(',').withQuote(null);\r\n-        final CSVFormat right = left.withQuote(null);\r\n-\r\n-        assertEquals(left, right);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsNullString() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true)\r\n-                .setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).setNullString(\"null\").get();\r\n-        final CSVFormat left = right.builder().setNullString(\"---\").get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsNullString_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withIgnoreEmptyLines()\r\n-                .withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL).withNullString(\"null\");\r\n-        final CSVFormat left = right.withNullString(\"---\");\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsOne() {\r\n-\r\n-        final CSVFormat csvFormatOne = CSVFormat.INFORMIX_UNLOAD;\r\n-        final CSVFormat csvFormatTwo = CSVFormat.MYSQL;\r\n-\r\n-        assertEquals('\\\\', (char) csvFormatOne.getEscapeCharacter());\r\n-        assertEquals('\\\\', csvFormatOne.getEscapeChar());\r\n-        assertNull(csvFormatOne.getQuoteMode());\r\n-\r\n-        assertTrue(csvFormatOne.getIgnoreEmptyLines());\r\n-        assertFalse(csvFormatOne.getSkipHeaderRecord());\r\n-\r\n-        assertFalse(csvFormatOne.getIgnoreHeaderCase());\r\n-        assertNull(csvFormatOne.getCommentMarker());\r\n-\r\n-        assertFalse(csvFormatOne.isCommentMarkerSet());\r\n-        assertTrue(csvFormatOne.isQuoteCharacterSet());\r\n-\r\n-        assertEquals('|', csvFormatOne.getDelimiter());\r\n-        assertFalse(csvFormatOne.getAllowMissingColumnNames());\r\n-\r\n-        assertTrue(csvFormatOne.isEscapeCharacterSet());\r\n-        assertEquals(\"\\n\", csvFormatOne.getRecordSeparator());\r\n-\r\n-        assertEquals('\\\"', (char) csvFormatOne.getQuoteCharacter());\r\n-        assertFalse(csvFormatOne.getTrailingDelimiter());\r\n-\r\n-        assertFalse(csvFormatOne.getTrim());\r\n-        assertFalse(csvFormatOne.isNullStringSet());\r\n-\r\n-        assertNull(csvFormatOne.getNullString());\r\n-        assertFalse(csvFormatOne.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertTrue(csvFormatTwo.isEscapeCharacterSet());\r\n-        assertNull(csvFormatTwo.getQuoteCharacter());\r\n-\r\n-        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n-        assertEquals(QuoteMode.ALL_NON_NULL, csvFormatTwo.getQuoteMode());\r\n-\r\n-        assertEquals('\\t', csvFormatTwo.getDelimiter());\r\n-        assertArrayEquals(new char[] { '\\t' }, csvFormatTwo.getDelimiterCharArray());\r\n-        assertEquals(\"\\t\", csvFormatTwo.getDelimiterString());\r\n-        assertEquals(\"\\n\", csvFormatTwo.getRecordSeparator());\r\n-\r\n-        assertFalse(csvFormatTwo.isQuoteCharacterSet());\r\n-        assertTrue(csvFormatTwo.isNullStringSet());\r\n-\r\n-        assertEquals('\\\\', (char) csvFormatTwo.getEscapeCharacter());\r\n-        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n-\r\n-        assertFalse(csvFormatTwo.getTrim());\r\n-        assertFalse(csvFormatTwo.getIgnoreEmptyLines());\r\n-\r\n-        assertEquals(\"\\\\N\", csvFormatTwo.getNullString());\r\n-        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n-        assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n-\r\n-        assertNull(csvFormatTwo.getCommentMarker());\r\n-        assertFalse(csvFormatTwo.isCommentMarkerSet());\r\n-\r\n-        assertNotSame(csvFormatTwo, csvFormatOne);\r\n-        Assertions.assertNotEquals(csvFormatTwo, csvFormatOne);\r\n-\r\n-        assertEquals('\\\\', (char) csvFormatOne.getEscapeCharacter());\r\n-        assertNull(csvFormatOne.getQuoteMode());\r\n-\r\n-        assertTrue(csvFormatOne.getIgnoreEmptyLines());\r\n-        assertFalse(csvFormatOne.getSkipHeaderRecord());\r\n-\r\n-        assertFalse(csvFormatOne.getIgnoreHeaderCase());\r\n-        assertNull(csvFormatOne.getCommentMarker());\r\n-\r\n-        assertFalse(csvFormatOne.isCommentMarkerSet());\r\n-        assertTrue(csvFormatOne.isQuoteCharacterSet());\r\n-\r\n-        assertEquals('|', csvFormatOne.getDelimiter());\r\n-        assertFalse(csvFormatOne.getAllowMissingColumnNames());\r\n-\r\n-        assertTrue(csvFormatOne.isEscapeCharacterSet());\r\n-        assertEquals(\"\\n\", csvFormatOne.getRecordSeparator());\r\n-\r\n-        assertEquals('\\\"', (char) csvFormatOne.getQuoteCharacter());\r\n-        assertFalse(csvFormatOne.getTrailingDelimiter());\r\n-\r\n-        assertFalse(csvFormatOne.getTrim());\r\n-        assertFalse(csvFormatOne.isNullStringSet());\r\n-\r\n-        assertNull(csvFormatOne.getNullString());\r\n-        assertFalse(csvFormatOne.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertTrue(csvFormatTwo.isEscapeCharacterSet());\r\n-        assertNull(csvFormatTwo.getQuoteCharacter());\r\n-\r\n-        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n-        assertEquals(QuoteMode.ALL_NON_NULL, csvFormatTwo.getQuoteMode());\r\n-\r\n-        assertEquals('\\t', csvFormatTwo.getDelimiter());\r\n-        assertEquals(\"\\n\", csvFormatTwo.getRecordSeparator());\r\n-\r\n-        assertFalse(csvFormatTwo.isQuoteCharacterSet());\r\n-        assertTrue(csvFormatTwo.isNullStringSet());\r\n-\r\n-        assertEquals('\\\\', (char) csvFormatTwo.getEscapeCharacter());\r\n-        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n-\r\n-        assertFalse(csvFormatTwo.getTrim());\r\n-        assertFalse(csvFormatTwo.getIgnoreEmptyLines());\r\n-\r\n-        assertEquals(\"\\\\N\", csvFormatTwo.getNullString());\r\n-        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n-        assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n-\r\n-        assertNull(csvFormatTwo.getCommentMarker());\r\n-        assertFalse(csvFormatTwo.isCommentMarkerSet());\r\n-\r\n-        assertNotSame(csvFormatOne, csvFormatTwo);\r\n-        assertNotSame(csvFormatTwo, csvFormatOne);\r\n-\r\n-        Assertions.assertNotEquals(csvFormatOne, csvFormatTwo);\r\n-        Assertions.assertNotEquals(csvFormatTwo, csvFormatOne);\r\n-\r\n-        Assertions.assertNotEquals(csvFormatTwo, csvFormatOne);\r\n-\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsQuoteChar() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').get();\r\n-        final CSVFormat left = right.builder().setQuote('!').get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsQuoteChar_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"');\r\n-        final CSVFormat left = right.withQuote('!');\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsQuotePolicy() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\r\n-        final CSVFormat left = right.builder().setQuoteMode(QuoteMode.MINIMAL).get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsQuotePolicy_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"').withQuoteMode(QuoteMode.ALL);\r\n-        final CSVFormat left = right.withQuoteMode(QuoteMode.MINIMAL);\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsRecordSeparator() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true)\r\n-                .setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\r\n-        final CSVFormat left = right.builder().setRecordSeparator(LF).get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsRecordSeparator_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withIgnoreEmptyLines()\r\n-                .withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL);\r\n-        final CSVFormat left = right.withRecordSeparator(LF);\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    public void testEqualsSkipHeaderRecord() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true)\r\n-                .setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).setNullString(\"null\").setSkipHeaderRecord(true).get();\r\n-        final CSVFormat left = right.builder().setSkipHeaderRecord(false).get();\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEqualsSkipHeaderRecord_Deprecated() {\r\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withIgnoreEmptyLines()\r\n-                .withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL).withNullString(\"null\").withSkipHeaderRecord();\r\n-        final CSVFormat left = right.withSkipHeaderRecord(false);\r\n-\r\n-        assertNotEquals(right, left);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEqualsWithNull() {\r\n-\r\n-        final CSVFormat csvFormat = CSVFormat.POSTGRESQL_TEXT;\r\n-\r\n-        assertEquals('\\\\', (char) csvFormat.getEscapeCharacter());\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-        assertFalse(csvFormat.getTrim());\r\n-\r\n-        assertFalse(csvFormat.isQuoteCharacterSet());\r\n-        assertEquals(\"\\\\N\", csvFormat.getNullString());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertTrue(csvFormat.isEscapeCharacterSet());\r\n-\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-        assertEquals(QuoteMode.ALL_NON_NULL, csvFormat.getQuoteMode());\r\n-\r\n-        assertEquals('\\t', csvFormat.getDelimiter());\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-\r\n-        assertEquals(\"\\n\", csvFormat.getRecordSeparator());\r\n-        assertFalse(csvFormat.getIgnoreEmptyLines());\r\n-\r\n-        assertNull(csvFormat.getQuoteCharacter());\r\n-        assertTrue(csvFormat.isNullStringSet());\r\n-\r\n-        assertEquals('\\\\', (char) csvFormat.getEscapeCharacter());\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-        assertFalse(csvFormat.getTrim());\r\n-\r\n-        assertFalse(csvFormat.isQuoteCharacterSet());\r\n-        assertEquals(\"\\\\N\", csvFormat.getNullString());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertTrue(csvFormat.isEscapeCharacterSet());\r\n-\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-        assertEquals(QuoteMode.ALL_NON_NULL, csvFormat.getQuoteMode());\r\n-\r\n-        assertEquals('\\t', csvFormat.getDelimiter());\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-\r\n-        assertEquals(\"\\n\", csvFormat.getRecordSeparator());\r\n-        assertFalse(csvFormat.getIgnoreEmptyLines());\r\n-\r\n-        assertNull(csvFormat.getQuoteCharacter());\r\n-        assertTrue(csvFormat.isNullStringSet());\r\n-\r\n-        Assertions.assertNotEquals(null, csvFormat);\r\n-\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeSameAsCommentStartThrowsException() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setEscape('!').setCommentMarker('!').get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEscapeSameAsCommentStartThrowsException_Deprecated() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withEscape('!').withCommentMarker('!'));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeSameAsCommentStartThrowsExceptionForWrapperType() {\r\n-        // Cannot assume that callers won't use different Character objects\r\n-        assertThrows(IllegalArgumentException.class,\r\n-                () -> CSVFormat.DEFAULT.builder().setEscape(Character.valueOf('!')).setCommentMarker(Character.valueOf('!')).get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testEscapeSameAsCommentStartThrowsExceptionForWrapperType_Deprecated() {\r\n-        // Cannot assume that callers won't use different Character objects\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withEscape(Character.valueOf('!')).withCommentMarker(Character.valueOf('!')));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testFormat() {\r\n-        final CSVFormat format = CSVFormat.DEFAULT;\r\n-\r\n-        assertEquals(\"\", format.format());\r\n-        assertEquals(\"a,b,c\", format.format(\"a\", \"b\", \"c\"));\r\n-        assertEquals(\"\\\"x,y\\\",z\", format.format(\"x,y\", \"z\"));\r\n-    }\r\n-\r\n-    @Test // I assume this to be a defect.\r\n-    public void testFormatThrowsNullPointerException() {\r\n-\r\n-        final CSVFormat csvFormat = CSVFormat.MYSQL;\r\n-\r\n-        final NullPointerException e = assertThrows(NullPointerException.class, () -> csvFormat.format((Object[]) null));\r\n-        assertEquals(Objects.class.getName(), e.getStackTrace()[0].getClassName());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testFormatToString() {\r\n-        // @formatter:off\r\n-        final CSVFormat format = CSVFormat.RFC4180\r\n-                .withEscape('?')\r\n-                .withDelimiter(',')\r\n-                .withQuoteMode(QuoteMode.MINIMAL)\r\n-                .withRecordSeparator(CRLF)\r\n-                .withQuote('\"')\r\n-                .withNullString(\"\")\r\n-                .withIgnoreHeaderCase(true)\r\n-                .withHeaderComments(\"This is HeaderComments\")\r\n-                .withHeader(\"col1\", \"col2\", \"col3\");\r\n-        // @formatter:on\r\n-        assertEquals(\r\n-                \"Delimiter=<,> Escape=<?> QuoteChar=<\\\"> QuoteMode=<MINIMAL> NullString=<> RecordSeparator=<\" + CRLF +\r\n-                        \"> IgnoreHeaderCase:ignored SkipHeaderRecord:false HeaderComments:[This is HeaderComments] Header:[col1, col2, col3]\",\r\n-                format.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetAllowDuplicateHeaderNames() {\r\n-        final Builder builder = CSVFormat.DEFAULT.builder();\r\n-        assertTrue(builder.get().getAllowDuplicateHeaderNames());\r\n-        assertTrue(builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).get().getAllowDuplicateHeaderNames());\r\n-        assertFalse(builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).get().getAllowDuplicateHeaderNames());\r\n-        assertFalse(builder.setDuplicateHeaderMode(DuplicateHeaderMode.DISALLOW).get().getAllowDuplicateHeaderNames());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetDuplicateHeaderMode() {\r\n-        final Builder builder = CSVFormat.DEFAULT.builder();\r\n-\r\n-        assertEquals(DuplicateHeaderMode.ALLOW_ALL, builder.get().getDuplicateHeaderMode());\r\n-        assertEquals(DuplicateHeaderMode.ALLOW_ALL, builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).get().getDuplicateHeaderMode());\r\n-        assertEquals(DuplicateHeaderMode.ALLOW_EMPTY, builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).get().getDuplicateHeaderMode());\r\n-        assertEquals(DuplicateHeaderMode.DISALLOW, builder.setDuplicateHeaderMode(DuplicateHeaderMode.DISALLOW).get().getDuplicateHeaderMode());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeader() {\r\n-        final String[] header = { \"one\", \"two\", \"three\" };\r\n-        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(header);\r\n-        // getHeader() makes a copy of the header array.\r\n-        final String[] headerCopy = formatWithHeader.getHeader();\r\n-        headerCopy[0] = \"A\";\r\n-        headerCopy[1] = \"B\";\r\n-        headerCopy[2] = \"C\";\r\n-        assertFalse(Arrays.equals(formatWithHeader.getHeader(), headerCopy));\r\n-        assertNotSame(formatWithHeader.getHeader(), headerCopy);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHashCodeAndWithIgnoreHeaderCase() {\r\n-\r\n-        final CSVFormat csvFormat = CSVFormat.INFORMIX_UNLOAD_CSV;\r\n-        final CSVFormat csvFormatTwo = csvFormat.withIgnoreHeaderCase();\r\n-        csvFormatTwo.hashCode();\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertTrue(csvFormatTwo.getIgnoreHeaderCase()); // now different\r\n-        assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n-\r\n-        Assertions.assertNotEquals(csvFormatTwo, csvFormat); // CSV-244 - should not be equal\r\n-        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n-\r\n-        assertFalse(csvFormatTwo.getTrim());\r\n-\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testJiraCsv236() {\r\n-        CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(true).setHeader(\"CC\", \"VV\", \"VV\").get();\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testJiraCsv236__Deprecated() {\r\n-        CSVFormat.DEFAULT.withAllowDuplicateHeaderNames().withHeader(\"CC\", \"VV\", \"VV\");\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNewFormat() {\r\n-\r\n-        final CSVFormat csvFormat = CSVFormat.newFormat('X');\r\n-\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-        assertFalse(csvFormat.isEscapeCharacterSet());\r\n-\r\n-        assertNull(csvFormat.getRecordSeparator());\r\n-        assertNull(csvFormat.getQuoteMode());\r\n-\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-        assertFalse(csvFormat.getTrim());\r\n-\r\n-        assertFalse(csvFormat.isNullStringSet());\r\n-        assertNull(csvFormat.getEscapeCharacter());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-\r\n-        assertEquals('X', csvFormat.getDelimiter());\r\n-        assertNull(csvFormat.getNullString());\r\n-\r\n-        assertFalse(csvFormat.isQuoteCharacterSet());\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-\r\n-        assertNull(csvFormat.getQuoteCharacter());\r\n-        assertFalse(csvFormat.getIgnoreEmptyLines());\r\n-\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-        assertFalse(csvFormat.isEscapeCharacterSet());\r\n-\r\n-        assertNull(csvFormat.getRecordSeparator());\r\n-        assertNull(csvFormat.getQuoteMode());\r\n-\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-        assertFalse(csvFormat.getTrim());\r\n-\r\n-        assertFalse(csvFormat.isNullStringSet());\r\n-        assertNull(csvFormat.getEscapeCharacter());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-\r\n-        assertEquals('X', csvFormat.getDelimiter());\r\n-        assertNull(csvFormat.getNullString());\r\n-\r\n-        assertFalse(csvFormat.isQuoteCharacterSet());\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-\r\n-        assertNull(csvFormat.getQuoteCharacter());\r\n-        assertFalse(csvFormat.getIgnoreEmptyLines());\r\n-\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNullRecordSeparatorCsv106() {\r\n-        final CSVFormat format = CSVFormat.newFormat(';').builder().setSkipHeaderRecord(true).setHeader(\"H1\", \"H2\").get();\r\n-        final String formatStr = format.format(\"A\", \"B\");\r\n-        assertNotNull(formatStr);\r\n-        assertFalse(formatStr.endsWith(\"null\"));\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testNullRecordSeparatorCsv106__Deprecated() {\r\n-        final CSVFormat format = CSVFormat.newFormat(';').withSkipHeaderRecord().withHeader(\"H1\", \"H2\");\r\n-        final String formatStr = format.format(\"A\", \"B\");\r\n-        assertNotNull(formatStr);\r\n-        assertFalse(formatStr.endsWith(\"null\"));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintRecord() throws IOException {\r\n-        final Appendable out = new StringBuilder();\r\n-        final CSVFormat format = CSVFormat.RFC4180;\r\n-        format.printRecord(out, \"a\", \"b\", \"c\");\r\n-        assertEquals(\"a,b,c\" + format.getRecordSeparator(), out.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintRecordEmpty() throws IOException {\r\n-        final Appendable out = new StringBuilder();\r\n-        final CSVFormat format = CSVFormat.RFC4180;\r\n-        format.printRecord(out);\r\n-        assertEquals(format.getRecordSeparator(), out.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintWithEscapesEndWithCRLF() throws IOException {\r\n-        final Reader in = new StringReader(\"x,y,x\\r\\na,?b,c\\r\\n\");\r\n-        final Appendable out = new StringBuilder();\r\n-        final CSVFormat format = CSVFormat.RFC4180.withEscape('?').withDelimiter(',').withQuote(null).withRecordSeparator(CRLF);\r\n-        format.print(in, out, true);\r\n-        assertEquals(\"x?,y?,x?r?na?,??b?,c?r?n\", out.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintWithEscapesEndWithoutCRLF() throws IOException {\r\n-        final Reader in = new StringReader(\"x,y,x\");\r\n-        final Appendable out = new StringBuilder();\r\n-        final CSVFormat format = CSVFormat.RFC4180.withEscape('?').withDelimiter(',').withQuote(null).withRecordSeparator(CRLF);\r\n-        format.print(in, out, true);\r\n-        assertEquals(\"x?,y?,x\", out.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintWithoutQuotes() throws IOException {\r\n-        final Reader in = new StringReader(\"\");\r\n-        final Appendable out = new StringBuilder();\r\n-        final CSVFormat format = CSVFormat.RFC4180.withDelimiter(',').withQuote('\"').withEscape('?').withQuoteMode(QuoteMode.NON_NUMERIC);\r\n-        format.print(in, out, true);\r\n-        assertEquals(\"\\\"\\\"\", out.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintWithQuoteModeIsNONE() throws IOException {\r\n-        final Reader in = new StringReader(\"a,b,c\");\r\n-        final Appendable out = new StringBuilder();\r\n-        final CSVFormat format = CSVFormat.RFC4180.withDelimiter(',').withQuote('\"').withEscape('?').withQuoteMode(QuoteMode.NONE);\r\n-        format.print(in, out, true);\r\n-        assertEquals(\"a?,b?,c\", out.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintWithQuotes() throws IOException {\r\n-        final Reader in = new StringReader(\"\\\"a,b,c\\r\\nx,y,z\");\r\n-        final Appendable out = new StringBuilder();\r\n-        final CSVFormat format = CSVFormat.RFC4180.withDelimiter(',').withQuote('\"').withEscape('?').withQuoteMode(QuoteMode.NON_NUMERIC);\r\n-        format.print(in, out, true);\r\n-        assertEquals(\"\\\"\\\"\\\"a,b,c\\r\\nx,y,z\\\"\", out.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testQuoteCharSameAsCommentStartThrowsException() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setQuote('!').setCommentMarker('!').get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testQuoteCharSameAsCommentStartThrowsException_Deprecated() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote('!').withCommentMarker('!'));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType() {\r\n-        // Cannot assume that callers won't use different Character objects\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setQuote(Character.valueOf('!')).setCommentMarker('!').get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType_Deprecated() {\r\n-        // Cannot assume that callers won't use different Character objects\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote(Character.valueOf('!')).withCommentMarker('!'));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testQuoteCharSameAsDelimiterThrowsException() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setQuote('!').setDelimiter('!').get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testQuoteCharSameAsDelimiterThrowsException_Deprecated() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote('!').withDelimiter('!'));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testQuoteModeNoneShouldReturnMeaningfulExceptionMessage() {\r\n-        final Exception exception = assertThrows(IllegalArgumentException.class, () ->\r\n-        // @formatter:off\r\n-            CSVFormat.DEFAULT.builder()\r\n-                    .setHeader(\"Col1\", \"Col2\", \"Col3\", \"Col4\")\r\n-                    .setQuoteMode(QuoteMode.NONE)\r\n-                    .get()\r\n-        // @formatter:on\r\n-        );\r\n-        final String actualMessage = exception.getMessage();\r\n-        final String expectedMessage = \"Quote mode set to NONE but no escape character is set\";\r\n-        assertEquals(expectedMessage, actualMessage);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testQuotePolicyNoneWithoutEscapeThrowsException() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat('!').builder().setQuoteMode(QuoteMode.NONE).get());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"deprecation\")\r\n-    @Test\r\n-    public void testQuotePolicyNoneWithoutEscapeThrowsException_Deprecated() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat('!').withQuoteMode(QuoteMode.NONE));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRFC4180() {\r\n-        assertNull(RFC4180.getCommentMarker());\r\n-        assertEquals(',', RFC4180.getDelimiter());\r\n-        assertNull(RFC4180.getEscapeCharacter());\r\n-        assertFalse(RFC4180.getIgnoreEmptyLines());\r\n-        assertEquals(Character.valueOf('\"'), RFC4180.getQuoteCharacter());\r\n-        assertNull(RFC4180.getQuoteMode());\r\n-        assertEquals(\"\\r\\n\", RFC4180.getRecordSeparator());\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"boxing\") // no need to worry about boxing here\r\n-    @Test\r\n-    public void testSerialization() throws Exception {\r\n-        final ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n-\r\n-        try (ObjectOutputStream oos = new ObjectOutputStream(out)) {\r\n-            oos.writeObject(CSVFormat.DEFAULT);\r\n-            oos.flush();\r\n-        }\r\n-\r\n-        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\r\n-        final CSVFormat format = (CSVFormat) in.readObject();\r\n-\r\n-        assertNotNull(format);\r\n-        assertEquals(CSVFormat.DEFAULT.getDelimiter(), format.getDelimiter(), \"delimiter\");\r\n-        assertEquals(CSVFormat.DEFAULT.getQuoteCharacter(), format.getQuoteCharacter(), \"encapsulator\");\r\n-        assertEquals(CSVFormat.DEFAULT.getCommentMarker(), format.getCommentMarker(), \"comment start\");\r\n-        assertEquals(CSVFormat.DEFAULT.getRecordSeparator(), format.getRecordSeparator(), \"record separator\");\r\n-        assertEquals(CSVFormat.DEFAULT.getEscapeCharacter(), format.getEscapeCharacter(), \"escape\");\r\n-        assertEquals(CSVFormat.DEFAULT.getIgnoreSurroundingSpaces(), format.getIgnoreSurroundingSpaces(), \"trim\");\r\n-        assertEquals(CSVFormat.DEFAULT.getIgnoreEmptyLines(), format.getIgnoreEmptyLines(), \"empty lines\");\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testToString() {\r\n-\r\n-        final String string = CSVFormat.INFORMIX_UNLOAD.toString();\r\n-\r\n-        assertEquals(\"Delimiter=<|> Escape=<\\\\> QuoteChar=<\\\"> RecordSeparator=<\\n> EmptyLines:ignored SkipHeaderRecord:false\", string);\r\n-\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testToStringAndWithCommentMarkerTakingCharacter() {\r\n-\r\n-        final CSVFormat.Predefined csvFormatPredefined = CSVFormat.Predefined.Default;\r\n-        final CSVFormat csvFormat = csvFormatPredefined.getFormat();\r\n-\r\n-        assertNull(csvFormat.getEscapeCharacter());\r\n-        assertTrue(csvFormat.isQuoteCharacterSet());\r\n-\r\n-        assertFalse(csvFormat.getTrim());\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-        assertEquals(',', csvFormat.getDelimiter());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n-\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-\r\n-        assertFalse(csvFormat.isNullStringSet());\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-\r\n-        assertFalse(csvFormat.isEscapeCharacterSet());\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-\r\n-        assertNull(csvFormat.getNullString());\r\n-        assertNull(csvFormat.getQuoteMode());\r\n-\r\n-        assertTrue(csvFormat.getIgnoreEmptyLines());\r\n-        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n-\r\n-        final Character character = Character.valueOf('n');\r\n-\r\n-        final CSVFormat csvFormatTwo = csvFormat.withCommentMarker(character);\r\n-\r\n-        assertNull(csvFormat.getEscapeCharacter());\r\n-        assertTrue(csvFormat.isQuoteCharacterSet());\r\n-\r\n-        assertFalse(csvFormat.getTrim());\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-        assertEquals(',', csvFormat.getDelimiter());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n-\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-\r\n-        assertFalse(csvFormat.isNullStringSet());\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-\r\n-        assertFalse(csvFormat.isEscapeCharacterSet());\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-\r\n-        assertNull(csvFormat.getNullString());\r\n-        assertNull(csvFormat.getQuoteMode());\r\n-\r\n-        assertTrue(csvFormat.getIgnoreEmptyLines());\r\n-        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n-\r\n-        assertFalse(csvFormatTwo.isNullStringSet());\r\n-        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n-\r\n-        assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\r\n-        assertNull(csvFormatTwo.getNullString());\r\n-\r\n-        assertEquals(',', csvFormatTwo.getDelimiter());\r\n-        assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n-\r\n-        assertTrue(csvFormatTwo.isCommentMarkerSet());\r\n-        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n-\r\n-        assertFalse(csvFormatTwo.getTrim());\r\n-        assertNull(csvFormatTwo.getEscapeCharacter());\r\n-\r\n-        assertTrue(csvFormatTwo.isQuoteCharacterSet());\r\n-        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\r\n-        assertNull(csvFormatTwo.getQuoteMode());\r\n-\r\n-        assertEquals('n', (char) csvFormatTwo.getCommentMarker());\r\n-        assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n-\r\n-        assertFalse(csvFormatTwo.isEscapeCharacterSet());\r\n-        assertTrue(csvFormatTwo.getIgnoreEmptyLines());\r\n-\r\n-        assertNotSame(csvFormat, csvFormatTwo);\r\n-        assertNotSame(csvFormatTwo, csvFormat);\r\n-\r\n-        Assertions.assertNotEquals(csvFormatTwo, csvFormat);\r\n-\r\n-        assertNull(csvFormat.getEscapeCharacter());\r\n-        assertTrue(csvFormat.isQuoteCharacterSet());\r\n-\r\n-        assertFalse(csvFormat.getTrim());\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-        assertEquals(',', csvFormat.getDelimiter());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n-\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-\r\n-        assertFalse(csvFormat.isNullStringSet());\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-\r\n-        assertFalse(csvFormat.isEscapeCharacterSet());\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-\r\n-        assertNull(csvFormat.getNullString());\r\n-        assertNull(csvFormat.getQuoteMode());\r\n-\r\n-        assertTrue(csvFormat.getIgnoreEmptyLines());\r\n-        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n-\r\n-        assertFalse(csvFormatTwo.isNullStringSet());\r\n-        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n-\r\n-        assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\r\n-        assertNull(csvFormatTwo.getNullString());\r\n-\r\n-        assertEquals(',', csvFormatTwo.getDelimiter());\r\n-        assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n-\r\n-        assertTrue(csvFormatTwo.isCommentMarkerSet());\r\n-        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n-\r\n-        assertFalse(csvFormatTwo.getTrim());\r\n-        assertNull(csvFormatTwo.getEscapeCharacter());\r\n-\r\n-        assertTrue(csvFormatTwo.isQuoteCharacterSet());\r\n-        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\r\n-        assertNull(csvFormatTwo.getQuoteMode());\r\n-\r\n-        assertEquals('n', (char) csvFormatTwo.getCommentMarker());\r\n-        assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n-\r\n-        assertFalse(csvFormatTwo.isEscapeCharacterSet());\r\n-        assertTrue(csvFormatTwo.getIgnoreEmptyLines());\r\n-\r\n-        assertNotSame(csvFormat, csvFormatTwo);\r\n-        assertNotSame(csvFormatTwo, csvFormat);\r\n-\r\n-        Assertions.assertNotEquals(csvFormat, csvFormatTwo);\r\n-\r\n-        Assertions.assertNotEquals(csvFormatTwo, csvFormat);\r\n-        assertEquals(\"Delimiter=<,> QuoteChar=<\\\"> CommentStart=<n> \" + \"RecordSeparator=<\\r\\n> EmptyLines:ignored SkipHeaderRecord:false\",\r\n-                csvFormatTwo.toString());\r\n-\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testTrim() throws IOException {\r\n-        final CSVFormat formatWithTrim = CSVFormat.DEFAULT.withDelimiter(',').withTrim().withQuote(null).withRecordSeparator(CRLF);\r\n-\r\n-        CharSequence in = \"a,b,c\";\r\n-        final StringBuilder out = new StringBuilder();\r\n-        formatWithTrim.print(in, out, true);\r\n-        assertEquals(\"a,b,c\", out.toString());\r\n-\r\n-        in = new StringBuilder(\" x,y,z\");\r\n-        out.setLength(0);\r\n-        formatWithTrim.print(in, out, true);\r\n-        assertEquals(\"x,y,z\", out.toString());\r\n-\r\n-        in = new StringBuilder(\"\");\r\n-        out.setLength(0);\r\n-        formatWithTrim.print(in, out, true);\r\n-        assertEquals(\"\", out.toString());\r\n-\r\n-        in = new StringBuilder(\"header\\r\\n\");\r\n-        out.setLength(0);\r\n-        formatWithTrim.print(in, out, true);\r\n-        assertEquals(\"header\", out.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithCommentStart() {\r\n-        final CSVFormat formatWithCommentStart = CSVFormat.DEFAULT.withCommentMarker('#');\r\n-        assertEquals(Character.valueOf('#'), formatWithCommentStart.getCommentMarker());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithCommentStartCRThrowsException() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withCommentMarker(CR));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithDelimiter() {\r\n-        final CSVFormat formatWithDelimiter = CSVFormat.DEFAULT.withDelimiter('!');\r\n-        assertEquals('!', formatWithDelimiter.getDelimiter());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithDelimiterLFThrowsException() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter(LF));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithEmptyDuplicates() {\r\n-        final CSVFormat formatWithEmptyDuplicates = CSVFormat.DEFAULT.builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).get();\r\n-\r\n-        assertEquals(DuplicateHeaderMode.ALLOW_EMPTY, formatWithEmptyDuplicates.getDuplicateHeaderMode());\r\n-        assertFalse(formatWithEmptyDuplicates.getAllowDuplicateHeaderNames());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithEmptyEnum() {\r\n-        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(EmptyEnum.class);\r\n-        assertEquals(0, formatWithHeader.getHeader().length);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithEscape() {\r\n-        final CSVFormat formatWithEscape = CSVFormat.DEFAULT.withEscape('&');\r\n-        assertEquals(Character.valueOf('&'), formatWithEscape.getEscapeCharacter());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithEscapeCRThrowsExceptions() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withEscape(CR));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithFirstRecordAsHeader() {\r\n-        final CSVFormat formatWithFirstRecordAsHeader = CSVFormat.DEFAULT.withFirstRecordAsHeader();\r\n-        assertTrue(formatWithFirstRecordAsHeader.getSkipHeaderRecord());\r\n-        assertEquals(0, formatWithFirstRecordAsHeader.getHeader().length);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithHeader() {\r\n-        final String[] header = { \"one\", \"two\", \"three\" };\r\n-        // withHeader() makes a copy of the header array.\r\n-        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(header);\r\n-        assertArrayEquals(header, formatWithHeader.getHeader());\r\n-        assertNotSame(header, formatWithHeader.getHeader());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithHeaderComments() {\r\n-\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT;\r\n-\r\n-        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-\r\n-        assertFalse(csvFormat.isEscapeCharacterSet());\r\n-        assertTrue(csvFormat.isQuoteCharacterSet());\r\n-\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-        assertNull(csvFormat.getQuoteMode());\r\n-\r\n-        assertEquals(',', csvFormat.getDelimiter());\r\n-        assertTrue(csvFormat.getIgnoreEmptyLines());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-\r\n-        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-        assertFalse(csvFormat.getTrim());\r\n-\r\n-        assertFalse(csvFormat.isNullStringSet());\r\n-        assertNull(csvFormat.getNullString());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-        assertNull(csvFormat.getEscapeCharacter());\r\n-\r\n-        final Object[] objectArray = new Object[8];\r\n-        final CSVFormat csvFormatTwo = csvFormat.withHeaderComments(objectArray);\r\n-\r\n-        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-\r\n-        assertFalse(csvFormat.isEscapeCharacterSet());\r\n-        assertTrue(csvFormat.isQuoteCharacterSet());\r\n-\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-        assertNull(csvFormat.getQuoteMode());\r\n-\r\n-        assertEquals(',', csvFormat.getDelimiter());\r\n-        assertTrue(csvFormat.getIgnoreEmptyLines());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-\r\n-        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-        assertFalse(csvFormat.getTrim());\r\n-\r\n-        assertFalse(csvFormat.isNullStringSet());\r\n-        assertNull(csvFormat.getNullString());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-        assertNull(csvFormat.getEscapeCharacter());\r\n-\r\n-        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n-        assertNull(csvFormatTwo.getQuoteMode());\r\n-\r\n-        assertTrue(csvFormatTwo.getIgnoreEmptyLines());\r\n-        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertNull(csvFormatTwo.getEscapeCharacter());\r\n-        assertFalse(csvFormatTwo.getTrim());\r\n-\r\n-        assertFalse(csvFormatTwo.isEscapeCharacterSet());\r\n-        assertTrue(csvFormatTwo.isQuoteCharacterSet());\r\n-\r\n-        assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n-        assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\r\n-\r\n-        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n-        assertNull(csvFormatTwo.getNullString());\r\n-\r\n-        assertFalse(csvFormatTwo.isNullStringSet());\r\n-        assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n-\r\n-        assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\r\n-        assertEquals(',', csvFormatTwo.getDelimiter());\r\n-\r\n-        assertNull(csvFormatTwo.getCommentMarker());\r\n-        assertFalse(csvFormatTwo.isCommentMarkerSet());\r\n-\r\n-        assertNotSame(csvFormat, csvFormatTwo);\r\n-        assertNotSame(csvFormatTwo, csvFormat);\r\n-\r\n-        Assertions.assertNotEquals(csvFormatTwo, csvFormat); // CSV-244 - should not be equal\r\n-\r\n-        final String string = csvFormatTwo.format(objectArray);\r\n-\r\n-        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\r\n-        assertFalse(csvFormat.isCommentMarkerSet());\r\n-\r\n-        assertFalse(csvFormat.isEscapeCharacterSet());\r\n-        assertTrue(csvFormat.isQuoteCharacterSet());\r\n-\r\n-        assertFalse(csvFormat.getSkipHeaderRecord());\r\n-        assertNull(csvFormat.getQuoteMode());\r\n-\r\n-        assertEquals(',', csvFormat.getDelimiter());\r\n-        assertTrue(csvFormat.getIgnoreEmptyLines());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreHeaderCase());\r\n-        assertNull(csvFormat.getCommentMarker());\r\n-\r\n-        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\r\n-        assertFalse(csvFormat.getTrailingDelimiter());\r\n-\r\n-        assertFalse(csvFormat.getAllowMissingColumnNames());\r\n-        assertFalse(csvFormat.getTrim());\r\n-\r\n-        assertFalse(csvFormat.isNullStringSet());\r\n-        assertNull(csvFormat.getNullString());\r\n-\r\n-        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\r\n-        assertNull(csvFormat.getEscapeCharacter());\r\n-\r\n-        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\r\n-        assertNull(csvFormatTwo.getQuoteMode());\r\n-\r\n-        assertTrue(csvFormatTwo.getIgnoreEmptyLines());\r\n-        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\r\n-\r\n-        assertNull(csvFormatTwo.getEscapeCharacter());\r\n-        assertFalse(csvFormatTwo.getTrim());\r\n-\r\n-        assertFalse(csvFormatTwo.isEscapeCharacterSet());\r\n-        assertTrue(csvFormatTwo.isQuoteCharacterSet());\r\n-\r\n-        assertFalse(csvFormatTwo.getSkipHeaderRecord());\r\n-        assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\r\n-\r\n-        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\r\n-        assertNull(csvFormatTwo.getNullString());\r\n-\r\n-        assertFalse(csvFormatTwo.isNullStringSet());\r\n-        assertFalse(csvFormatTwo.getTrailingDelimiter());\r\n-\r\n-        assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\r\n-        assertEquals(',', csvFormatTwo.getDelimiter());\r\n-\r\n-        assertNull(csvFormatTwo.getCommentMarker());\r\n-        assertFalse(csvFormatTwo.isCommentMarkerSet());\r\n-\r\n-        assertNotSame(csvFormat, csvFormatTwo);\r\n-        assertNotSame(csvFormatTwo, csvFormat);\r\n-\r\n-        assertNotNull(string);\r\n-        Assertions.assertNotEquals(csvFormat, csvFormatTwo); // CSV-244 - should not be equal\r\n-\r\n-        Assertions.assertNotEquals(csvFormatTwo, csvFormat); // CSV-244 - should not be equal\r\n-        assertEquals(\",,,,,,,\", string);\r\n-\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithHeaderEnum() {\r\n-        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(Header.class);\r\n-        assertArrayEquals(new String[] { \"Name\", \"Email\", \"Phone\" }, formatWithHeader.getHeader());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithHeaderEnumNull() {\r\n-        final CSVFormat format = CSVFormat.DEFAULT;\r\n-        final Class<Enum<?>> simpleName = null;\r\n-        format.withHeader(simpleName);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithHeaderResultSetNull() throws SQLException {\r\n-        final CSVFormat format = CSVFormat.DEFAULT;\r\n-        final ResultSet resultSet = null;\r\n-        format.withHeader(resultSet);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithIgnoreEmptyLines() {\r\n-        assertFalse(CSVFormat.DEFAULT.withIgnoreEmptyLines(false).getIgnoreEmptyLines());\r\n-        assertTrue(CSVFormat.DEFAULT.withIgnoreEmptyLines().getIgnoreEmptyLines());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithIgnoreSurround() {\r\n-        assertFalse(CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(false).getIgnoreSurroundingSpaces());\r\n-        assertTrue(CSVFormat.DEFAULT.withIgnoreSurroundingSpaces().getIgnoreSurroundingSpaces());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithNullString() {\r\n-        final CSVFormat formatWithNullString = CSVFormat.DEFAULT.withNullString(\"null\");\r\n-        assertEquals(\"null\", formatWithNullString.getNullString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithQuoteChar() {\r\n-        final CSVFormat formatWithQuoteChar = CSVFormat.DEFAULT.withQuote('\"');\r\n-        assertEquals(Character.valueOf('\"'), formatWithQuoteChar.getQuoteCharacter());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithQuoteLFThrowsException() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote(LF));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithQuotePolicy() {\r\n-        final CSVFormat formatWithQuotePolicy = CSVFormat.DEFAULT.withQuoteMode(QuoteMode.ALL);\r\n-        assertEquals(QuoteMode.ALL, formatWithQuotePolicy.getQuoteMode());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithRecordSeparatorCR() {\r\n-        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator(CR);\r\n-        assertEquals(String.valueOf(CR), formatWithRecordSeparator.getRecordSeparator());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithRecordSeparatorCRLF() {\r\n-        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator(CRLF);\r\n-        assertEquals(CRLF, formatWithRecordSeparator.getRecordSeparator());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithRecordSeparatorLF() {\r\n-        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator(LF);\r\n-        assertEquals(String.valueOf(LF), formatWithRecordSeparator.getRecordSeparator());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testWithSystemRecordSeparator() {\r\n-        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withSystemRecordSeparator();\r\n-        assertEquals(System.lineSeparator(), formatWithRecordSeparator.getRecordSeparator());\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import static org.apache.commons.csv.CSVFormat.RFC4180;\n+import static org.apache.commons.csv.Constants.CR;\n+import static org.apache.commons.csv.Constants.CRLF;\n+import static org.apache.commons.csv.Constants.LF;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+import org.apache.commons.csv.CSVFormat.Builder;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * Tests {@link CSVFormat}.\n+ */\n+public class CSVFormatTest {\n+\n+    public enum EmptyEnum {\n+        // empty enum.\n+    }\n+\n+    public enum Header {\n+        Name, Email, Phone\n+    }\n+\n+    private static void assertNotEquals(final Object right, final Object left) {\n+        Assertions.assertNotEquals(right, left);\n+        Assertions.assertNotEquals(left, right);\n+    }\n+\n+    private static CSVFormat copy(final CSVFormat format) {\n+        return format.builder().setDelimiter(format.getDelimiter()).get();\n+    }\n+\n+    private void assertNotEquals(final String name, final String type, final Object left, final Object right) {\n+        if (left.equals(right) || right.equals(left)) {\n+            fail(\"Objects must not compare equal for \" + name + \"(\" + type + \")\");\n+        }\n+        if (left.hashCode() == right.hashCode()) {\n+            fail(\"Hash code should not be equal for \" + name + \"(\" + type + \")\");\n+        }\n+    }\n+\n+    @Test\n+    public void testBuildVsGet() {\n+        final Builder builder = CSVFormat.DEFAULT.builder();\n+        assertNotSame(builder.get(), builder.build());\n+    }\n+\n+    @Test\n+    public void testDelimiterEmptyStringThrowsException1() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter(\"\").get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testDelimiterSameAsCommentStartThrowsException_Deprecated() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter('!').withCommentMarker('!'));\n+    }\n+\n+    @Test\n+    public void testDelimiterSameAsCommentStartThrowsException1() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter('!').setCommentMarker('!').get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testDelimiterSameAsEscapeThrowsException_Deprecated() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter('!').withEscape('!'));\n+    }\n+\n+    @Test\n+    public void testDelimiterSameAsEscapeThrowsException1() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter('!').setEscape('!').get());\n+    }\n+\n+    @Test\n+    public void testDelimiterSameAsRecordSeparatorThrowsException() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat(CR));\n+    }\n+\n+    @Test\n+    public void testDuplicateHeaderElements() {\n+        final String[] header = { \"A\", \"A\" };\n+        final CSVFormat format = CSVFormat.DEFAULT.builder().setHeader(header).get();\n+        assertEquals(2, format.getHeader().length);\n+        assertArrayEquals(header, format.getHeader());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testDuplicateHeaderElements_Deprecated() {\n+        final String[] header = { \"A\", \"A\" };\n+        final CSVFormat format = CSVFormat.DEFAULT.withHeader(header);\n+        assertEquals(2, format.getHeader().length);\n+        assertArrayEquals(header, format.getHeader());\n+    }\n+\n+    @Test\n+    public void testDuplicateHeaderElementsFalse() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(false).setHeader(\"A\", \"A\").get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testDuplicateHeaderElementsFalse_Deprecated() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withAllowDuplicateHeaderNames(false).withHeader(\"A\", \"A\"));\n+    }\n+\n+    @Test\n+    public void testDuplicateHeaderElementsTrue() {\n+        CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(true).setHeader(\"A\", \"A\").get();\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testDuplicateHeaderElementsTrue_Deprecated() {\n+        CSVFormat.DEFAULT.withAllowDuplicateHeaderNames(true).withHeader(\"A\", \"A\");\n+    }\n+\n+    @Test\n+    public void testDuplicateHeaderElementsTrueContainsEmpty1() {\n+        CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(false).setHeader(\"A\", \"\", \"B\", \"\").get();\n+    }\n+\n+    @Test\n+    public void testDuplicateHeaderElementsTrueContainsEmpty2() {\n+        CSVFormat.DEFAULT.builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).setHeader(\"A\", \"\", \"B\", \"\").get();\n+    }\n+\n+    @Test\n+    public void testDuplicateHeaderElementsTrueContainsEmpty3() {\n+        CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(false).setAllowMissingColumnNames(true).setHeader(\"A\", \"\", \"B\", \"\").get();\n+    }\n+\n+    @Test\n+    public void testEquals() {\n+        final CSVFormat right = CSVFormat.DEFAULT;\n+        final CSVFormat left = copy(right);\n+        Assertions.assertNotEquals(null, right);\n+        Assertions.assertNotEquals(\"A String Instance\", right);\n+        assertEquals(right, right);\n+        assertEquals(right, left);\n+        assertEquals(left, right);\n+        assertEquals(right.hashCode(), right.hashCode());\n+        assertEquals(right.hashCode(), left.hashCode());\n+    }\n+\n+    @Test\n+    public void testEqualsCommentStart() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').setCommentMarker('#').setQuoteMode(QuoteMode.ALL).get();\n+        final CSVFormat left = right.builder().setCommentMarker('!').get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsCommentStart_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"').withCommentMarker('#').withQuoteMode(QuoteMode.ALL);\n+        final CSVFormat left = right.withCommentMarker('!');\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsDelimiter() {\n+        final CSVFormat right = CSVFormat.newFormat('!');\n+        final CSVFormat left = CSVFormat.newFormat('?');\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsEscape() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').setCommentMarker('#').setEscape('+').setQuoteMode(QuoteMode.ALL).get();\n+        final CSVFormat left = right.builder().setEscape('!').get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsEscape_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"').withCommentMarker('#').withEscape('+').withQuoteMode(QuoteMode.ALL);\n+        final CSVFormat left = right.withEscape('!');\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsHash() throws Exception {\n+        final Method[] methods = CSVFormat.class.getDeclaredMethods();\n+        for (final Method method : methods) {\n+            if (Modifier.isPublic(method.getModifiers())) {\n+                final String name = method.getName();\n+                if (name.startsWith(\"with\")) {\n+                    for (final Class<?> cls : method.getParameterTypes()) {\n+                        final String type = cls.getCanonicalName();\n+                        switch (type) {\n+                        case \"boolean\": {\n+                            final Object defTrue = method.invoke(CSVFormat.DEFAULT, Boolean.TRUE);\n+                            final Object defFalse = method.invoke(CSVFormat.DEFAULT, Boolean.FALSE);\n+                            assertNotEquals(name, type, defTrue, defFalse);\n+                            break;\n+                        }\n+                        case \"char\": {\n+                            final Object a = method.invoke(CSVFormat.DEFAULT, 'a');\n+                            final Object b = method.invoke(CSVFormat.DEFAULT, 'b');\n+                            assertNotEquals(name, type, a, b);\n+                            break;\n+                        }\n+                        case \"java.lang.Character\": {\n+                            final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { null });\n+                            final Object b = method.invoke(CSVFormat.DEFAULT, Character.valueOf('d'));\n+                            assertNotEquals(name, type, a, b);\n+                            break;\n+                        }\n+                        case \"java.lang.String\": {\n+                            final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { null });\n+                            final Object b = method.invoke(CSVFormat.DEFAULT, \"e\");\n+                            assertNotEquals(name, type, a, b);\n+                            break;\n+                        }\n+                        case \"java.lang.String[]\": {\n+                            final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { new String[] { null, null } });\n+                            final Object b = method.invoke(CSVFormat.DEFAULT, new Object[] { new String[] { \"f\", \"g\" } });\n+                            assertNotEquals(name, type, a, b);\n+                            break;\n+                        }\n+                        case \"org.apache.commons.csv.QuoteMode\": {\n+                            final Object a = method.invoke(CSVFormat.DEFAULT, QuoteMode.MINIMAL);\n+                            final Object b = method.invoke(CSVFormat.DEFAULT, QuoteMode.ALL);\n+                            assertNotEquals(name, type, a, b);\n+                            break;\n+                        }\n+                        case \"org.apache.commons.csv.DuplicateHeaderMode\": {\n+                            final Object a = method.invoke(CSVFormat.DEFAULT, DuplicateHeaderMode.ALLOW_ALL);\n+                            final Object b = method.invoke(CSVFormat.DEFAULT, DuplicateHeaderMode.DISALLOW);\n+                            assertNotEquals(name, type, a, b);\n+                            break;\n+                        }\n+                        case \"java.lang.Object[]\": {\n+                            final Object a = method.invoke(CSVFormat.DEFAULT, new Object[] { new Object[] { null, null } });\n+                            final Object b = method.invoke(CSVFormat.DEFAULT, new Object[] { new Object[] { new Object(), new Object() } });\n+                            assertNotEquals(name, type, a, b);\n+                            break;\n+                        }\n+                        default:\n+                            if (\"withHeader\".equals(name)) { // covered above by String[]\n+                                // ignored\n+                            } else {\n+                                fail(\"Unhandled method: \" + name + \"(\" + type + \")\");\n+                            }\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testEqualsHeader() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setHeader(\"One\", \"Two\", \"Three\")\n+                .setIgnoreEmptyLines(true).setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\n+        final CSVFormat left = right.builder().setHeader(\"Three\", \"Two\", \"One\").get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsHeader_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withHeader(\"One\", \"Two\", \"Three\")\n+                .withIgnoreEmptyLines().withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL);\n+        final CSVFormat left = right.withHeader(\"Three\", \"Two\", \"One\");\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsIgnoreEmptyLines() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true)\n+                .setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\n+        final CSVFormat left = right.builder().setIgnoreEmptyLines(false).get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsIgnoreEmptyLines_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withCommentMarker('#').withEscape('+').withIgnoreEmptyLines().withIgnoreSurroundingSpaces()\n+                .withQuote('\"').withQuoteMode(QuoteMode.ALL);\n+        final CSVFormat left = right.withIgnoreEmptyLines(false);\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsIgnoreSurroundingSpaces() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setCommentMarker('#').setEscape('+').setIgnoreSurroundingSpaces(true).setQuote('\"')\n+                .setQuoteMode(QuoteMode.ALL).get();\n+        final CSVFormat left = right.builder().setIgnoreSurroundingSpaces(false).get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsIgnoreSurroundingSpaces_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withCommentMarker('#').withEscape('+').withIgnoreSurroundingSpaces().withQuote('\"')\n+                .withQuoteMode(QuoteMode.ALL);\n+        final CSVFormat left = right.withIgnoreSurroundingSpaces(false);\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsLeftNoQuoteRightQuote() {\n+        final CSVFormat left = CSVFormat.newFormat(',').builder().setQuote(null).get();\n+        final CSVFormat right = left.builder().setQuote('#').get();\n+\n+        assertNotEquals(left, right);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsLeftNoQuoteRightQuote_Deprecated() {\n+        final CSVFormat left = CSVFormat.newFormat(',').withQuote(null);\n+        final CSVFormat right = left.withQuote('#');\n+\n+        assertNotEquals(left, right);\n+    }\n+\n+    @Test\n+    public void testEqualsNoQuotes() {\n+        final CSVFormat left = CSVFormat.newFormat(',').builder().setQuote(null).get();\n+        final CSVFormat right = left.builder().setQuote(null).get();\n+\n+        assertEquals(left, right);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsNoQuotes_Deprecated() {\n+        final CSVFormat left = CSVFormat.newFormat(',').withQuote(null);\n+        final CSVFormat right = left.withQuote(null);\n+\n+        assertEquals(left, right);\n+    }\n+\n+    @Test\n+    public void testEqualsNullString() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true)\n+                .setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).setNullString(\"null\").get();\n+        final CSVFormat left = right.builder().setNullString(\"---\").get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsNullString_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withIgnoreEmptyLines()\n+                .withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL).withNullString(\"null\");\n+        final CSVFormat left = right.withNullString(\"---\");\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsOne() {\n+\n+        final CSVFormat csvFormatOne = CSVFormat.INFORMIX_UNLOAD;\n+        final CSVFormat csvFormatTwo = CSVFormat.MYSQL;\n+\n+        assertEquals('\\\\', (char) csvFormatOne.getEscapeCharacter());\n+        assertEquals('\\\\', csvFormatOne.getEscapeChar());\n+        assertNull(csvFormatOne.getQuoteMode());\n+\n+        assertTrue(csvFormatOne.getIgnoreEmptyLines());\n+        assertFalse(csvFormatOne.getSkipHeaderRecord());\n+\n+        assertFalse(csvFormatOne.getIgnoreHeaderCase());\n+        assertNull(csvFormatOne.getCommentMarker());\n+\n+        assertFalse(csvFormatOne.isCommentMarkerSet());\n+        assertTrue(csvFormatOne.isQuoteCharacterSet());\n+\n+        assertEquals('|', csvFormatOne.getDelimiter());\n+        assertFalse(csvFormatOne.getAllowMissingColumnNames());\n+\n+        assertTrue(csvFormatOne.isEscapeCharacterSet());\n+        assertEquals(\"\\n\", csvFormatOne.getRecordSeparator());\n+\n+        assertEquals('\\\"', (char) csvFormatOne.getQuoteCharacter());\n+        assertFalse(csvFormatOne.getTrailingDelimiter());\n+\n+        assertFalse(csvFormatOne.getTrim());\n+        assertFalse(csvFormatOne.isNullStringSet());\n+\n+        assertNull(csvFormatOne.getNullString());\n+        assertFalse(csvFormatOne.getIgnoreSurroundingSpaces());\n+\n+        assertTrue(csvFormatTwo.isEscapeCharacterSet());\n+        assertNull(csvFormatTwo.getQuoteCharacter());\n+\n+        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\n+        assertEquals(QuoteMode.ALL_NON_NULL, csvFormatTwo.getQuoteMode());\n+\n+        assertEquals('\\t', csvFormatTwo.getDelimiter());\n+        assertArrayEquals(new char[] { '\\t' }, csvFormatTwo.getDelimiterCharArray());\n+        assertEquals(\"\\t\", csvFormatTwo.getDelimiterString());\n+        assertEquals(\"\\n\", csvFormatTwo.getRecordSeparator());\n+\n+        assertFalse(csvFormatTwo.isQuoteCharacterSet());\n+        assertTrue(csvFormatTwo.isNullStringSet());\n+\n+        assertEquals('\\\\', (char) csvFormatTwo.getEscapeCharacter());\n+        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\n+\n+        assertFalse(csvFormatTwo.getTrim());\n+        assertFalse(csvFormatTwo.getIgnoreEmptyLines());\n+\n+        assertEquals(\"\\\\N\", csvFormatTwo.getNullString());\n+        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\n+\n+        assertFalse(csvFormatTwo.getTrailingDelimiter());\n+        assertFalse(csvFormatTwo.getSkipHeaderRecord());\n+\n+        assertNull(csvFormatTwo.getCommentMarker());\n+        assertFalse(csvFormatTwo.isCommentMarkerSet());\n+\n+        assertNotSame(csvFormatTwo, csvFormatOne);\n+        Assertions.assertNotEquals(csvFormatTwo, csvFormatOne);\n+\n+        assertEquals('\\\\', (char) csvFormatOne.getEscapeCharacter());\n+        assertNull(csvFormatOne.getQuoteMode());\n+\n+        assertTrue(csvFormatOne.getIgnoreEmptyLines());\n+        assertFalse(csvFormatOne.getSkipHeaderRecord());\n+\n+        assertFalse(csvFormatOne.getIgnoreHeaderCase());\n+        assertNull(csvFormatOne.getCommentMarker());\n+\n+        assertFalse(csvFormatOne.isCommentMarkerSet());\n+        assertTrue(csvFormatOne.isQuoteCharacterSet());\n+\n+        assertEquals('|', csvFormatOne.getDelimiter());\n+        assertFalse(csvFormatOne.getAllowMissingColumnNames());\n+\n+        assertTrue(csvFormatOne.isEscapeCharacterSet());\n+        assertEquals(\"\\n\", csvFormatOne.getRecordSeparator());\n+\n+        assertEquals('\\\"', (char) csvFormatOne.getQuoteCharacter());\n+        assertFalse(csvFormatOne.getTrailingDelimiter());\n+\n+        assertFalse(csvFormatOne.getTrim());\n+        assertFalse(csvFormatOne.isNullStringSet());\n+\n+        assertNull(csvFormatOne.getNullString());\n+        assertFalse(csvFormatOne.getIgnoreSurroundingSpaces());\n+\n+        assertTrue(csvFormatTwo.isEscapeCharacterSet());\n+        assertNull(csvFormatTwo.getQuoteCharacter());\n+\n+        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\n+        assertEquals(QuoteMode.ALL_NON_NULL, csvFormatTwo.getQuoteMode());\n+\n+        assertEquals('\\t', csvFormatTwo.getDelimiter());\n+        assertEquals(\"\\n\", csvFormatTwo.getRecordSeparator());\n+\n+        assertFalse(csvFormatTwo.isQuoteCharacterSet());\n+        assertTrue(csvFormatTwo.isNullStringSet());\n+\n+        assertEquals('\\\\', (char) csvFormatTwo.getEscapeCharacter());\n+        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\n+\n+        assertFalse(csvFormatTwo.getTrim());\n+        assertFalse(csvFormatTwo.getIgnoreEmptyLines());\n+\n+        assertEquals(\"\\\\N\", csvFormatTwo.getNullString());\n+        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\n+\n+        assertFalse(csvFormatTwo.getTrailingDelimiter());\n+        assertFalse(csvFormatTwo.getSkipHeaderRecord());\n+\n+        assertNull(csvFormatTwo.getCommentMarker());\n+        assertFalse(csvFormatTwo.isCommentMarkerSet());\n+\n+        assertNotSame(csvFormatOne, csvFormatTwo);\n+        assertNotSame(csvFormatTwo, csvFormatOne);\n+\n+        Assertions.assertNotEquals(csvFormatOne, csvFormatTwo);\n+        Assertions.assertNotEquals(csvFormatTwo, csvFormatOne);\n+\n+        Assertions.assertNotEquals(csvFormatTwo, csvFormatOne);\n+\n+    }\n+\n+    @Test\n+    public void testEqualsQuoteChar() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').get();\n+        final CSVFormat left = right.builder().setQuote('!').get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsQuoteChar_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"');\n+        final CSVFormat left = right.withQuote('!');\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsQuotePolicy() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\n+        final CSVFormat left = right.builder().setQuoteMode(QuoteMode.MINIMAL).get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsQuotePolicy_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"').withQuoteMode(QuoteMode.ALL);\n+        final CSVFormat left = right.withQuoteMode(QuoteMode.MINIMAL);\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsRecordSeparator() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true)\n+                .setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).get();\n+        final CSVFormat left = right.builder().setRecordSeparator(LF).get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsRecordSeparator_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withIgnoreEmptyLines()\n+                .withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL);\n+        final CSVFormat left = right.withRecordSeparator(LF);\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    public void testEqualsSkipHeaderRecord() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').builder().setRecordSeparator(CR).setCommentMarker('#').setEscape('+').setIgnoreEmptyLines(true)\n+                .setIgnoreSurroundingSpaces(true).setQuote('\"').setQuoteMode(QuoteMode.ALL).setNullString(\"null\").setSkipHeaderRecord(true).get();\n+        final CSVFormat left = right.builder().setSkipHeaderRecord(false).get();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEqualsSkipHeaderRecord_Deprecated() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withRecordSeparator(CR).withCommentMarker('#').withEscape('+').withIgnoreEmptyLines()\n+                .withIgnoreSurroundingSpaces().withQuote('\"').withQuoteMode(QuoteMode.ALL).withNullString(\"null\").withSkipHeaderRecord();\n+        final CSVFormat left = right.withSkipHeaderRecord(false);\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsWithNull() {\n+\n+        final CSVFormat csvFormat = CSVFormat.POSTGRESQL_TEXT;\n+\n+        assertEquals('\\\\', (char) csvFormat.getEscapeCharacter());\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+        assertFalse(csvFormat.getTrim());\n+\n+        assertFalse(csvFormat.isQuoteCharacterSet());\n+        assertEquals(\"\\\\N\", csvFormat.getNullString());\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertTrue(csvFormat.isEscapeCharacterSet());\n+\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+        assertNull(csvFormat.getCommentMarker());\n+\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+        assertEquals(QuoteMode.ALL_NON_NULL, csvFormat.getQuoteMode());\n+\n+        assertEquals('\\t', csvFormat.getDelimiter());\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+\n+        assertEquals(\"\\n\", csvFormat.getRecordSeparator());\n+        assertFalse(csvFormat.getIgnoreEmptyLines());\n+\n+        assertNull(csvFormat.getQuoteCharacter());\n+        assertTrue(csvFormat.isNullStringSet());\n+\n+        assertEquals('\\\\', (char) csvFormat.getEscapeCharacter());\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+        assertFalse(csvFormat.getTrim());\n+\n+        assertFalse(csvFormat.isQuoteCharacterSet());\n+        assertEquals(\"\\\\N\", csvFormat.getNullString());\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertTrue(csvFormat.isEscapeCharacterSet());\n+\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+        assertNull(csvFormat.getCommentMarker());\n+\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+        assertEquals(QuoteMode.ALL_NON_NULL, csvFormat.getQuoteMode());\n+\n+        assertEquals('\\t', csvFormat.getDelimiter());\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+\n+        assertEquals(\"\\n\", csvFormat.getRecordSeparator());\n+        assertFalse(csvFormat.getIgnoreEmptyLines());\n+\n+        assertNull(csvFormat.getQuoteCharacter());\n+        assertTrue(csvFormat.isNullStringSet());\n+\n+        Assertions.assertNotEquals(null, csvFormat);\n+\n+    }\n+\n+    @Test\n+    public void testEscapeSameAsCommentStartThrowsException() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setEscape('!').setCommentMarker('!').get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEscapeSameAsCommentStartThrowsException_Deprecated() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withEscape('!').withCommentMarker('!'));\n+    }\n+\n+    @Test\n+    public void testEscapeSameAsCommentStartThrowsExceptionForWrapperType() {\n+        // Cannot assume that callers won't use different Character objects\n+        assertThrows(IllegalArgumentException.class,\n+                () -> CSVFormat.DEFAULT.builder().setEscape(Character.valueOf('!')).setCommentMarker(Character.valueOf('!')).get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testEscapeSameAsCommentStartThrowsExceptionForWrapperType_Deprecated() {\n+        // Cannot assume that callers won't use different Character objects\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withEscape(Character.valueOf('!')).withCommentMarker(Character.valueOf('!')));\n+    }\n+\n+    @Test\n+    public void testFormat() {\n+        final CSVFormat format = CSVFormat.DEFAULT;\n+\n+        assertEquals(\"\", format.format());\n+        assertEquals(\"a,b,c\", format.format(\"a\", \"b\", \"c\"));\n+        assertEquals(\"\\\"x,y\\\",z\", format.format(\"x,y\", \"z\"));\n+    }\n+\n+    @Test // I assume this to be a defect.\n+    public void testFormatThrowsNullPointerException() {\n+\n+        final CSVFormat csvFormat = CSVFormat.MYSQL;\n+\n+        final NullPointerException e = assertThrows(NullPointerException.class, () -> csvFormat.format((Object[]) null));\n+        assertEquals(Objects.class.getName(), e.getStackTrace()[0].getClassName());\n+    }\n+\n+    @Test\n+    public void testFormatToString() {\n+        // @formatter:off\n+        final CSVFormat format = CSVFormat.RFC4180\n+                .withEscape('?')\n+                .withDelimiter(',')\n+                .withQuoteMode(QuoteMode.MINIMAL)\n+                .withRecordSeparator(CRLF)\n+                .withQuote('\"')\n+                .withNullString(\"\")\n+                .withIgnoreHeaderCase(true)\n+                .withHeaderComments(\"This is HeaderComments\")\n+                .withHeader(\"col1\", \"col2\", \"col3\");\n+        // @formatter:on\n+        assertEquals(\n+                \"Delimiter=<,> Escape=<?> QuoteChar=<\\\"> QuoteMode=<MINIMAL> NullString=<> RecordSeparator=<\" + CRLF +\n+                        \"> IgnoreHeaderCase:ignored SkipHeaderRecord:false HeaderComments:[This is HeaderComments] Header:[col1, col2, col3]\",\n+                format.toString());\n+    }\n+\n+    @Test\n+    public void testGetAllowDuplicateHeaderNames() {\n+        final Builder builder = CSVFormat.DEFAULT.builder();\n+        assertTrue(builder.get().getAllowDuplicateHeaderNames());\n+        assertTrue(builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).get().getAllowDuplicateHeaderNames());\n+        assertFalse(builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).get().getAllowDuplicateHeaderNames());\n+        assertFalse(builder.setDuplicateHeaderMode(DuplicateHeaderMode.DISALLOW).get().getAllowDuplicateHeaderNames());\n+    }\n+\n+    @Test\n+    public void testGetDuplicateHeaderMode() {\n+        final Builder builder = CSVFormat.DEFAULT.builder();\n+\n+        assertEquals(DuplicateHeaderMode.ALLOW_ALL, builder.get().getDuplicateHeaderMode());\n+        assertEquals(DuplicateHeaderMode.ALLOW_ALL, builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).get().getDuplicateHeaderMode());\n+        assertEquals(DuplicateHeaderMode.ALLOW_EMPTY, builder.setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).get().getDuplicateHeaderMode());\n+        assertEquals(DuplicateHeaderMode.DISALLOW, builder.setDuplicateHeaderMode(DuplicateHeaderMode.DISALLOW).get().getDuplicateHeaderMode());\n+    }\n+\n+    @Test\n+    public void testGetHeader() {\n+        final String[] header = { \"one\", \"two\", \"three\" };\n+        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(header);\n+        // getHeader() makes a copy of the header array.\n+        final String[] headerCopy = formatWithHeader.getHeader();\n+        headerCopy[0] = \"A\";\n+        headerCopy[1] = \"B\";\n+        headerCopy[2] = \"C\";\n+        assertFalse(Arrays.equals(formatWithHeader.getHeader(), headerCopy));\n+        assertNotSame(formatWithHeader.getHeader(), headerCopy);\n+    }\n+\n+    @Test\n+    public void testHashCodeAndWithIgnoreHeaderCase() {\n+\n+        final CSVFormat csvFormat = CSVFormat.INFORMIX_UNLOAD_CSV;\n+        final CSVFormat csvFormatTwo = csvFormat.withIgnoreHeaderCase();\n+        csvFormatTwo.hashCode();\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertTrue(csvFormatTwo.getIgnoreHeaderCase()); // now different\n+        assertFalse(csvFormatTwo.getTrailingDelimiter());\n+\n+        Assertions.assertNotEquals(csvFormatTwo, csvFormat); // CSV-244 - should not be equal\n+        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\n+\n+        assertFalse(csvFormatTwo.getTrim());\n+\n+    }\n+\n+    @Test\n+    public void testJiraCsv236() {\n+        CSVFormat.DEFAULT.builder().setAllowDuplicateHeaderNames(true).setHeader(\"CC\", \"VV\", \"VV\").get();\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testJiraCsv236__Deprecated() {\n+        CSVFormat.DEFAULT.withAllowDuplicateHeaderNames().withHeader(\"CC\", \"VV\", \"VV\");\n+    }\n+\n+    @Test\n+    public void testNewFormat() {\n+\n+        final CSVFormat csvFormat = CSVFormat.newFormat('X');\n+\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+        assertFalse(csvFormat.isEscapeCharacterSet());\n+\n+        assertNull(csvFormat.getRecordSeparator());\n+        assertNull(csvFormat.getQuoteMode());\n+\n+        assertNull(csvFormat.getCommentMarker());\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+        assertFalse(csvFormat.getTrim());\n+\n+        assertFalse(csvFormat.isNullStringSet());\n+        assertNull(csvFormat.getEscapeCharacter());\n+\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+\n+        assertEquals('X', csvFormat.getDelimiter());\n+        assertNull(csvFormat.getNullString());\n+\n+        assertFalse(csvFormat.isQuoteCharacterSet());\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+\n+        assertNull(csvFormat.getQuoteCharacter());\n+        assertFalse(csvFormat.getIgnoreEmptyLines());\n+\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+        assertFalse(csvFormat.isEscapeCharacterSet());\n+\n+        assertNull(csvFormat.getRecordSeparator());\n+        assertNull(csvFormat.getQuoteMode());\n+\n+        assertNull(csvFormat.getCommentMarker());\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+        assertFalse(csvFormat.getTrim());\n+\n+        assertFalse(csvFormat.isNullStringSet());\n+        assertNull(csvFormat.getEscapeCharacter());\n+\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+\n+        assertEquals('X', csvFormat.getDelimiter());\n+        assertNull(csvFormat.getNullString());\n+\n+        assertFalse(csvFormat.isQuoteCharacterSet());\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+\n+        assertNull(csvFormat.getQuoteCharacter());\n+        assertFalse(csvFormat.getIgnoreEmptyLines());\n+\n+    }\n+\n+    @Test\n+    public void testNullRecordSeparatorCsv106() {\n+        final CSVFormat format = CSVFormat.newFormat(';').builder().setSkipHeaderRecord(true).setHeader(\"H1\", \"H2\").get();\n+        final String formatStr = format.format(\"A\", \"B\");\n+        assertNotNull(formatStr);\n+        assertFalse(formatStr.endsWith(\"null\"));\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testNullRecordSeparatorCsv106__Deprecated() {\n+        final CSVFormat format = CSVFormat.newFormat(';').withSkipHeaderRecord().withHeader(\"H1\", \"H2\");\n+        final String formatStr = format.format(\"A\", \"B\");\n+        assertNotNull(formatStr);\n+        assertFalse(formatStr.endsWith(\"null\"));\n+    }\n+\n+    @Test\n+    public void testPrintRecord() throws IOException {\n+        final Appendable out = new StringBuilder();\n+        final CSVFormat format = CSVFormat.RFC4180;\n+        format.printRecord(out, \"a\", \"b\", \"c\");\n+        assertEquals(\"a,b,c\" + format.getRecordSeparator(), out.toString());\n+    }\n+\n+    @Test\n+    public void testPrintRecordEmpty() throws IOException {\n+        final Appendable out = new StringBuilder();\n+        final CSVFormat format = CSVFormat.RFC4180;\n+        format.printRecord(out);\n+        assertEquals(format.getRecordSeparator(), out.toString());\n+    }\n+\n+    @Test\n+    public void testPrintWithEscapesEndWithCRLF() throws IOException {\n+        final Reader in = new StringReader(\"x,y,x\\r\\na,?b,c\\r\\n\");\n+        final Appendable out = new StringBuilder();\n+        final CSVFormat format = CSVFormat.RFC4180.withEscape('?').withDelimiter(',').withQuote(null).withRecordSeparator(CRLF);\n+        format.print(in, out, true);\n+        assertEquals(\"x?,y?,x?r?na?,??b?,c?r?n\", out.toString());\n+    }\n+\n+    @Test\n+    public void testPrintWithEscapesEndWithoutCRLF() throws IOException {\n+        final Reader in = new StringReader(\"x,y,x\");\n+        final Appendable out = new StringBuilder();\n+        final CSVFormat format = CSVFormat.RFC4180.withEscape('?').withDelimiter(',').withQuote(null).withRecordSeparator(CRLF);\n+        format.print(in, out, true);\n+        assertEquals(\"x?,y?,x\", out.toString());\n+    }\n+\n+    @Test\n+    public void testPrintWithoutQuotes() throws IOException {\n+        final Reader in = new StringReader(\"\");\n+        final Appendable out = new StringBuilder();\n+        final CSVFormat format = CSVFormat.RFC4180.withDelimiter(',').withQuote('\"').withEscape('?').withQuoteMode(QuoteMode.NON_NUMERIC);\n+        format.print(in, out, true);\n+        assertEquals(\"\\\"\\\"\", out.toString());\n+    }\n+\n+    @Test\n+    public void testPrintWithQuoteModeIsNONE() throws IOException {\n+        final Reader in = new StringReader(\"a,b,c\");\n+        final Appendable out = new StringBuilder();\n+        final CSVFormat format = CSVFormat.RFC4180.withDelimiter(',').withQuote('\"').withEscape('?').withQuoteMode(QuoteMode.NONE);\n+        format.print(in, out, true);\n+        assertEquals(\"a?,b?,c\", out.toString());\n+    }\n+\n+    @Test\n+    public void testPrintWithQuotes() throws IOException {\n+        final Reader in = new StringReader(\"\\\"a,b,c\\r\\nx,y,z\");\n+        final Appendable out = new StringBuilder();\n+        final CSVFormat format = CSVFormat.RFC4180.withDelimiter(',').withQuote('\"').withEscape('?').withQuoteMode(QuoteMode.NON_NUMERIC);\n+        format.print(in, out, true);\n+        assertEquals(\"\\\"\\\"\\\"a,b,c\\r\\nx,y,z\\\"\", out.toString());\n+    }\n+\n+    @Test\n+    public void testQuoteCharSameAsCommentStartThrowsException() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setQuote('!').setCommentMarker('!').get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testQuoteCharSameAsCommentStartThrowsException_Deprecated() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote('!').withCommentMarker('!'));\n+    }\n+\n+    @Test\n+    public void testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType() {\n+        // Cannot assume that callers won't use different Character objects\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setQuote(Character.valueOf('!')).setCommentMarker('!').get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType_Deprecated() {\n+        // Cannot assume that callers won't use different Character objects\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote(Character.valueOf('!')).withCommentMarker('!'));\n+    }\n+\n+    @Test\n+    public void testQuoteCharSameAsDelimiterThrowsException() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setQuote('!').setDelimiter('!').get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testQuoteCharSameAsDelimiterThrowsException_Deprecated() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote('!').withDelimiter('!'));\n+    }\n+\n+    @Test\n+    public void testQuoteModeNoneShouldReturnMeaningfulExceptionMessage() {\n+        final Exception exception = assertThrows(IllegalArgumentException.class, () ->\n+        // @formatter:off\n+            CSVFormat.DEFAULT.builder()\n+                    .setHeader(\"Col1\", \"Col2\", \"Col3\", \"Col4\")\n+                    .setQuoteMode(QuoteMode.NONE)\n+                    .get()\n+        // @formatter:on\n+        );\n+        final String actualMessage = exception.getMessage();\n+        final String expectedMessage = \"Quote mode set to NONE but no escape character is set\";\n+        assertEquals(expectedMessage, actualMessage);\n+    }\n+\n+    @Test\n+    public void testQuotePolicyNoneWithoutEscapeThrowsException() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat('!').builder().setQuoteMode(QuoteMode.NONE).get());\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void testQuotePolicyNoneWithoutEscapeThrowsException_Deprecated() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat('!').withQuoteMode(QuoteMode.NONE));\n+    }\n+\n+    @Test\n+    public void testRFC4180() {\n+        assertNull(RFC4180.getCommentMarker());\n+        assertEquals(',', RFC4180.getDelimiter());\n+        assertNull(RFC4180.getEscapeCharacter());\n+        assertFalse(RFC4180.getIgnoreEmptyLines());\n+        assertEquals(Character.valueOf('\"'), RFC4180.getQuoteCharacter());\n+        assertNull(RFC4180.getQuoteMode());\n+        assertEquals(\"\\r\\n\", RFC4180.getRecordSeparator());\n+    }\n+\n+    @SuppressWarnings(\"boxing\") // no need to worry about boxing here\n+    @Test\n+    public void testSerialization() throws Exception {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+\n+        try (ObjectOutputStream oos = new ObjectOutputStream(out)) {\n+            oos.writeObject(CSVFormat.DEFAULT);\n+            oos.flush();\n+        }\n+\n+        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n+        final CSVFormat format = (CSVFormat) in.readObject();\n+\n+        assertNotNull(format);\n+        assertEquals(CSVFormat.DEFAULT.getDelimiter(), format.getDelimiter(), \"delimiter\");\n+        assertEquals(CSVFormat.DEFAULT.getQuoteCharacter(), format.getQuoteCharacter(), \"encapsulator\");\n+        assertEquals(CSVFormat.DEFAULT.getCommentMarker(), format.getCommentMarker(), \"comment start\");\n+        assertEquals(CSVFormat.DEFAULT.getRecordSeparator(), format.getRecordSeparator(), \"record separator\");\n+        assertEquals(CSVFormat.DEFAULT.getEscapeCharacter(), format.getEscapeCharacter(), \"escape\");\n+        assertEquals(CSVFormat.DEFAULT.getIgnoreSurroundingSpaces(), format.getIgnoreSurroundingSpaces(), \"trim\");\n+        assertEquals(CSVFormat.DEFAULT.getIgnoreEmptyLines(), format.getIgnoreEmptyLines(), \"empty lines\");\n+    }\n+\n+    @Test\n+    public void testToString() {\n+\n+        final String string = CSVFormat.INFORMIX_UNLOAD.toString();\n+\n+        assertEquals(\"Delimiter=<|> Escape=<\\\\> QuoteChar=<\\\"> RecordSeparator=<\\n> EmptyLines:ignored SkipHeaderRecord:false\", string);\n+\n+    }\n+\n+    @Test\n+    public void testToStringAndWithCommentMarkerTakingCharacter() {\n+\n+        final CSVFormat.Predefined csvFormatPredefined = CSVFormat.Predefined.Default;\n+        final CSVFormat csvFormat = csvFormatPredefined.getFormat();\n+\n+        assertNull(csvFormat.getEscapeCharacter());\n+        assertTrue(csvFormat.isQuoteCharacterSet());\n+\n+        assertFalse(csvFormat.getTrim());\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+        assertEquals(',', csvFormat.getDelimiter());\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\n+\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+        assertNull(csvFormat.getCommentMarker());\n+\n+        assertFalse(csvFormat.isNullStringSet());\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+\n+        assertFalse(csvFormat.isEscapeCharacterSet());\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+\n+        assertNull(csvFormat.getNullString());\n+        assertNull(csvFormat.getQuoteMode());\n+\n+        assertTrue(csvFormat.getIgnoreEmptyLines());\n+        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\n+\n+        final Character character = Character.valueOf('n');\n+\n+        final CSVFormat csvFormatTwo = csvFormat.withCommentMarker(character);\n+\n+        assertNull(csvFormat.getEscapeCharacter());\n+        assertTrue(csvFormat.isQuoteCharacterSet());\n+\n+        assertFalse(csvFormat.getTrim());\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+        assertEquals(',', csvFormat.getDelimiter());\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\n+\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+        assertNull(csvFormat.getCommentMarker());\n+\n+        assertFalse(csvFormat.isNullStringSet());\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+\n+        assertFalse(csvFormat.isEscapeCharacterSet());\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+\n+        assertNull(csvFormat.getNullString());\n+        assertNull(csvFormat.getQuoteMode());\n+\n+        assertTrue(csvFormat.getIgnoreEmptyLines());\n+        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\n+\n+        assertFalse(csvFormatTwo.isNullStringSet());\n+        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\n+\n+        assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\n+        assertNull(csvFormatTwo.getNullString());\n+\n+        assertEquals(',', csvFormatTwo.getDelimiter());\n+        assertFalse(csvFormatTwo.getTrailingDelimiter());\n+\n+        assertTrue(csvFormatTwo.isCommentMarkerSet());\n+        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\n+\n+        assertFalse(csvFormatTwo.getTrim());\n+        assertNull(csvFormatTwo.getEscapeCharacter());\n+\n+        assertTrue(csvFormatTwo.isQuoteCharacterSet());\n+        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\n+\n+        assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\n+        assertNull(csvFormatTwo.getQuoteMode());\n+\n+        assertEquals('n', (char) csvFormatTwo.getCommentMarker());\n+        assertFalse(csvFormatTwo.getSkipHeaderRecord());\n+\n+        assertFalse(csvFormatTwo.isEscapeCharacterSet());\n+        assertTrue(csvFormatTwo.getIgnoreEmptyLines());\n+\n+        assertNotSame(csvFormat, csvFormatTwo);\n+        assertNotSame(csvFormatTwo, csvFormat);\n+\n+        Assertions.assertNotEquals(csvFormatTwo, csvFormat);\n+\n+        assertNull(csvFormat.getEscapeCharacter());\n+        assertTrue(csvFormat.isQuoteCharacterSet());\n+\n+        assertFalse(csvFormat.getTrim());\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+        assertEquals(',', csvFormat.getDelimiter());\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\n+\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+        assertNull(csvFormat.getCommentMarker());\n+\n+        assertFalse(csvFormat.isNullStringSet());\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+\n+        assertFalse(csvFormat.isEscapeCharacterSet());\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+\n+        assertNull(csvFormat.getNullString());\n+        assertNull(csvFormat.getQuoteMode());\n+\n+        assertTrue(csvFormat.getIgnoreEmptyLines());\n+        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\n+\n+        assertFalse(csvFormatTwo.isNullStringSet());\n+        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\n+\n+        assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\n+        assertNull(csvFormatTwo.getNullString());\n+\n+        assertEquals(',', csvFormatTwo.getDelimiter());\n+        assertFalse(csvFormatTwo.getTrailingDelimiter());\n+\n+        assertTrue(csvFormatTwo.isCommentMarkerSet());\n+        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\n+\n+        assertFalse(csvFormatTwo.getTrim());\n+        assertNull(csvFormatTwo.getEscapeCharacter());\n+\n+        assertTrue(csvFormatTwo.isQuoteCharacterSet());\n+        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\n+\n+        assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\n+        assertNull(csvFormatTwo.getQuoteMode());\n+\n+        assertEquals('n', (char) csvFormatTwo.getCommentMarker());\n+        assertFalse(csvFormatTwo.getSkipHeaderRecord());\n+\n+        assertFalse(csvFormatTwo.isEscapeCharacterSet());\n+        assertTrue(csvFormatTwo.getIgnoreEmptyLines());\n+\n+        assertNotSame(csvFormat, csvFormatTwo);\n+        assertNotSame(csvFormatTwo, csvFormat);\n+\n+        Assertions.assertNotEquals(csvFormat, csvFormatTwo);\n+\n+        Assertions.assertNotEquals(csvFormatTwo, csvFormat);\n+        assertEquals(\"Delimiter=<,> QuoteChar=<\\\"> CommentStart=<n> \" + \"RecordSeparator=<\\r\\n> EmptyLines:ignored SkipHeaderRecord:false\",\n+                csvFormatTwo.toString());\n+\n+    }\n+\n+    @Test\n+    public void testTrim() throws IOException {\n+        final CSVFormat formatWithTrim = CSVFormat.DEFAULT.withDelimiter(',').withTrim().withQuote(null).withRecordSeparator(CRLF);\n+\n+        CharSequence in = \"a,b,c\";\n+        final StringBuilder out = new StringBuilder();\n+        formatWithTrim.print(in, out, true);\n+        assertEquals(\"a,b,c\", out.toString());\n+\n+        in = new StringBuilder(\" x,y,z\");\n+        out.setLength(0);\n+        formatWithTrim.print(in, out, true);\n+        assertEquals(\"x,y,z\", out.toString());\n+\n+        in = new StringBuilder(\"\");\n+        out.setLength(0);\n+        formatWithTrim.print(in, out, true);\n+        assertEquals(\"\", out.toString());\n+\n+        in = new StringBuilder(\"header\\r\\n\");\n+        out.setLength(0);\n+        formatWithTrim.print(in, out, true);\n+        assertEquals(\"header\", out.toString());\n+    }\n+\n+    @Test\n+    public void testWithCommentStart() {\n+        final CSVFormat formatWithCommentStart = CSVFormat.DEFAULT.withCommentMarker('#');\n+        assertEquals(Character.valueOf('#'), formatWithCommentStart.getCommentMarker());\n+    }\n+\n+    @Test\n+    public void testWithCommentStartCRThrowsException() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withCommentMarker(CR));\n+    }\n+\n+    @Test\n+    public void testWithDelimiter() {\n+        final CSVFormat formatWithDelimiter = CSVFormat.DEFAULT.withDelimiter('!');\n+        assertEquals('!', formatWithDelimiter.getDelimiter());\n+    }\n+\n+    @Test\n+    public void testWithDelimiterLFThrowsException() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter(LF));\n+    }\n+\n+    @Test\n+    public void testWithEmptyDuplicates() {\n+        final CSVFormat formatWithEmptyDuplicates = CSVFormat.DEFAULT.builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY).get();\n+\n+        assertEquals(DuplicateHeaderMode.ALLOW_EMPTY, formatWithEmptyDuplicates.getDuplicateHeaderMode());\n+        assertFalse(formatWithEmptyDuplicates.getAllowDuplicateHeaderNames());\n+    }\n+\n+    @Test\n+    public void testWithEmptyEnum() {\n+        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(EmptyEnum.class);\n+        assertEquals(0, formatWithHeader.getHeader().length);\n+    }\n+\n+    @Test\n+    public void testWithEscape() {\n+        final CSVFormat formatWithEscape = CSVFormat.DEFAULT.withEscape('&');\n+        assertEquals(Character.valueOf('&'), formatWithEscape.getEscapeCharacter());\n+    }\n+\n+    @Test\n+    public void testWithEscapeCRThrowsExceptions() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withEscape(CR));\n+    }\n+\n+    @Test\n+    public void testWithFirstRecordAsHeader() {\n+        final CSVFormat formatWithFirstRecordAsHeader = CSVFormat.DEFAULT.withFirstRecordAsHeader();\n+        assertTrue(formatWithFirstRecordAsHeader.getSkipHeaderRecord());\n+        assertEquals(0, formatWithFirstRecordAsHeader.getHeader().length);\n+    }\n+\n+    @Test\n+    public void testWithHeader() {\n+        final String[] header = { \"one\", \"two\", \"three\" };\n+        // withHeader() makes a copy of the header array.\n+        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(header);\n+        assertArrayEquals(header, formatWithHeader.getHeader());\n+        assertNotSame(header, formatWithHeader.getHeader());\n+    }\n+\n+    @Test\n+    public void testWithHeaderComments() {\n+\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT;\n+\n+        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+\n+        assertFalse(csvFormat.isEscapeCharacterSet());\n+        assertTrue(csvFormat.isQuoteCharacterSet());\n+\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+        assertNull(csvFormat.getQuoteMode());\n+\n+        assertEquals(',', csvFormat.getDelimiter());\n+        assertTrue(csvFormat.getIgnoreEmptyLines());\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertNull(csvFormat.getCommentMarker());\n+\n+        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+        assertFalse(csvFormat.getTrim());\n+\n+        assertFalse(csvFormat.isNullStringSet());\n+        assertNull(csvFormat.getNullString());\n+\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+        assertNull(csvFormat.getEscapeCharacter());\n+\n+        final Object[] objectArray = new Object[8];\n+        final CSVFormat csvFormatTwo = csvFormat.withHeaderComments(objectArray);\n+\n+        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+\n+        assertFalse(csvFormat.isEscapeCharacterSet());\n+        assertTrue(csvFormat.isQuoteCharacterSet());\n+\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+        assertNull(csvFormat.getQuoteMode());\n+\n+        assertEquals(',', csvFormat.getDelimiter());\n+        assertTrue(csvFormat.getIgnoreEmptyLines());\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertNull(csvFormat.getCommentMarker());\n+\n+        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+        assertFalse(csvFormat.getTrim());\n+\n+        assertFalse(csvFormat.isNullStringSet());\n+        assertNull(csvFormat.getNullString());\n+\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+        assertNull(csvFormat.getEscapeCharacter());\n+\n+        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\n+        assertNull(csvFormatTwo.getQuoteMode());\n+\n+        assertTrue(csvFormatTwo.getIgnoreEmptyLines());\n+        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\n+\n+        assertNull(csvFormatTwo.getEscapeCharacter());\n+        assertFalse(csvFormatTwo.getTrim());\n+\n+        assertFalse(csvFormatTwo.isEscapeCharacterSet());\n+        assertTrue(csvFormatTwo.isQuoteCharacterSet());\n+\n+        assertFalse(csvFormatTwo.getSkipHeaderRecord());\n+        assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\n+\n+        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\n+        assertNull(csvFormatTwo.getNullString());\n+\n+        assertFalse(csvFormatTwo.isNullStringSet());\n+        assertFalse(csvFormatTwo.getTrailingDelimiter());\n+\n+        assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\n+        assertEquals(',', csvFormatTwo.getDelimiter());\n+\n+        assertNull(csvFormatTwo.getCommentMarker());\n+        assertFalse(csvFormatTwo.isCommentMarkerSet());\n+\n+        assertNotSame(csvFormat, csvFormatTwo);\n+        assertNotSame(csvFormatTwo, csvFormat);\n+\n+        Assertions.assertNotEquals(csvFormatTwo, csvFormat); // CSV-244 - should not be equal\n+\n+        final String string = csvFormatTwo.format(objectArray);\n+\n+        assertEquals('\\\"', (char) csvFormat.getQuoteCharacter());\n+        assertFalse(csvFormat.isCommentMarkerSet());\n+\n+        assertFalse(csvFormat.isEscapeCharacterSet());\n+        assertTrue(csvFormat.isQuoteCharacterSet());\n+\n+        assertFalse(csvFormat.getSkipHeaderRecord());\n+        assertNull(csvFormat.getQuoteMode());\n+\n+        assertEquals(',', csvFormat.getDelimiter());\n+        assertTrue(csvFormat.getIgnoreEmptyLines());\n+\n+        assertFalse(csvFormat.getIgnoreHeaderCase());\n+        assertNull(csvFormat.getCommentMarker());\n+\n+        assertEquals(\"\\r\\n\", csvFormat.getRecordSeparator());\n+        assertFalse(csvFormat.getTrailingDelimiter());\n+\n+        assertFalse(csvFormat.getAllowMissingColumnNames());\n+        assertFalse(csvFormat.getTrim());\n+\n+        assertFalse(csvFormat.isNullStringSet());\n+        assertNull(csvFormat.getNullString());\n+\n+        assertFalse(csvFormat.getIgnoreSurroundingSpaces());\n+        assertNull(csvFormat.getEscapeCharacter());\n+\n+        assertFalse(csvFormatTwo.getIgnoreHeaderCase());\n+        assertNull(csvFormatTwo.getQuoteMode());\n+\n+        assertTrue(csvFormatTwo.getIgnoreEmptyLines());\n+        assertFalse(csvFormatTwo.getIgnoreSurroundingSpaces());\n+\n+        assertNull(csvFormatTwo.getEscapeCharacter());\n+        assertFalse(csvFormatTwo.getTrim());\n+\n+        assertFalse(csvFormatTwo.isEscapeCharacterSet());\n+        assertTrue(csvFormatTwo.isQuoteCharacterSet());\n+\n+        assertFalse(csvFormatTwo.getSkipHeaderRecord());\n+        assertEquals('\\\"', (char) csvFormatTwo.getQuoteCharacter());\n+\n+        assertFalse(csvFormatTwo.getAllowMissingColumnNames());\n+        assertNull(csvFormatTwo.getNullString());\n+\n+        assertFalse(csvFormatTwo.isNullStringSet());\n+        assertFalse(csvFormatTwo.getTrailingDelimiter());\n+\n+        assertEquals(\"\\r\\n\", csvFormatTwo.getRecordSeparator());\n+        assertEquals(',', csvFormatTwo.getDelimiter());\n+\n+        assertNull(csvFormatTwo.getCommentMarker());\n+        assertFalse(csvFormatTwo.isCommentMarkerSet());\n+\n+        assertNotSame(csvFormat, csvFormatTwo);\n+        assertNotSame(csvFormatTwo, csvFormat);\n+\n+        assertNotNull(string);\n+        Assertions.assertNotEquals(csvFormat, csvFormatTwo); // CSV-244 - should not be equal\n+\n+        Assertions.assertNotEquals(csvFormatTwo, csvFormat); // CSV-244 - should not be equal\n+        assertEquals(\",,,,,,,\", string);\n+\n+    }\n+\n+    @Test\n+    public void testWithHeaderEnum() {\n+        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(Header.class);\n+        assertArrayEquals(new String[] { \"Name\", \"Email\", \"Phone\" }, formatWithHeader.getHeader());\n+    }\n+\n+    @Test\n+    public void testWithHeaderEnumNull() {\n+        final CSVFormat format = CSVFormat.DEFAULT;\n+        final Class<Enum<?>> simpleName = null;\n+        format.withHeader(simpleName);\n+    }\n+\n+    @Test\n+    public void testWithHeaderResultSetNull() throws SQLException {\n+        final CSVFormat format = CSVFormat.DEFAULT;\n+        final ResultSet resultSet = null;\n+        format.withHeader(resultSet);\n+    }\n+\n+    @Test\n+    public void testWithIgnoreEmptyLines() {\n+        assertFalse(CSVFormat.DEFAULT.withIgnoreEmptyLines(false).getIgnoreEmptyLines());\n+        assertTrue(CSVFormat.DEFAULT.withIgnoreEmptyLines().getIgnoreEmptyLines());\n+    }\n+\n+    @Test\n+    public void testWithIgnoreSurround() {\n+        assertFalse(CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(false).getIgnoreSurroundingSpaces());\n+        assertTrue(CSVFormat.DEFAULT.withIgnoreSurroundingSpaces().getIgnoreSurroundingSpaces());\n+    }\n+\n+    @Test\n+    public void testWithNullString() {\n+        final CSVFormat formatWithNullString = CSVFormat.DEFAULT.withNullString(\"null\");\n+        assertEquals(\"null\", formatWithNullString.getNullString());\n+    }\n+\n+    @Test\n+    public void testWithQuoteChar() {\n+        final CSVFormat formatWithQuoteChar = CSVFormat.DEFAULT.withQuote('\"');\n+        assertEquals(Character.valueOf('\"'), formatWithQuoteChar.getQuoteCharacter());\n+    }\n+\n+    @Test\n+    public void testWithQuoteLFThrowsException() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote(LF));\n+    }\n+\n+    @Test\n+    public void testWithQuotePolicy() {\n+        final CSVFormat formatWithQuotePolicy = CSVFormat.DEFAULT.withQuoteMode(QuoteMode.ALL);\n+        assertEquals(QuoteMode.ALL, formatWithQuotePolicy.getQuoteMode());\n+    }\n+\n+    @Test\n+    public void testWithRecordSeparatorCR() {\n+        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator(CR);\n+        assertEquals(String.valueOf(CR), formatWithRecordSeparator.getRecordSeparator());\n+    }\n+\n+    @Test\n+    public void testWithRecordSeparatorCRLF() {\n+        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator(CRLF);\n+        assertEquals(CRLF, formatWithRecordSeparator.getRecordSeparator());\n+    }\n+\n+    @Test\n+    public void testWithRecordSeparatorLF() {\n+        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator(LF);\n+        assertEquals(String.valueOf(LF), formatWithRecordSeparator.getRecordSeparator());\n+    }\n+\n+    @Test\n+    public void testWithSystemRecordSeparator() {\n+        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withSystemRecordSeparator();\n+        assertEquals(System.lineSeparator(), formatWithRecordSeparator.getRecordSeparator());\n+    }\n+}\n\ndiff --git a/src/test/java/org/apache/commons/csv/CSVParserTest.java b/src/test/java/org/apache/commons/csv/CSVParserTest.java\nindex da49a78c..38d442e5 100644\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n@@ -1,1812 +1,1812 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv;\r\n-\r\n-import static org.apache.commons.csv.Constants.CR;\r\n-import static org.apache.commons.csv.Constants.CRLF;\r\n-import static org.apache.commons.csv.Constants.LF;\r\n-import static org.junit.jupiter.api.Assertions.assertArrayEquals;\r\n-import static org.junit.jupiter.api.Assertions.assertEquals;\r\n-import static org.junit.jupiter.api.Assertions.assertFalse;\r\n-import static org.junit.jupiter.api.Assertions.assertInstanceOf;\r\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\r\n-import static org.junit.jupiter.api.Assertions.assertNull;\r\n-import static org.junit.jupiter.api.Assertions.assertThrows;\r\n-import static org.junit.jupiter.api.Assertions.assertTrue;\r\n-\r\n-import java.io.File;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.PipedReader;\r\n-import java.io.PipedWriter;\r\n-import java.io.Reader;\r\n-import java.io.StringReader;\r\n-import java.io.StringWriter;\r\n-import java.io.UncheckedIOException;\r\n-import java.net.URL;\r\n-import java.nio.charset.Charset;\r\n-import java.nio.charset.StandardCharsets;\r\n-import java.nio.file.Files;\r\n-import java.nio.file.Path;\r\n-import java.nio.file.Paths;\r\n-import java.util.ArrayList;\r\n-import java.util.Arrays;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.NoSuchElementException;\r\n-import java.util.stream.Collectors;\r\n-import java.util.stream.Stream;\r\n-\r\n-import org.apache.commons.io.input.BOMInputStream;\r\n-import org.apache.commons.io.input.BrokenInputStream;\r\n-import org.junit.jupiter.api.Assertions;\r\n-import org.junit.jupiter.api.Disabled;\r\n-import org.junit.jupiter.api.Test;\r\n-import org.junit.jupiter.params.ParameterizedTest;\r\n-import org.junit.jupiter.params.provider.EnumSource;\r\n-\r\n-/**\r\n- * CSVParserTest\r\n- *\r\n- * The test are organized in three different sections: The 'setter/getter' section, the lexer section and finally the parser section. In case a test fails, you\r\n- * should follow a top-down approach for fixing a potential bug (its likely that the parser itself fails if the lexer has problems...).\r\n- */\r\n-public class CSVParserTest {\r\n-\r\n-    private static final CSVFormat EXCEL_WITH_HEADER = CSVFormat.EXCEL.withHeader();\r\n-\r\n-    private static final Charset UTF_8 = StandardCharsets.UTF_8;\r\n-\r\n-    private static final String UTF_8_NAME = UTF_8.name();\r\n-\r\n-    private static final String CSV_INPUT = \"a,b,c,d\\n\" + \" a , b , 1 2 \\n\" + \"\\\"foo baar\\\", b,\\n\" +\r\n-            // + \" \\\"foo\\n,,\\n\\\"\\\",,\\n\\\\\\\"\\\",d,e\\n\";\r\n-            \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\"\\\"\\\",d,e\\n\"; // changed to use standard CSV escaping\r\n-\r\n-    private static final String CSV_INPUT_1 = \"a,b,c,d\";\r\n-\r\n-    private static final String CSV_INPUT_2 = \"a,b,1 2\";\r\n-\r\n-    private static final String[][] RESULT = { { \"a\", \"b\", \"c\", \"d\" }, { \"a\", \"b\", \"1 2\" }, { \"foo baar\", \"b\", \"\" }, { \"foo\\n,,\\n\\\",,\\n\\\"\", \"d\", \"e\" } };\r\n-\r\n-    // CSV with no header comments\r\n-    private static final String CSV_INPUT_NO_COMMENT = \"A,B\" + CRLF + \"1,2\" + CRLF;\r\n-\r\n-    // CSV with a header comment\r\n-    private static final String CSV_INPUT_HEADER_COMMENT = \"# header comment\" + CRLF + \"A,B\" + CRLF + \"1,2\" + CRLF;\r\n-\r\n-    // CSV with a single line header and trailer comment\r\n-    private static final String CSV_INPUT_HEADER_TRAILER_COMMENT = \"# header comment\" + CRLF + \"A,B\" + CRLF + \"1,2\" + CRLF + \"# comment\";\r\n-\r\n-    // CSV with a multi-line header and trailer comment\r\n-    private static final String CSV_INPUT_MULTILINE_HEADER_TRAILER_COMMENT = \"# multi-line\" + CRLF + \"# header comment\" + CRLF + \"A,B\" + CRLF + \"1,2\" + CRLF +\r\n-            \"# multi-line\" + CRLF + \"# comment\";\r\n-\r\n-    // Format with auto-detected header\r\n-    private static final CSVFormat FORMAT_AUTO_HEADER = CSVFormat.Builder.create(CSVFormat.DEFAULT).setCommentMarker('#').setHeader().get();\r\n-\r\n-    // Format with explicit header\r\n-    // @formatter:off\r\n-    private static final CSVFormat FORMAT_EXPLICIT_HEADER = CSVFormat.Builder.create(CSVFormat.DEFAULT)\r\n-            .setSkipHeaderRecord(true)\r\n-            .setCommentMarker('#')\r\n-            .setHeader(\"A\", \"B\")\r\n-            .get();\r\n-    // @formatter:on\r\n-\r\n-    // Format with explicit header that does not skip the header line\r\n-    // @formatter:off\r\n-    CSVFormat FORMAT_EXPLICIT_HEADER_NOSKIP = CSVFormat.Builder.create(CSVFormat.DEFAULT)\r\n-            .setCommentMarker('#')\r\n-            .setHeader(\"A\", \"B\")\r\n-            .get();\r\n-    // @formatter:on\r\n-\r\n-    @SuppressWarnings(\"resource\") // caller releases\r\n-    private BOMInputStream createBOMInputStream(final String resource) throws IOException {\r\n-        return new BOMInputStream(ClassLoader.getSystemClassLoader().getResource(resource).openStream());\r\n-    }\r\n-\r\n-    CSVRecord parse(final CSVParser parser, final int failParseRecordNo) throws IOException {\r\n-        if (parser.getRecordNumber() + 1 == failParseRecordNo) {\r\n-            assertThrows(IOException.class, () -> parser.nextRecord());\r\n-            return null;\r\n-        }\r\n-        return parser.nextRecord();\r\n-    }\r\n-\r\n-    private void parseFully(final CSVParser parser) {\r\n-        parser.forEach(Assertions::assertNotNull);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testBackslashEscaping() throws IOException {\r\n-        // To avoid confusion over the need for escaping chars in java code,\r\n-        // We will test with a forward slash as the escape char, and a single\r\n-        // quote as the encapsulator.\r\n-\r\n-        // @formatter:off\r\n-        final String code = \"one,two,three\\n\" + // 0\r\n-            \"'',''\\n\" + // 1) empty encapsulators\r\n-            \"/',/'\\n\" + // 2) single encapsulators\r\n-            \"'/'','/''\\n\" + // 3) single encapsulators encapsulated via escape\r\n-            \"'''',''''\\n\" + // 4) single encapsulators encapsulated via doubling\r\n-            \"/,,/,\\n\" + // 5) separator escaped\r\n-            \"//,//\\n\" + // 6) escape escaped\r\n-            \"'//','//'\\n\" + // 7) escape escaped in encapsulation\r\n-            \"   8   ,   \\\"quoted \\\"\\\" /\\\" // string\\\"   \\n\" + // don't eat spaces\r\n-            \"9,   /\\n   \\n\" + // escaped newline\r\n-            \"\";\r\n-        final String[][] res = {{\"one\", \"two\", \"three\"}, // 0\r\n-            {\"\", \"\"}, // 1\r\n-            {\"'\", \"'\"}, // 2\r\n-            {\"'\", \"'\"}, // 3\r\n-            {\"'\", \"'\"}, // 4\r\n-            {\",\", \",\"}, // 5\r\n-            {\"/\", \"/\"}, // 6\r\n-            {\"/\", \"/\"}, // 7\r\n-            {\"   8   \", \"   \\\"quoted \\\"\\\" /\\\" / string\\\"   \"}, {\"9\", \"   \\n   \"} };\r\n-        // @formatter:on\r\n-        final CSVFormat format = CSVFormat.newFormat(',').withQuote('\\'').withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines();\r\n-        try (CSVParser parser = CSVParser.parse(code, format)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertFalse(records.isEmpty());\r\n-            Utils.compare(\"Records do not match expected result\", res, records);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testBackslashEscaping2() throws IOException {\r\n-        // To avoid confusion over the need for escaping chars in java code,\r\n-        // We will test with a forward slash as the escape char, and a single\r\n-        // quote as the encapsulator.\r\n-        // @formatter:off\r\n-        final String code = \"\" + \" , , \\n\" + // 1)\r\n-            \" \\t ,  , \\n\" + // 2)\r\n-            \" // , /, , /,\\n\" + // 3)\r\n-            \"\";\r\n-        final String[][] res = {{\" \", \" \", \" \"}, // 1\r\n-            {\" \\t \", \"  \", \" \"}, // 2\r\n-            {\" / \", \" , \", \" ,\"}, // 3\r\n-        };\r\n-        // @formatter:on\r\n-        final CSVFormat format = CSVFormat.newFormat(',').withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines();\r\n-        try (CSVParser parser = CSVParser.parse(code, format)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertFalse(records.isEmpty());\r\n-            Utils.compare(\"\", res, records);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testBackslashEscapingOld() throws IOException {\r\n-        final String code = \"one,two,three\\n\" + \"on\\\\\\\"e,two\\n\" + \"on\\\"e,two\\n\" + \"one,\\\"tw\\\\\\\"o\\\"\\n\" + \"one,\\\"t\\\\,wo\\\"\\n\" + \"one,two,\\\"th,ree\\\"\\n\" +\r\n-                \"\\\"a\\\\\\\\\\\"\\n\" + \"a\\\\,b\\n\" + \"\\\"a\\\\\\\\,b\\\"\";\r\n-        final String[][] res = { { \"one\", \"two\", \"three\" }, { \"on\\\\\\\"e\", \"two\" }, { \"on\\\"e\", \"two\" }, { \"one\", \"tw\\\"o\" }, { \"one\", \"t\\\\,wo\" }, // backslash in\r\n-                                                                                                                                               // quotes only\r\n-                                                                                                                                               // escapes a\r\n-                                                                                                                                               // delimiter\r\n-                                                                                                                                               // (\",\")\r\n-                { \"one\", \"two\", \"th,ree\" }, { \"a\\\\\\\\\" }, // backslash in quotes only escapes a delimiter (\",\")\r\n-                { \"a\\\\\", \"b\" }, // a backslash must be returned\r\n-                { \"a\\\\\\\\,b\" } // backslash in quotes only escapes a delimiter (\",\")\r\n-        };\r\n-        try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(res.length, records.size());\r\n-            assertFalse(records.isEmpty());\r\n-            for (int i = 0; i < res.length; i++) {\r\n-                assertArrayEquals(res[i], records.get(i).values());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled(\"CSV-107\")\r\n-    public void testBOM() throws IOException {\r\n-        final URL url = ClassLoader.getSystemClassLoader().getResource(\"org/apache/commons/csv/CSVFileParser/bom.csv\");\r\n-        try (CSVParser parser = CSVParser.parse(url, StandardCharsets.UTF_8, EXCEL_WITH_HEADER)) {\r\n-            parser.forEach(record -> assertNotNull(record.get(\"Date\")));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testBOMInputStreamParserWithInputStream() throws IOException {\r\n-        try (BOMInputStream inputStream = createBOMInputStream(\"org/apache/commons/csv/CSVFileParser/bom.csv\");\r\n-                CSVParser parser = CSVParser.parse(inputStream, UTF_8, EXCEL_WITH_HEADER)) {\r\n-            parser.forEach(record -> assertNotNull(record.get(\"Date\")));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testBOMInputStreamParserWithReader() throws IOException {\r\n-        try (Reader reader = new InputStreamReader(createBOMInputStream(\"org/apache/commons/csv/CSVFileParser/bom.csv\"), UTF_8_NAME);\r\n-                CSVParser parser = CSVParser.builder()\r\n-                        .setReader(reader)\r\n-                        .setFormat(EXCEL_WITH_HEADER)\r\n-                        .get()) {\r\n-            parser.forEach(record -> assertNotNull(record.get(\"Date\")));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testBOMInputStreamParseWithReader() throws IOException {\r\n-        try (Reader reader = new InputStreamReader(createBOMInputStream(\"org/apache/commons/csv/CSVFileParser/bom.csv\"), UTF_8_NAME);\r\n-                CSVParser parser = CSVParser.builder()\r\n-                        .setReader(reader)\r\n-                        .setFormat(EXCEL_WITH_HEADER)\r\n-                        .get()) {\r\n-            parser.forEach(record -> assertNotNull(record.get(\"Date\")));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCarriageReturnEndings() throws IOException {\r\n-        final String string = \"foo\\rbaar,\\rhello,world\\r,kanu\";\r\n-        try (CSVParser parser = CSVParser.builder().setCharSequence(string).get()) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(4, records.size());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCarriageReturnLineFeedEndings() throws IOException {\r\n-        final String string = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\r\n-        try (CSVParser parser = CSVParser.builder().setCharSequence(string).get()) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(4, records.size());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testClose() throws Exception {\r\n-        final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\r\n-        final Iterator<CSVRecord> records;\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withCommentMarker('#').withHeader().parse(in)) {\r\n-            records = parser.iterator();\r\n-            assertTrue(records.hasNext());\r\n-        }\r\n-        assertFalse(records.hasNext());\r\n-        assertThrows(NoSuchElementException.class, records::next);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV141CSVFormat_DEFAULT() throws Exception {\r\n-        testCSV141Failure(CSVFormat.DEFAULT, 3);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV141CSVFormat_INFORMIX_UNLOAD() throws Exception {\r\n-        testCSV141Failure(CSVFormat.INFORMIX_UNLOAD, 1);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV141CSVFormat_INFORMIX_UNLOAD_CSV() throws Exception {\r\n-        testCSV141Failure(CSVFormat.INFORMIX_UNLOAD_CSV, 3);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV141CSVFormat_ORACLE() throws Exception {\r\n-        testCSV141Failure(CSVFormat.ORACLE, 2);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV141CSVFormat_POSTGRESQL_CSV() throws Exception {\r\n-        testCSV141Failure(CSVFormat.POSTGRESQL_CSV, 3);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV141Excel() throws Exception {\r\n-        testCSV141Ok(CSVFormat.EXCEL);\r\n-    }\r\n-\r\n-    private void testCSV141Failure(final CSVFormat format, final int failParseRecordNo) throws IOException {\r\n-        final Path path = Paths.get(\"src/test/resources/org/apache/commons/csv/CSV-141/csv-141.csv\");\r\n-        try (CSVParser parser = CSVParser.parse(path, StandardCharsets.UTF_8, format)) {\r\n-            // row 1\r\n-            CSVRecord record = parse(parser, failParseRecordNo);\r\n-            if (record == null) {\r\n-                return; // expected failure\r\n-            }\r\n-            assertEquals(\"1414770317901\", record.get(0));\r\n-            assertEquals(\"android.widget.EditText\", record.get(1));\r\n-            assertEquals(\"pass sem1 _84*|*\", record.get(2));\r\n-            assertEquals(\"0\", record.get(3));\r\n-            assertEquals(\"pass sem1 _8\", record.get(4));\r\n-            assertEquals(5, record.size());\r\n-            // row 2\r\n-            record = parse(parser, failParseRecordNo);\r\n-            if (record == null) {\r\n-                return; // expected failure\r\n-            }\r\n-            assertEquals(\"1414770318470\", record.get(0));\r\n-            assertEquals(\"android.widget.EditText\", record.get(1));\r\n-            assertEquals(\"pass sem1 _84:|\", record.get(2));\r\n-            assertEquals(\"0\", record.get(3));\r\n-            assertEquals(\"pass sem1 _84:\\\\\", record.get(4));\r\n-            assertEquals(5, record.size());\r\n-            // row 3: Fail for certain\r\n-            assertThrows(IOException.class, () -> parser.nextRecord());\r\n-        }\r\n-    }\r\n-\r\n-    private void testCSV141Ok(final CSVFormat format) throws IOException {\r\n-        final Path path = Paths.get(\"src/test/resources/org/apache/commons/csv/CSV-141/csv-141.csv\");\r\n-        try (CSVParser parser = CSVParser.parse(path, StandardCharsets.UTF_8, format)) {\r\n-            // row 1\r\n-            CSVRecord record = parser.nextRecord();\r\n-            assertEquals(\"1414770317901\", record.get(0));\r\n-            assertEquals(\"android.widget.EditText\", record.get(1));\r\n-            assertEquals(\"pass sem1 _84*|*\", record.get(2));\r\n-            assertEquals(\"0\", record.get(3));\r\n-            assertEquals(\"pass sem1 _8\", record.get(4));\r\n-            assertEquals(5, record.size());\r\n-            // row 2\r\n-            record = parser.nextRecord();\r\n-            assertEquals(\"1414770318470\", record.get(0));\r\n-            assertEquals(\"android.widget.EditText\", record.get(1));\r\n-            assertEquals(\"pass sem1 _84:|\", record.get(2));\r\n-            assertEquals(\"0\", record.get(3));\r\n-            assertEquals(\"pass sem1 _84:\\\\\", record.get(4));\r\n-            assertEquals(5, record.size());\r\n-            // row 3\r\n-            record = parser.nextRecord();\r\n-            assertEquals(\"1414770318327\", record.get(0));\r\n-            assertEquals(\"android.widget.EditText\", record.get(1));\r\n-            assertEquals(\"pass sem1\\n1414770318628\\\"\", record.get(2));\r\n-            assertEquals(\"android.widget.EditText\", record.get(3));\r\n-            assertEquals(\"pass sem1 _84*|*\", record.get(4));\r\n-            assertEquals(\"0\", record.get(5));\r\n-            assertEquals(\"pass sem1\\n\", record.get(6));\r\n-            assertEquals(7, record.size());\r\n-            // EOF\r\n-            record = parser.nextRecord();\r\n-            assertNull(record);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV141RFC4180() throws Exception {\r\n-        testCSV141Failure(CSVFormat.RFC4180, 3);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV235() throws IOException {\r\n-        final String dqString = \"\\\"aaa\\\",\\\"b\\\"\\\"bb\\\",\\\"ccc\\\"\"; // \"aaa\",\"b\"\"bb\",\"ccc\"\r\n-        try (CSVParser parser = CSVFormat.RFC4180.parse(new StringReader(dqString))) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            assertFalse(records.hasNext());\r\n-            assertEquals(3, record.size());\r\n-            assertEquals(\"aaa\", record.get(0));\r\n-            assertEquals(\"b\\\"bb\", record.get(1));\r\n-            assertEquals(\"ccc\", record.get(2));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV57() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT)) {\r\n-            final List<CSVRecord> list = parser.getRecords();\r\n-            assertNotNull(list);\r\n-            assertEquals(0, list.size());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDefaultFormat() throws IOException {\r\n-        // @formatter:off\r\n-        final String code = \"\" + \"a,b#\\n\" + // 1)\r\n-            \"\\\"\\n\\\",\\\" \\\",#\\n\" +            // 2)\r\n-            \"#,\\\"\\\"\\n\" +                    // 3)\r\n-            \"# Final comment\\n\"             // 4)\r\n-        ;\r\n-        // @formatter:on\r\n-        final String[][] res = { { \"a\", \"b#\" }, { \"\\n\", \" \", \"#\" }, { \"#\", \"\" }, { \"# Final comment\" } };\r\n-        CSVFormat format = CSVFormat.DEFAULT;\r\n-        assertFalse(format.isCommentMarkerSet());\r\n-        final String[][] resComments = { { \"a\", \"b#\" }, { \"\\n\", \" \", \"#\" } };\r\n-        try (CSVParser parser = CSVParser.parse(code, format)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertFalse(records.isEmpty());\r\n-            Utils.compare(\"Failed to parse without comments\", res, records);\r\n-            format = CSVFormat.DEFAULT.withCommentMarker('#');\r\n-        }\r\n-        try (CSVParser parser = CSVParser.parse(code, format)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            Utils.compare(\"Failed to parse with comments\", resComments, records);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDuplicateHeadersAllowedByDefault() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"a,b,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader())) {\r\n-            // noop\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDuplicateHeadersNotAllowed() {\r\n-        assertThrows(IllegalArgumentException.class,\r\n-                () -> CSVParser.parse(\"a,b,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader().withAllowDuplicateHeaderNames(false)));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEmptyFile() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(Paths.get(\"src/test/resources/org/apache/commons/csv/empty.txt\"), StandardCharsets.UTF_8,\r\n-                CSVFormat.DEFAULT)) {\r\n-            assertNull(parser.nextRecord());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEmptyFileHeaderParsing() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT.withFirstRecordAsHeader())) {\r\n-            assertNull(parser.nextRecord());\r\n-            assertTrue(parser.getHeaderNames().isEmpty());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEmptyLineBehaviorCSV() throws Exception {\r\n-        final String[] codes = { \"hello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\r\n-        final String[][] res = { { \"hello\", \"\" } // CSV format ignores empty lines\r\n-        };\r\n-        for (final String code : codes) {\r\n-            try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\r\n-                final List<CSVRecord> records = parser.getRecords();\r\n-                assertEquals(res.length, records.size());\r\n-                assertFalse(records.isEmpty());\r\n-                for (int i = 0; i < res.length; i++) {\r\n-                    assertArrayEquals(res[i], records.get(i).values());\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEmptyLineBehaviorExcel() throws Exception {\r\n-        final String[] codes = { \"hello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\r\n-        final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\r\n-                { \"\" } };\r\n-        for (final String code : codes) {\r\n-            try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\r\n-                final List<CSVRecord> records = parser.getRecords();\r\n-                assertEquals(res.length, records.size());\r\n-                assertFalse(records.isEmpty());\r\n-                for (int i = 0; i < res.length; i++) {\r\n-                    assertArrayEquals(res[i], records.get(i).values());\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEmptyString() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT)) {\r\n-            assertNull(parser.nextRecord());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEndOfFileBehaviorCSV() throws Exception {\r\n-        final String[] codes = { \"hello,\\r\\n\\r\\nworld,\\r\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\r\n-                \"hello,\\r\\n\\r\\nworld,\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\" };\r\n-        final String[][] res = { { \"hello\", \"\" }, // CSV format ignores empty lines\r\n-                { \"world\", \"\" } };\r\n-        for (final String code : codes) {\r\n-            try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\r\n-                final List<CSVRecord> records = parser.getRecords();\r\n-                assertEquals(res.length, records.size());\r\n-                assertFalse(records.isEmpty());\r\n-                for (int i = 0; i < res.length; i++) {\r\n-                    assertArrayEquals(res[i], records.get(i).values());\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEndOfFileBehaviorExcel() throws Exception {\r\n-        final String[] codes = { \"hello,\\r\\n\\r\\nworld,\\r\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\r\n-                \"hello,\\r\\n\\r\\nworld,\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\" };\r\n-        final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\r\n-                { \"world\", \"\" } };\r\n-\r\n-        for (final String code : codes) {\r\n-            try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\r\n-                final List<CSVRecord> records = parser.getRecords();\r\n-                assertEquals(res.length, records.size());\r\n-                assertFalse(records.isEmpty());\r\n-                for (int i = 0; i < res.length; i++) {\r\n-                    assertArrayEquals(res[i], records.get(i).values());\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelFormat1() throws IOException {\r\n-        final String code = \"value1,value2,value3,value4\\r\\na,b,c,d\\r\\n  x,,,\" + \"\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\",\\\"  \\\"\\\"world\\\"\\\"\\\",\\\"abc\\ndef\\\",\\r\\n\";\r\n-        final String[][] res = { { \"value1\", \"value2\", \"value3\", \"value4\" }, { \"a\", \"b\", \"c\", \"d\" }, { \"  x\", \"\", \"\", \"\" }, { \"\" },\r\n-                { \"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\" } };\r\n-        try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(res.length, records.size());\r\n-            assertFalse(records.isEmpty());\r\n-            for (int i = 0; i < res.length; i++) {\r\n-                assertArrayEquals(res[i], records.get(i).values());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelFormat2() throws Exception {\r\n-        final String code = \"foo,baar\\r\\n\\r\\nhello,\\r\\n\\r\\nworld,\\r\\n\";\r\n-        final String[][] res = { { \"foo\", \"baar\" }, { \"\" }, { \"hello\", \"\" }, { \"\" }, { \"world\", \"\" } };\r\n-        try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(res.length, records.size());\r\n-            assertFalse(records.isEmpty());\r\n-            for (int i = 0; i < res.length; i++) {\r\n-                assertArrayEquals(res[i], records.get(i).values());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Tests an exported Excel worksheet with a header row and rows that have more columns than the headers\r\n-     */\r\n-    @Test\r\n-    public void testExcelHeaderCountLessThanData() throws Exception {\r\n-        final String code = \"A,B,C,,\\r\\na,b,c,d,e\\r\\n\";\r\n-        try (CSVParser parser = CSVParser.parse(code, EXCEL_WITH_HEADER)) {\r\n-            parser.getRecords().forEach(record -> {\r\n-                assertEquals(\"a\", record.get(\"A\"));\r\n-                assertEquals(\"b\", record.get(\"B\"));\r\n-                assertEquals(\"c\", record.get(\"C\"));\r\n-            });\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testFirstEndOfLineCr() throws IOException {\r\n-        final String data = \"foo\\rbaar,\\rhello,world\\r,kanu\";\r\n-        try (CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(4, records.size());\r\n-            assertEquals(\"\\r\", parser.getFirstEndOfLine());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testFirstEndOfLineCrLf() throws IOException {\r\n-        final String data = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\r\n-        try (CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(4, records.size());\r\n-            assertEquals(\"\\r\\n\", parser.getFirstEndOfLine());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testFirstEndOfLineLf() throws IOException {\r\n-        final String data = \"foo\\nbaar,\\nhello,world\\n,kanu\";\r\n-        try (CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(4, records.size());\r\n-            assertEquals(\"\\n\", parser.getFirstEndOfLine());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testForEach() throws Exception {\r\n-        try (Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-                CSVParser parser = CSVFormat.DEFAULT.parse(in)) {\r\n-            final List<CSVRecord> records = new ArrayList<>();\r\n-            for (final CSVRecord record : parser) {\r\n-                records.add(record);\r\n-            }\r\n-            assertEquals(3, records.size());\r\n-            assertArrayEquals(new String[] { \"a\", \"b\", \"c\" }, records.get(0).values());\r\n-            assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, records.get(1).values());\r\n-            assertArrayEquals(new String[] { \"x\", \"y\", \"z\" }, records.get(2).values());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderComment_HeaderComment1() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_AUTO_HEADER)) {\r\n-            parser.getRecords();\r\n-            // Expect a header comment\r\n-            assertTrue(parser.hasHeaderComment());\r\n-            assertEquals(\"header comment\", parser.getHeaderComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderComment_HeaderComment2() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER)) {\r\n-            parser.getRecords();\r\n-            // Expect a header comment\r\n-            assertTrue(parser.hasHeaderComment());\r\n-            assertEquals(\"header comment\", parser.getHeaderComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderComment_HeaderComment3() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\r\n-            parser.getRecords();\r\n-            // Expect no header comment - the text \"comment\" is attached to the first record\r\n-            assertFalse(parser.hasHeaderComment());\r\n-            assertNull(parser.getHeaderComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderComment_HeaderTrailerComment() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_MULTILINE_HEADER_TRAILER_COMMENT, FORMAT_AUTO_HEADER)) {\r\n-            parser.getRecords();\r\n-            // Expect a header comment\r\n-            assertTrue(parser.hasHeaderComment());\r\n-            assertEquals(\"multi-line\" + LF + \"header comment\", parser.getHeaderComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderComment_NoComment1() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_NO_COMMENT, FORMAT_AUTO_HEADER)) {\r\n-            parser.getRecords();\r\n-            // Expect no header comment\r\n-            assertFalse(parser.hasHeaderComment());\r\n-            assertNull(parser.getHeaderComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderComment_NoComment2() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_NO_COMMENT, FORMAT_EXPLICIT_HEADER)) {\r\n-            parser.getRecords();\r\n-            // Expect no header comment\r\n-            assertFalse(parser.hasHeaderComment());\r\n-            assertNull(parser.getHeaderComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderComment_NoComment3() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_NO_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\r\n-            parser.getRecords();\r\n-            // Expect no header comment\r\n-            assertFalse(parser.hasHeaderComment());\r\n-            assertNull(parser.getHeaderComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderMap() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\r\n-            final Map<String, Integer> headerMap = parser.getHeaderMap();\r\n-            final Iterator<String> columnNames = headerMap.keySet().iterator();\r\n-            // Headers are iterated in column order.\r\n-            assertEquals(\"A\", columnNames.next());\r\n-            assertEquals(\"B\", columnNames.next());\r\n-            assertEquals(\"C\", columnNames.next());\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-\r\n-            // Parse to make sure getHeaderMap did not have a side-effect.\r\n-            for (int i = 0; i < 3; i++) {\r\n-                assertTrue(records.hasNext());\r\n-                final CSVRecord record = records.next();\r\n-                assertEquals(record.get(0), record.get(\"A\"));\r\n-                assertEquals(record.get(1), record.get(\"B\"));\r\n-                assertEquals(record.get(2), record.get(\"C\"));\r\n-            }\r\n-\r\n-            assertFalse(records.hasNext());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderNames() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\r\n-            final Map<String, Integer> nameIndexMap = parser.getHeaderMap();\r\n-            final List<String> headerNames = parser.getHeaderNames();\r\n-            assertNotNull(headerNames);\r\n-            assertEquals(nameIndexMap.size(), headerNames.size());\r\n-            for (int i = 0; i < headerNames.size(); i++) {\r\n-                final String name = headerNames.get(i);\r\n-                assertEquals(i, nameIndexMap.get(name).intValue());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetHeaderNamesReadOnly() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\r\n-            final List<String> headerNames = parser.getHeaderNames();\r\n-            assertNotNull(headerNames);\r\n-            assertThrows(UnsupportedOperationException.class, () -> headerNames.add(\"This is a read-only list.\"));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetLine() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\r\n-            for (final String[] re : RESULT) {\r\n-                assertArrayEquals(re, parser.nextRecord().values());\r\n-            }\r\n-\r\n-            assertNull(parser.nextRecord());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetLineNumberWithCR() throws Exception {\r\n-        validateLineNumbers(String.valueOf(CR));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetLineNumberWithCRLF() throws Exception {\r\n-        validateLineNumbers(CRLF);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetLineNumberWithLF() throws Exception {\r\n-        validateLineNumbers(String.valueOf(LF));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetOneLine() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_1, CSVFormat.DEFAULT)) {\r\n-            final CSVRecord record = parser.getRecords().get(0);\r\n-            assertArrayEquals(RESULT[0], record.values());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Tests reusing a parser to process new string records one at a time as they are being discovered. See [CSV-110].\r\n-     *\r\n-     * @throws IOException when an I/O error occurs.\r\n-     */\r\n-    @Test\r\n-    public void testGetOneLineOneParser() throws IOException {\r\n-        final CSVFormat format = CSVFormat.DEFAULT;\r\n-        try (PipedWriter writer = new PipedWriter();\r\n-                CSVParser parser = CSVParser.builder()\r\n-                        .setReader(new PipedReader(writer))\r\n-                        .setFormat(format)\r\n-                        .get()) {\r\n-            writer.append(CSV_INPUT_1);\r\n-            writer.append(format.getRecordSeparator());\r\n-            final CSVRecord record1 = parser.nextRecord();\r\n-            assertArrayEquals(RESULT[0], record1.values());\r\n-            writer.append(CSV_INPUT_2);\r\n-            writer.append(format.getRecordSeparator());\r\n-            final CSVRecord record2 = parser.nextRecord();\r\n-            assertArrayEquals(RESULT[1], record2.values());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordFourBytesRead() throws Exception {\r\n-        final String code = \"id,a,b,c\\n\" +\r\n-            \"1,,,\\n\" +\r\n-            \"2,,,\\n\" +\r\n-            \"3,,,\\n\";\r\n-        final CSVFormat format = CSVFormat.Builder.create()\r\n-            .setDelimiter(',')\r\n-            .setQuote('\\'')\r\n-            .get();\r\n-        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setTrackBytes(true).get()) {\r\n-            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n-\r\n-            assertEquals(0, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(1, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n-\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(2, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), 26);\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(4, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), 43);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordNumberWithCR() throws Exception {\r\n-        validateRecordNumbers(String.valueOf(CR));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordNumberWithCRLF() throws Exception {\r\n-        validateRecordNumbers(CRLF);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordNumberWithLF() throws Exception {\r\n-        validateRecordNumbers(String.valueOf(LF));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordPositionWithCRLF() throws Exception {\r\n-        validateRecordPosition(CRLF);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordPositionWithLF() throws Exception {\r\n-        validateRecordPosition(String.valueOf(LF));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecords() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(RESULT.length, records.size());\r\n-            assertFalse(records.isEmpty());\r\n-            for (int i = 0; i < RESULT.length; i++) {\r\n-                assertArrayEquals(RESULT[i], records.get(i).values());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordsFromBrokenInputStream() throws IOException {\r\n-        @SuppressWarnings(\"resource\") // We also get an exception on close, which is OK but can't assert in a try.\r\n-        final CSVParser parser = CSVParser.parse(new BrokenInputStream(), UTF_8, CSVFormat.DEFAULT);\r\n-        assertThrows(UncheckedIOException.class, parser::getRecords);\r\n-\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordThreeBytesRead() throws Exception {\r\n-        final String code = \"id,date,val5,val4\\n\" +\r\n-            \"11111111111111,'4017-09-01',,v4\\n\" +\r\n-            \"22222222222222,'4017-01-01',,v4\\n\" +\r\n-            \"33333333333333,'4017-01-01',,v4\\n\";\r\n-        final CSVFormat format = CSVFormat.Builder.create()\r\n-            .setDelimiter(',')\r\n-            .setQuote('\\'')\r\n-            .get();\r\n-        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setTrackBytes(true).get()) {\r\n-            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n-\r\n-            assertEquals(0, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(1, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n-\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(2, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n-\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), 95);\r\n-\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(4, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), 154);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordWithMultiLineValues() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF + \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\",\r\n-                CSVFormat.DEFAULT.withRecordSeparator(CRLF))) {\r\n-            CSVRecord record;\r\n-            assertEquals(0, parser.getRecordNumber());\r\n-            assertEquals(0, parser.getCurrentLineNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(3, parser.getCurrentLineNumber());\r\n-            assertEquals(1, record.getRecordNumber());\r\n-            assertEquals(1, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(6, parser.getCurrentLineNumber());\r\n-            assertEquals(2, record.getRecordNumber());\r\n-            assertEquals(2, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(9, parser.getCurrentLineNumber());\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(3, parser.getRecordNumber());\r\n-            assertNull(record = parser.nextRecord());\r\n-            assertEquals(9, parser.getCurrentLineNumber());\r\n-            assertEquals(3, parser.getRecordNumber());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetTrailerComment_HeaderComment1() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_AUTO_HEADER)) {\r\n-            parser.getRecords();\r\n-            assertFalse(parser.hasTrailerComment());\r\n-            assertNull(parser.getTrailerComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetTrailerComment_HeaderComment2() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER)) {\r\n-            parser.getRecords();\r\n-            assertFalse(parser.hasTrailerComment());\r\n-            assertNull(parser.getTrailerComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetTrailerComment_HeaderComment3() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\r\n-            parser.getRecords();\r\n-            assertFalse(parser.hasTrailerComment());\r\n-            assertNull(parser.getTrailerComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetTrailerComment_HeaderTrailerComment1() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_TRAILER_COMMENT, FORMAT_AUTO_HEADER)) {\r\n-            parser.getRecords();\r\n-            assertTrue(parser.hasTrailerComment());\r\n-            assertEquals(\"comment\", parser.getTrailerComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetTrailerComment_HeaderTrailerComment2() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_TRAILER_COMMENT, FORMAT_EXPLICIT_HEADER)) {\r\n-            parser.getRecords();\r\n-            assertTrue(parser.hasTrailerComment());\r\n-            assertEquals(\"comment\", parser.getTrailerComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetTrailerComment_HeaderTrailerComment3() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_TRAILER_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\r\n-            parser.getRecords();\r\n-            assertTrue(parser.hasTrailerComment());\r\n-            assertEquals(\"comment\", parser.getTrailerComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetTrailerComment_MultilineComment() throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(CSV_INPUT_MULTILINE_HEADER_TRAILER_COMMENT, FORMAT_AUTO_HEADER)) {\r\n-            parser.getRecords();\r\n-            assertTrue(parser.hasTrailerComment());\r\n-            assertEquals(\"multi-line\" + LF + \"comment\", parser.getTrailerComment());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeader() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-\r\n-            for (int i = 0; i < 2; i++) {\r\n-                assertTrue(records.hasNext());\r\n-                final CSVRecord record = records.next();\r\n-                assertEquals(record.get(0), record.get(\"a\"));\r\n-                assertEquals(record.get(1), record.get(\"b\"));\r\n-                assertEquals(record.get(2), record.get(\"c\"));\r\n-            }\r\n-\r\n-            assertFalse(records.hasNext());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeaderComment() throws Exception {\r\n-        final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withCommentMarker('#').withHeader().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            for (int i = 0; i < 2; i++) {\r\n-                assertTrue(records.hasNext());\r\n-                final CSVRecord record = records.next();\r\n-                assertEquals(record.get(0), record.get(\"a\"));\r\n-                assertEquals(record.get(1), record.get(\"b\"));\r\n-                assertEquals(record.get(2), record.get(\"c\"));\r\n-            }\r\n-            assertFalse(records.hasNext());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeaderMissing() throws Exception {\r\n-        final Reader in = new StringReader(\"a,,c\\n1,2,3\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            for (int i = 0; i < 2; i++) {\r\n-                assertTrue(records.hasNext());\r\n-                final CSVRecord record = records.next();\r\n-                assertEquals(record.get(0), record.get(\"a\"));\r\n-                assertEquals(record.get(2), record.get(\"c\"));\r\n-            }\r\n-            assertFalse(records.hasNext());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeaderMissingWithNull() throws Exception {\r\n-        final Reader in = new StringReader(\"a,,c,,e\\n1,2,3,4,5\\nv,w,x,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().withNullString(\"\").withAllowMissingColumnNames().parse(in)) {\r\n-            parser.iterator();\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeadersMissing() throws Exception {\r\n-        try (Reader in = new StringReader(\"a,,c,,e\\n1,2,3,4,5\\nv,w,x,y,z\");\r\n-                CSVParser parser = CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames().parse(in)) {\r\n-            parser.iterator();\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeadersMissingException() {\r\n-        final Reader in = new StringReader(\"a,,c,,e\\n1,2,3,4,5\\nv,w,x,y,z\");\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withHeader().parse(in).iterator());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeadersMissingOneColumnException() {\r\n-        final Reader in = new StringReader(\"a,,c,d,e\\n1,2,3,4,5\\nv,w,x,y,z\");\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withHeader().parse(in).iterator());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeadersWithNullColumnName() throws IOException {\r\n-        final Reader in = new StringReader(\"header1,null,header3\\n1,2,3\\n4,5,6\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().withNullString(\"null\").withAllowMissingColumnNames().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            // Expect the null header to be missing\r\n-            @SuppressWarnings(\"resource\")\r\n-            final CSVParser recordParser = record.getParser();\r\n-            assertEquals(Arrays.asList(\"header1\", \"header3\"), recordParser.getHeaderNames());\r\n-            assertEquals(2, recordParser.getHeaderMap().size());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testIgnoreCaseHeaderMapping() throws Exception {\r\n-        final Reader reader = new StringReader(\"1,2,3\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"One\", \"TWO\", \"three\").withIgnoreHeaderCase().parse(reader)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            assertEquals(\"1\", record.get(\"one\"));\r\n-            assertEquals(\"2\", record.get(\"two\"));\r\n-            assertEquals(\"3\", record.get(\"THREE\"));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testIgnoreEmptyLines() throws IOException {\r\n-        final String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\r\n-        // String code = \"world\\r\\n\\n\";\r\n-        // String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\r\n-        try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(3, records.size());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testInvalidFormat() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter(CR));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testIterator() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.parse(in)) {\r\n-            final Iterator<CSVRecord> iterator = parser.iterator();\r\n-            assertTrue(iterator.hasNext());\r\n-            assertThrows(UnsupportedOperationException.class, iterator::remove);\r\n-            assertArrayEquals(new String[] { \"a\", \"b\", \"c\" }, iterator.next().values());\r\n-            assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, iterator.next().values());\r\n-            assertTrue(iterator.hasNext());\r\n-            assertTrue(iterator.hasNext());\r\n-            assertTrue(iterator.hasNext());\r\n-            assertArrayEquals(new String[] { \"x\", \"y\", \"z\" }, iterator.next().values());\r\n-            assertFalse(iterator.hasNext());\r\n-            assertThrows(NoSuchElementException.class, iterator::next);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testIteratorSequenceBreaking() throws IOException {\r\n-        final String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\r\n-        // Iterator hasNext() shouldn't break sequence\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows))) {\r\n-            final Iterator<CSVRecord> iter = parser.iterator();\r\n-            int recordNumber = 0;\r\n-            while (iter.hasNext()) {\r\n-                final CSVRecord record = iter.next();\r\n-                recordNumber++;\r\n-                assertEquals(String.valueOf(recordNumber), record.get(0));\r\n-                if (recordNumber >= 2) {\r\n-                    break;\r\n-                }\r\n-            }\r\n-            iter.hasNext();\r\n-            while (iter.hasNext()) {\r\n-                final CSVRecord record = iter.next();\r\n-                recordNumber++;\r\n-                assertEquals(String.valueOf(recordNumber), record.get(0));\r\n-            }\r\n-        }\r\n-        // Consecutive enhanced for loops shouldn't break sequence\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows))) {\r\n-            int recordNumber = 0;\r\n-            for (final CSVRecord record : parser) {\r\n-                recordNumber++;\r\n-                assertEquals(String.valueOf(recordNumber), record.get(0));\r\n-                if (recordNumber >= 2) {\r\n-                    break;\r\n-                }\r\n-            }\r\n-            for (final CSVRecord record : parser) {\r\n-                recordNumber++;\r\n-                assertEquals(String.valueOf(recordNumber), record.get(0));\r\n-            }\r\n-        }\r\n-        // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows))) {\r\n-            int recordNumber = 0;\r\n-            for (final CSVRecord record : parser) {\r\n-                recordNumber++;\r\n-                assertEquals(String.valueOf(recordNumber), record.get(0));\r\n-                if (recordNumber >= 2) {\r\n-                    break;\r\n-                }\r\n-            }\r\n-            parser.iterator().hasNext();\r\n-            for (final CSVRecord record : parser) {\r\n-                recordNumber++;\r\n-                assertEquals(String.valueOf(recordNumber), record.get(0));\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testLineFeedEndings() throws IOException {\r\n-        final String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\r\n-        try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertEquals(4, records.size());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").withSkipHeaderRecord().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            CSVRecord record;\r\n-            // 1st record\r\n-            record = records.next();\r\n-            assertTrue(record.isMapped(\"A\"));\r\n-            assertTrue(record.isMapped(\"B\"));\r\n-            assertTrue(record.isMapped(\"C\"));\r\n-            assertTrue(record.isSet(\"A\"));\r\n-            assertTrue(record.isSet(\"B\"));\r\n-            assertFalse(record.isSet(\"C\"));\r\n-            assertEquals(\"1\", record.get(\"A\"));\r\n-            assertEquals(\"2\", record.get(\"B\"));\r\n-            assertFalse(record.isConsistent());\r\n-            // 2nd record\r\n-            record = records.next();\r\n-            assertTrue(record.isMapped(\"A\"));\r\n-            assertTrue(record.isMapped(\"B\"));\r\n-            assertTrue(record.isMapped(\"C\"));\r\n-            assertTrue(record.isSet(\"A\"));\r\n-            assertTrue(record.isSet(\"B\"));\r\n-            assertTrue(record.isSet(\"C\"));\r\n-            assertEquals(\"x\", record.get(\"A\"));\r\n-            assertEquals(\"y\", record.get(\"B\"));\r\n-            assertEquals(\"z\", record.get(\"C\"));\r\n-            assertTrue(record.isConsistent());\r\n-            // end\r\n-            assertFalse(records.hasNext());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testMongoDbCsv() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"\\\"a a\\\",b,c\" + LF + \"d,e,f\", CSVFormat.MONGODB_CSV)) {\r\n-            final Iterator<CSVRecord> itr1 = parser.iterator();\r\n-            final Iterator<CSVRecord> itr2 = parser.iterator();\r\n-\r\n-            final CSVRecord first = itr1.next();\r\n-            assertEquals(\"a a\", first.get(0));\r\n-            assertEquals(\"b\", first.get(1));\r\n-            assertEquals(\"c\", first.get(2));\r\n-\r\n-            final CSVRecord second = itr2.next();\r\n-            assertEquals(\"d\", second.get(0));\r\n-            assertEquals(\"e\", second.get(1));\r\n-            assertEquals(\"f\", second.get(2));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // TODO this may lead to strange behavior, throw an exception if iterator() has already been called?\r\n-    public void testMultipleIterators() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"a,b,c\" + CRLF + \"d,e,f\", CSVFormat.DEFAULT)) {\r\n-            final Iterator<CSVRecord> itr1 = parser.iterator();\r\n-\r\n-            final CSVRecord first = itr1.next();\r\n-            assertEquals(\"a\", first.get(0));\r\n-            assertEquals(\"b\", first.get(1));\r\n-            assertEquals(\"c\", first.get(2));\r\n-\r\n-            final CSVRecord second = itr1.next();\r\n-            assertEquals(\"d\", second.get(0));\r\n-            assertEquals(\"e\", second.get(1));\r\n-            assertEquals(\"f\", second.get(2));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNewCSVParserNullReaderFormat() {\r\n-        assertThrows(NullPointerException.class, () -> new CSVParser(null, CSVFormat.DEFAULT));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNewCSVParserReaderNullFormat() {\r\n-        assertThrows(NullPointerException.class, () -> new CSVParser(new StringReader(\"\"), null));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNoHeaderMap() throws Exception {\r\n-        try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT)) {\r\n-            assertNull(parser.getHeaderMap());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNotValueCSV() throws IOException {\r\n-        final String source = \"#\";\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT.withCommentMarker('#');\r\n-        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n-            final CSVRecord csvRecord = csvParser.nextRecord();\r\n-            assertNull(csvRecord);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParse() throws Exception {\r\n-        final ClassLoader loader = ClassLoader.getSystemClassLoader();\r\n-        final URL url = loader.getResource(\"org/apache/commons/csv/CSVFileParser/test.csv\");\r\n-        final CSVFormat format = CSVFormat.DEFAULT.builder().setHeader(\"A\", \"B\", \"C\", \"D\").get();\r\n-        final Charset charset = StandardCharsets.UTF_8;\r\n-        // Reader\r\n-        try (CSVParser parser = CSVParser.parse(new InputStreamReader(url.openStream(), charset), format)) {\r\n-            parseFully(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.builder().setReader(new InputStreamReader(url.openStream(), charset)).setFormat(format).get()) {\r\n-            parseFully(parser);\r\n-        }\r\n-        // String\r\n-        final Path path = Paths.get(url.toURI());\r\n-        final String string = new String(Files.readAllBytes(path), charset);\r\n-        try (CSVParser parser = CSVParser.parse(string, format)) {\r\n-            parseFully(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.builder().setCharSequence(string).setFormat(format).get()) {\r\n-            parseFully(parser);\r\n-        }\r\n-        // File\r\n-        final File file = new File(url.toURI());\r\n-        try (CSVParser parser = CSVParser.parse(file, charset, format)) {\r\n-            parseFully(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.builder().setFile(file).setCharset(charset).setFormat(format).get()) {\r\n-            parseFully(parser);\r\n-        }\r\n-        // InputStream\r\n-        try (CSVParser parser = CSVParser.parse(url.openStream(), charset, format)) {\r\n-            parseFully(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.builder().setInputStream(url.openStream()).setCharset(charset).setFormat(format).get()) {\r\n-            parseFully(parser);\r\n-        }\r\n-        // Path\r\n-        try (CSVParser parser = CSVParser.parse(path, charset, format)) {\r\n-            parseFully(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.builder().setPath(path).setCharset(charset).setFormat(format).get()) {\r\n-            parseFully(parser);\r\n-        }\r\n-        // URL\r\n-        try (CSVParser parser = CSVParser.parse(url, charset, format)) {\r\n-            parseFully(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.builder().setURI(url.toURI()).setCharset(charset).setFormat(format).get()) {\r\n-            parseFully(parser);\r\n-        }\r\n-        // InputStreamReader\r\n-        try (CSVParser parser = new CSVParser(new InputStreamReader(url.openStream(), charset), format)) {\r\n-            parseFully(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.builder().setReader(new InputStreamReader(url.openStream(), charset)).setFormat(format).get()) {\r\n-            parseFully(parser);\r\n-        }\r\n-        // InputStreamReader with longs\r\n-        try (CSVParser parser = new CSVParser(new InputStreamReader(url.openStream(), charset), format, /* characterOffset= */0, /* recordNumber= */1)) {\r\n-            parseFully(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.builder().setReader(new InputStreamReader(url.openStream(), charset)).setFormat(format).setCharacterOffset(0)\r\n-                .setRecordNumber(0).get()) {\r\n-            parseFully(parser);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseFileNullFormat() {\r\n-        assertThrows(NullPointerException.class, () -> CSVParser.parse(new File(\"CSVFileParser/test.csv\"), Charset.defaultCharset(), null));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseNullFileFormat() {\r\n-        assertThrows(NullPointerException.class, () -> CSVParser.parse((File) null, Charset.defaultCharset(), CSVFormat.DEFAULT));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseNullPathFormat() {\r\n-        assertThrows(NullPointerException.class, () -> CSVParser.parse((Path) null, Charset.defaultCharset(), CSVFormat.DEFAULT));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseNullStringFormat() {\r\n-        assertThrows(NullPointerException.class, () -> CSVParser.parse((String) null, CSVFormat.DEFAULT));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseNullUrlCharsetFormat() {\r\n-        assertThrows(NullPointerException.class, () -> CSVParser.parse((URL) null, Charset.defaultCharset(), CSVFormat.DEFAULT));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParserUrlNullCharsetFormat() {\r\n-        assertThrows(NullPointerException.class, () -> CSVParser.parse(new URL(\"https://commons.apache.org\"), null, CSVFormat.DEFAULT));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseStringNullFormat() {\r\n-        assertThrows(NullPointerException.class, () -> CSVParser.parse(\"csv data\", (CSVFormat) null));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseUrlCharsetNullFormat() {\r\n-        assertThrows(NullPointerException.class, () -> CSVParser.parse(new URL(\"https://commons.apache.org\"), Charset.defaultCharset(), null));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseWithDelimiterStringWithEscape() throws IOException {\r\n-        final String source = \"a![!|!]b![|]c[|]xyz\\r\\nabc[abc][|]xyz\";\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setEscape('!').get();\r\n-        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n-            CSVRecord csvRecord = csvParser.nextRecord();\r\n-            assertEquals(\"a[|]b![|]c\", csvRecord.get(0));\r\n-            assertEquals(\"xyz\", csvRecord.get(1));\r\n-            csvRecord = csvParser.nextRecord();\r\n-            assertEquals(\"abc[abc]\", csvRecord.get(0));\r\n-            assertEquals(\"xyz\", csvRecord.get(1));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseWithDelimiterStringWithQuote() throws IOException {\r\n-        final String source = \"'a[|]b[|]c'[|]xyz\\r\\nabc[abc][|]xyz\";\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setQuote('\\'').get();\r\n-        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n-            CSVRecord csvRecord = csvParser.nextRecord();\r\n-            assertEquals(\"a[|]b[|]c\", csvRecord.get(0));\r\n-            assertEquals(\"xyz\", csvRecord.get(1));\r\n-            csvRecord = csvParser.nextRecord();\r\n-            assertEquals(\"abc[abc]\", csvRecord.get(0));\r\n-            assertEquals(\"xyz\", csvRecord.get(1));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseWithDelimiterWithEscape() throws IOException {\r\n-        final String source = \"a!,b!,c,xyz\";\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT.withEscape('!');\r\n-        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n-            final CSVRecord csvRecord = csvParser.nextRecord();\r\n-            assertEquals(\"a,b,c\", csvRecord.get(0));\r\n-            assertEquals(\"xyz\", csvRecord.get(1));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseWithDelimiterWithQuote() throws IOException {\r\n-        final String source = \"'a,b,c',xyz\";\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT.withQuote('\\'');\r\n-        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n-            final CSVRecord csvRecord = csvParser.nextRecord();\r\n-            assertEquals(\"a,b,c\", csvRecord.get(0));\r\n-            assertEquals(\"xyz\", csvRecord.get(1));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseWithQuoteThrowsException() {\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT.withQuote('\\'');\r\n-        assertThrows(IOException.class, () -> csvFormat.parse(new StringReader(\"'a,b,c','\")).nextRecord());\r\n-        assertThrows(IOException.class, () -> csvFormat.parse(new StringReader(\"'a,b,c'abc,xyz\")).nextRecord());\r\n-        assertThrows(IOException.class, () -> csvFormat.parse(new StringReader(\"'abc'a,b,c',xyz\")).nextRecord());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseWithQuoteWithEscape() throws IOException {\r\n-        final String source = \"'a?,b?,c?d',xyz\";\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT.withQuote('\\'').withEscape('?');\r\n-        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\r\n-            final CSVRecord csvRecord = csvParser.nextRecord();\r\n-            assertEquals(\"a,b,c?d\", csvRecord.get(0));\r\n-            assertEquals(\"xyz\", csvRecord.get(1));\r\n-        }\r\n-    }\r\n-\r\n-    @ParameterizedTest\r\n-    @EnumSource(CSVFormat.Predefined.class)\r\n-    public void testParsingPrintedEmptyFirstColumn(final CSVFormat.Predefined format) throws Exception {\r\n-        final String[][] lines = { { \"a\", \"b\" }, { \"\", \"x\" } };\r\n-        final StringWriter buf = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(buf, format.getFormat())) {\r\n-            printer.printRecords(Stream.of(lines));\r\n-        }\r\n-        try (CSVParser csvRecords = CSVParser.builder()\r\n-                .setReader(new StringReader(buf.toString()))\r\n-                .setFormat(format.getFormat())\r\n-                .get()) {\r\n-            for (final String[] line : lines) {\r\n-                assertArrayEquals(line, csvRecords.nextRecord().values());\r\n-            }\r\n-            assertNull(csvRecords.nextRecord());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testProvidedHeader() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-\r\n-            for (int i = 0; i < 3; i++) {\r\n-                assertTrue(records.hasNext());\r\n-                final CSVRecord record = records.next();\r\n-                assertTrue(record.isMapped(\"A\"));\r\n-                assertTrue(record.isMapped(\"B\"));\r\n-                assertTrue(record.isMapped(\"C\"));\r\n-                assertFalse(record.isMapped(\"NOT MAPPED\"));\r\n-                assertEquals(record.get(0), record.get(\"A\"));\r\n-                assertEquals(record.get(1), record.get(\"B\"));\r\n-                assertEquals(record.get(2), record.get(\"C\"));\r\n-            }\r\n-\r\n-            assertFalse(records.hasNext());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testProvidedHeaderAuto() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-\r\n-            for (int i = 0; i < 2; i++) {\r\n-                assertTrue(records.hasNext());\r\n-                final CSVRecord record = records.next();\r\n-                assertTrue(record.isMapped(\"a\"));\r\n-                assertTrue(record.isMapped(\"b\"));\r\n-                assertTrue(record.isMapped(\"c\"));\r\n-                assertFalse(record.isMapped(\"NOT MAPPED\"));\r\n-                assertEquals(record.get(0), record.get(\"a\"));\r\n-                assertEquals(record.get(1), record.get(\"b\"));\r\n-                assertEquals(record.get(2), record.get(\"c\"));\r\n-            }\r\n-\r\n-            assertFalse(records.hasNext());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRepeatedHeadersAreReturnedInCSVRecordHeaderNames() throws IOException {\r\n-        final Reader in = new StringReader(\"header1,header2,header1\\n1,2,3\\n4,5,6\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withFirstRecordAsHeader().withTrim().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            @SuppressWarnings(\"resource\")\r\n-            final CSVParser recordParser = record.getParser();\r\n-            assertEquals(Arrays.asList(\"header1\", \"header2\", \"header1\"), recordParser.getHeaderNames());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRoundtrip() throws Exception {\r\n-        final StringWriter out = new StringWriter();\r\n-        final String data = \"a,b,c\\r\\n1,2,3\\r\\nx,y,z\\r\\n\";\r\n-        try (CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT);\r\n-                CSVParser parse = CSVParser.parse(data, CSVFormat.DEFAULT)) {\r\n-            for (final CSVRecord record : parse) {\r\n-                printer.printRecord(record);\r\n-            }\r\n-            assertEquals(data, out.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testSkipAutoHeader() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            assertEquals(\"1\", record.get(\"a\"));\r\n-            assertEquals(\"2\", record.get(\"b\"));\r\n-            assertEquals(\"3\", record.get(\"c\"));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testSkipHeaderOverrideDuplicateHeaders() throws Exception {\r\n-        final Reader in = new StringReader(\"a,a,a\\n1,2,3\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            assertEquals(\"1\", record.get(\"X\"));\r\n-            assertEquals(\"2\", record.get(\"Y\"));\r\n-            assertEquals(\"3\", record.get(\"Z\"));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testSkipSetAltHeaders() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            assertEquals(\"1\", record.get(\"X\"));\r\n-            assertEquals(\"2\", record.get(\"Y\"));\r\n-            assertEquals(\"3\", record.get(\"Z\"));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testSkipSetHeader() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"a\", \"b\", \"c\").withSkipHeaderRecord().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            assertEquals(\"1\", record.get(\"a\"));\r\n-            assertEquals(\"2\", record.get(\"b\"));\r\n-            assertEquals(\"3\", record.get(\"c\"));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testStartWithEmptyLinesThenHeaders() throws Exception {\r\n-        final String[] codes = { \"\\r\\n\\r\\n\\r\\nhello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\r\n-        final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\r\n-                { \"\" } };\r\n-        for (final String code : codes) {\r\n-            try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\r\n-                final List<CSVRecord> records = parser.getRecords();\r\n-                assertEquals(res.length, records.size());\r\n-                assertFalse(records.isEmpty());\r\n-                for (int i = 0; i < res.length; i++) {\r\n-                    assertArrayEquals(res[i], records.get(i).values());\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testStream() throws Exception {\r\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.parse(in)) {\r\n-            final List<CSVRecord> list = parser.stream().collect(Collectors.toList());\r\n-            assertFalse(list.isEmpty());\r\n-            assertArrayEquals(new String[] { \"a\", \"b\", \"c\" }, list.get(0).values());\r\n-            assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, list.get(1).values());\r\n-            assertArrayEquals(new String[] { \"x\", \"y\", \"z\" }, list.get(2).values());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testThrowExceptionWithLineAndPosition() throws IOException {\r\n-        final String csvContent = \"col1,col2,col3,col4,col5,col6,col7,col8,col9,col10\\nrec1,rec2,rec3,rec4,rec5,rec6,rec7,rec8,\\\"\\\"rec9\\\"\\\",rec10\";\r\n-        final StringReader stringReader = new StringReader(csvContent);\r\n-        // @formatter:off\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT.builder()\r\n-                .setHeader()\r\n-                .setSkipHeaderRecord(true)\r\n-                .get();\r\n-        // @formatter:on\r\n-        try (CSVParser csvParser = csvFormat.parse(stringReader)) {\r\n-            final UncheckedIOException exception = assertThrows(UncheckedIOException.class, csvParser::getRecords);\r\n-            assertInstanceOf(CSVException.class, exception.getCause());\r\n-            assertTrue(exception.getMessage().contains(\"Invalid character between encapsulated token and delimiter at line: 2, position: 94\"),\r\n-                    exception::getMessage);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testTrailingDelimiter() throws Exception {\r\n-        final Reader in = new StringReader(\"a,a,a,\\n\\\"1\\\",\\\"2\\\",\\\"3\\\",\\nx,y,z,\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrailingDelimiter().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            assertEquals(\"1\", record.get(\"X\"));\r\n-            assertEquals(\"2\", record.get(\"Y\"));\r\n-            assertEquals(\"3\", record.get(\"Z\"));\r\n-            assertEquals(3, record.size());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testTrim() throws Exception {\r\n-        final Reader in = new StringReader(\"a,a,a\\n\\\" 1 \\\",\\\" 2 \\\",\\\" 3 \\\"\\nx,y,z\");\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrim().parse(in)) {\r\n-            final Iterator<CSVRecord> records = parser.iterator();\r\n-            final CSVRecord record = records.next();\r\n-            assertEquals(\"1\", record.get(\"X\"));\r\n-            assertEquals(\"2\", record.get(\"Y\"));\r\n-            assertEquals(\"3\", record.get(\"Z\"));\r\n-            assertEquals(3, record.size());\r\n-        }\r\n-    }\r\n-\r\n-    private void validateLineNumbers(final String lineSeparator) throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator))) {\r\n-            assertEquals(0, parser.getCurrentLineNumber());\r\n-            assertNotNull(parser.nextRecord());\r\n-            assertEquals(1, parser.getCurrentLineNumber());\r\n-            assertNotNull(parser.nextRecord());\r\n-            assertEquals(2, parser.getCurrentLineNumber());\r\n-            assertNotNull(parser.nextRecord());\r\n-            // Read EOF without EOL should 3\r\n-            assertEquals(3, parser.getCurrentLineNumber());\r\n-            assertNull(parser.nextRecord());\r\n-            // Read EOF without EOL should 3\r\n-            assertEquals(3, parser.getCurrentLineNumber());\r\n-        }\r\n-    }\r\n-\r\n-    private void validateRecordNumbers(final String lineSeparator) throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator))) {\r\n-            CSVRecord record;\r\n-            assertEquals(0, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(1, record.getRecordNumber());\r\n-            assertEquals(1, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(2, record.getRecordNumber());\r\n-            assertEquals(2, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(3, parser.getRecordNumber());\r\n-            assertNull(record = parser.nextRecord());\r\n-            assertEquals(3, parser.getRecordNumber());\r\n-        }\r\n-    }\r\n-\r\n-    private void validateRecordPosition(final String lineSeparator) throws IOException {\r\n-        final String nl = lineSeparator; // used as linebreak in values for better distinction\r\n-        final String code = \"a,b,c\" + lineSeparator + \"1,2,3\" + lineSeparator +\r\n-                // to see if recordPosition correctly points to the enclosing quote\r\n-                \"'A\" + nl + \"A','B\" + nl + \"B',CC\" + lineSeparator +\r\n-                // unicode test... not very relevant while operating on strings instead of bytes, but for\r\n-                // completeness...\r\n-                \"\\u00c4,\\u00d6,\\u00dc\" + lineSeparator + \"EOF,EOF,EOF\";\r\n-        final CSVFormat format = CSVFormat.newFormat(',').withQuote('\\'').withRecordSeparator(lineSeparator);\r\n-        final long positionRecord3;\r\n-        try (CSVParser parser = CSVParser.parse(code, format)) {\r\n-            CSVRecord record;\r\n-            assertEquals(0, parser.getRecordNumber());\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(1, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('a'), record.getCharacterPosition());\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(2, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            positionRecord3 = record.getCharacterPosition();\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(code.indexOf(\"'A\"), record.getCharacterPosition());\r\n-            assertEquals(\"A\" + lineSeparator + \"A\", record.get(0));\r\n-            assertEquals(\"B\" + lineSeparator + \"B\", record.get(1));\r\n-            assertEquals(\"CC\", record.get(2));\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(4, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('\\u00c4'), record.getCharacterPosition());\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(5, record.getRecordNumber());\r\n-            assertEquals(code.indexOf(\"EOF\"), record.getCharacterPosition());\r\n-        }\r\n-        // now try to read starting at record 3\r\n-        try (CSVParser parser = CSVParser.builder()\r\n-                .setReader(new StringReader(code.substring((int) positionRecord3)))\r\n-                .setFormat(format)\r\n-                .setCharacterOffset(positionRecord3)\r\n-                .setRecordNumber(3)\r\n-                .get()) {\r\n-            CSVRecord record;\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(code.indexOf(\"'A\"), record.getCharacterPosition());\r\n-            assertEquals(\"A\" + lineSeparator + \"A\", record.get(0));\r\n-            assertEquals(\"B\" + lineSeparator + \"B\", record.get(1));\r\n-            assertEquals(\"CC\", record.get(2));\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(4, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('\\u00c4'), record.getCharacterPosition());\r\n-            assertEquals(\"\\u00c4\", record.get(0));\r\n-        } // again with ctor\r\n-        try (CSVParser parser = new CSVParser(new StringReader(code.substring((int) positionRecord3)), format, positionRecord3, 3)) {\r\n-            CSVRecord record;\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(code.indexOf(\"'A\"), record.getCharacterPosition());\r\n-            assertEquals(\"A\" + lineSeparator + \"A\", record.get(0));\r\n-            assertEquals(\"B\" + lineSeparator + \"B\", record.get(1));\r\n-            assertEquals(\"CC\", record.get(2));\r\n-            // nextRecord\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(4, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('\\u00c4'), record.getCharacterPosition());\r\n-            assertEquals(\"\\u00c4\", record.get(0));\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import static org.apache.commons.csv.Constants.CR;\n+import static org.apache.commons.csv.Constants.CRLF;\n+import static org.apache.commons.csv.Constants.LF;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PipedReader;\n+import java.io.PipedWriter;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.input.BOMInputStream;\n+import org.apache.commons.io.input.BrokenInputStream;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+/**\n+ * CSVParserTest\n+ *\n+ * The test are organized in three different sections: The 'setter/getter' section, the lexer section and finally the parser section. In case a test fails, you\n+ * should follow a top-down approach for fixing a potential bug (its likely that the parser itself fails if the lexer has problems...).\n+ */\n+public class CSVParserTest {\n+\n+    private static final CSVFormat EXCEL_WITH_HEADER = CSVFormat.EXCEL.withHeader();\n+\n+    private static final Charset UTF_8 = StandardCharsets.UTF_8;\n+\n+    private static final String UTF_8_NAME = UTF_8.name();\n+\n+    private static final String CSV_INPUT = \"a,b,c,d\\n\" + \" a , b , 1 2 \\n\" + \"\\\"foo baar\\\", b,\\n\" +\n+            // + \" \\\"foo\\n,,\\n\\\"\\\",,\\n\\\\\\\"\\\",d,e\\n\";\n+            \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\"\\\"\\\",d,e\\n\"; // changed to use standard CSV escaping\n+\n+    private static final String CSV_INPUT_1 = \"a,b,c,d\";\n+\n+    private static final String CSV_INPUT_2 = \"a,b,1 2\";\n+\n+    private static final String[][] RESULT = { { \"a\", \"b\", \"c\", \"d\" }, { \"a\", \"b\", \"1 2\" }, { \"foo baar\", \"b\", \"\" }, { \"foo\\n,,\\n\\\",,\\n\\\"\", \"d\", \"e\" } };\n+\n+    // CSV with no header comments\n+    private static final String CSV_INPUT_NO_COMMENT = \"A,B\" + CRLF + \"1,2\" + CRLF;\n+\n+    // CSV with a header comment\n+    private static final String CSV_INPUT_HEADER_COMMENT = \"# header comment\" + CRLF + \"A,B\" + CRLF + \"1,2\" + CRLF;\n+\n+    // CSV with a single line header and trailer comment\n+    private static final String CSV_INPUT_HEADER_TRAILER_COMMENT = \"# header comment\" + CRLF + \"A,B\" + CRLF + \"1,2\" + CRLF + \"# comment\";\n+\n+    // CSV with a multi-line header and trailer comment\n+    private static final String CSV_INPUT_MULTILINE_HEADER_TRAILER_COMMENT = \"# multi-line\" + CRLF + \"# header comment\" + CRLF + \"A,B\" + CRLF + \"1,2\" + CRLF +\n+            \"# multi-line\" + CRLF + \"# comment\";\n+\n+    // Format with auto-detected header\n+    private static final CSVFormat FORMAT_AUTO_HEADER = CSVFormat.Builder.create(CSVFormat.DEFAULT).setCommentMarker('#').setHeader().get();\n+\n+    // Format with explicit header\n+    // @formatter:off\n+    private static final CSVFormat FORMAT_EXPLICIT_HEADER = CSVFormat.Builder.create(CSVFormat.DEFAULT)\n+            .setSkipHeaderRecord(true)\n+            .setCommentMarker('#')\n+            .setHeader(\"A\", \"B\")\n+            .get();\n+    // @formatter:on\n+\n+    // Format with explicit header that does not skip the header line\n+    // @formatter:off\n+    CSVFormat FORMAT_EXPLICIT_HEADER_NOSKIP = CSVFormat.Builder.create(CSVFormat.DEFAULT)\n+            .setCommentMarker('#')\n+            .setHeader(\"A\", \"B\")\n+            .get();\n+    // @formatter:on\n+\n+    @SuppressWarnings(\"resource\") // caller releases\n+    private BOMInputStream createBOMInputStream(final String resource) throws IOException {\n+        return new BOMInputStream(ClassLoader.getSystemClassLoader().getResource(resource).openStream());\n+    }\n+\n+    CSVRecord parse(final CSVParser parser, final int failParseRecordNo) throws IOException {\n+        if (parser.getRecordNumber() + 1 == failParseRecordNo) {\n+            assertThrows(IOException.class, () -> parser.nextRecord());\n+            return null;\n+        }\n+        return parser.nextRecord();\n+    }\n+\n+    private void parseFully(final CSVParser parser) {\n+        parser.forEach(Assertions::assertNotNull);\n+    }\n+\n+    @Test\n+    public void testBackslashEscaping() throws IOException {\n+        // To avoid confusion over the need for escaping chars in java code,\n+        // We will test with a forward slash as the escape char, and a single\n+        // quote as the encapsulator.\n+\n+        // @formatter:off\n+        final String code = \"one,two,three\\n\" + // 0\n+            \"'',''\\n\" + // 1) empty encapsulators\n+            \"/',/'\\n\" + // 2) single encapsulators\n+            \"'/'','/''\\n\" + // 3) single encapsulators encapsulated via escape\n+            \"'''',''''\\n\" + // 4) single encapsulators encapsulated via doubling\n+            \"/,,/,\\n\" + // 5) separator escaped\n+            \"//,//\\n\" + // 6) escape escaped\n+            \"'//','//'\\n\" + // 7) escape escaped in encapsulation\n+            \"   8   ,   \\\"quoted \\\"\\\" /\\\" // string\\\"   \\n\" + // don't eat spaces\n+            \"9,   /\\n   \\n\" + // escaped newline\n+            \"\";\n+        final String[][] res = {{\"one\", \"two\", \"three\"}, // 0\n+            {\"\", \"\"}, // 1\n+            {\"'\", \"'\"}, // 2\n+            {\"'\", \"'\"}, // 3\n+            {\"'\", \"'\"}, // 4\n+            {\",\", \",\"}, // 5\n+            {\"/\", \"/\"}, // 6\n+            {\"/\", \"/\"}, // 7\n+            {\"   8   \", \"   \\\"quoted \\\"\\\" /\\\" / string\\\"   \"}, {\"9\", \"   \\n   \"} };\n+        // @formatter:on\n+        final CSVFormat format = CSVFormat.newFormat(',').withQuote('\\'').withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines();\n+        try (CSVParser parser = CSVParser.parse(code, format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertFalse(records.isEmpty());\n+            Utils.compare(\"Records do not match expected result\", res, records);\n+        }\n+    }\n+\n+    @Test\n+    public void testBackslashEscaping2() throws IOException {\n+        // To avoid confusion over the need for escaping chars in java code,\n+        // We will test with a forward slash as the escape char, and a single\n+        // quote as the encapsulator.\n+        // @formatter:off\n+        final String code = \"\" + \" , , \\n\" + // 1)\n+            \" \\t ,  , \\n\" + // 2)\n+            \" // , /, , /,\\n\" + // 3)\n+            \"\";\n+        final String[][] res = {{\" \", \" \", \" \"}, // 1\n+            {\" \\t \", \"  \", \" \"}, // 2\n+            {\" / \", \" , \", \" ,\"}, // 3\n+        };\n+        // @formatter:on\n+        final CSVFormat format = CSVFormat.newFormat(',').withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines();\n+        try (CSVParser parser = CSVParser.parse(code, format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertFalse(records.isEmpty());\n+            Utils.compare(\"\", res, records);\n+        }\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testBackslashEscapingOld() throws IOException {\n+        final String code = \"one,two,three\\n\" + \"on\\\\\\\"e,two\\n\" + \"on\\\"e,two\\n\" + \"one,\\\"tw\\\\\\\"o\\\"\\n\" + \"one,\\\"t\\\\,wo\\\"\\n\" + \"one,two,\\\"th,ree\\\"\\n\" +\n+                \"\\\"a\\\\\\\\\\\"\\n\" + \"a\\\\,b\\n\" + \"\\\"a\\\\\\\\,b\\\"\";\n+        final String[][] res = { { \"one\", \"two\", \"three\" }, { \"on\\\\\\\"e\", \"two\" }, { \"on\\\"e\", \"two\" }, { \"one\", \"tw\\\"o\" }, { \"one\", \"t\\\\,wo\" }, // backslash in\n+                                                                                                                                               // quotes only\n+                                                                                                                                               // escapes a\n+                                                                                                                                               // delimiter\n+                                                                                                                                               // (\",\")\n+                { \"one\", \"two\", \"th,ree\" }, { \"a\\\\\\\\\" }, // backslash in quotes only escapes a delimiter (\",\")\n+                { \"a\\\\\", \"b\" }, // a backslash must be returned\n+                { \"a\\\\\\\\,b\" } // backslash in quotes only escapes a delimiter (\",\")\n+        };\n+        try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(res.length, records.size());\n+            assertFalse(records.isEmpty());\n+            for (int i = 0; i < res.length; i++) {\n+                assertArrayEquals(res[i], records.get(i).values());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Disabled(\"CSV-107\")\n+    public void testBOM() throws IOException {\n+        final URL url = ClassLoader.getSystemClassLoader().getResource(\"org/apache/commons/csv/CSVFileParser/bom.csv\");\n+        try (CSVParser parser = CSVParser.parse(url, StandardCharsets.UTF_8, EXCEL_WITH_HEADER)) {\n+            parser.forEach(record -> assertNotNull(record.get(\"Date\")));\n+        }\n+    }\n+\n+    @Test\n+    public void testBOMInputStreamParserWithInputStream() throws IOException {\n+        try (BOMInputStream inputStream = createBOMInputStream(\"org/apache/commons/csv/CSVFileParser/bom.csv\");\n+                CSVParser parser = CSVParser.parse(inputStream, UTF_8, EXCEL_WITH_HEADER)) {\n+            parser.forEach(record -> assertNotNull(record.get(\"Date\")));\n+        }\n+    }\n+\n+    @Test\n+    public void testBOMInputStreamParserWithReader() throws IOException {\n+        try (Reader reader = new InputStreamReader(createBOMInputStream(\"org/apache/commons/csv/CSVFileParser/bom.csv\"), UTF_8_NAME);\n+                CSVParser parser = CSVParser.builder()\n+                        .setReader(reader)\n+                        .setFormat(EXCEL_WITH_HEADER)\n+                        .get()) {\n+            parser.forEach(record -> assertNotNull(record.get(\"Date\")));\n+        }\n+    }\n+\n+    @Test\n+    public void testBOMInputStreamParseWithReader() throws IOException {\n+        try (Reader reader = new InputStreamReader(createBOMInputStream(\"org/apache/commons/csv/CSVFileParser/bom.csv\"), UTF_8_NAME);\n+                CSVParser parser = CSVParser.builder()\n+                        .setReader(reader)\n+                        .setFormat(EXCEL_WITH_HEADER)\n+                        .get()) {\n+            parser.forEach(record -> assertNotNull(record.get(\"Date\")));\n+        }\n+    }\n+\n+    @Test\n+    public void testCarriageReturnEndings() throws IOException {\n+        final String string = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n+        try (CSVParser parser = CSVParser.builder().setCharSequence(string).get()) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testCarriageReturnLineFeedEndings() throws IOException {\n+        final String string = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n+        try (CSVParser parser = CSVParser.builder().setCharSequence(string).get()) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testClose() throws Exception {\n+        final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n+        final Iterator<CSVRecord> records;\n+        try (CSVParser parser = CSVFormat.DEFAULT.withCommentMarker('#').withHeader().parse(in)) {\n+            records = parser.iterator();\n+            assertTrue(records.hasNext());\n+        }\n+        assertFalse(records.hasNext());\n+        assertThrows(NoSuchElementException.class, records::next);\n+    }\n+\n+    @Test\n+    public void testCSV141CSVFormat_DEFAULT() throws Exception {\n+        testCSV141Failure(CSVFormat.DEFAULT, 3);\n+    }\n+\n+    @Test\n+    public void testCSV141CSVFormat_INFORMIX_UNLOAD() throws Exception {\n+        testCSV141Failure(CSVFormat.INFORMIX_UNLOAD, 1);\n+    }\n+\n+    @Test\n+    public void testCSV141CSVFormat_INFORMIX_UNLOAD_CSV() throws Exception {\n+        testCSV141Failure(CSVFormat.INFORMIX_UNLOAD_CSV, 3);\n+    }\n+\n+    @Test\n+    public void testCSV141CSVFormat_ORACLE() throws Exception {\n+        testCSV141Failure(CSVFormat.ORACLE, 2);\n+    }\n+\n+    @Test\n+    public void testCSV141CSVFormat_POSTGRESQL_CSV() throws Exception {\n+        testCSV141Failure(CSVFormat.POSTGRESQL_CSV, 3);\n+    }\n+\n+    @Test\n+    public void testCSV141Excel() throws Exception {\n+        testCSV141Ok(CSVFormat.EXCEL);\n+    }\n+\n+    private void testCSV141Failure(final CSVFormat format, final int failParseRecordNo) throws IOException {\n+        final Path path = Paths.get(\"src/test/resources/org/apache/commons/csv/CSV-141/csv-141.csv\");\n+        try (CSVParser parser = CSVParser.parse(path, StandardCharsets.UTF_8, format)) {\n+            // row 1\n+            CSVRecord record = parse(parser, failParseRecordNo);\n+            if (record == null) {\n+                return; // expected failure\n+            }\n+            assertEquals(\"1414770317901\", record.get(0));\n+            assertEquals(\"android.widget.EditText\", record.get(1));\n+            assertEquals(\"pass sem1 _84*|*\", record.get(2));\n+            assertEquals(\"0\", record.get(3));\n+            assertEquals(\"pass sem1 _8\", record.get(4));\n+            assertEquals(5, record.size());\n+            // row 2\n+            record = parse(parser, failParseRecordNo);\n+            if (record == null) {\n+                return; // expected failure\n+            }\n+            assertEquals(\"1414770318470\", record.get(0));\n+            assertEquals(\"android.widget.EditText\", record.get(1));\n+            assertEquals(\"pass sem1 _84:|\", record.get(2));\n+            assertEquals(\"0\", record.get(3));\n+            assertEquals(\"pass sem1 _84:\\\\\", record.get(4));\n+            assertEquals(5, record.size());\n+            // row 3: Fail for certain\n+            assertThrows(IOException.class, () -> parser.nextRecord());\n+        }\n+    }\n+\n+    private void testCSV141Ok(final CSVFormat format) throws IOException {\n+        final Path path = Paths.get(\"src/test/resources/org/apache/commons/csv/CSV-141/csv-141.csv\");\n+        try (CSVParser parser = CSVParser.parse(path, StandardCharsets.UTF_8, format)) {\n+            // row 1\n+            CSVRecord record = parser.nextRecord();\n+            assertEquals(\"1414770317901\", record.get(0));\n+            assertEquals(\"android.widget.EditText\", record.get(1));\n+            assertEquals(\"pass sem1 _84*|*\", record.get(2));\n+            assertEquals(\"0\", record.get(3));\n+            assertEquals(\"pass sem1 _8\", record.get(4));\n+            assertEquals(5, record.size());\n+            // row 2\n+            record = parser.nextRecord();\n+            assertEquals(\"1414770318470\", record.get(0));\n+            assertEquals(\"android.widget.EditText\", record.get(1));\n+            assertEquals(\"pass sem1 _84:|\", record.get(2));\n+            assertEquals(\"0\", record.get(3));\n+            assertEquals(\"pass sem1 _84:\\\\\", record.get(4));\n+            assertEquals(5, record.size());\n+            // row 3\n+            record = parser.nextRecord();\n+            assertEquals(\"1414770318327\", record.get(0));\n+            assertEquals(\"android.widget.EditText\", record.get(1));\n+            assertEquals(\"pass sem1\\n1414770318628\\\"\", record.get(2));\n+            assertEquals(\"android.widget.EditText\", record.get(3));\n+            assertEquals(\"pass sem1 _84*|*\", record.get(4));\n+            assertEquals(\"0\", record.get(5));\n+            assertEquals(\"pass sem1\\n\", record.get(6));\n+            assertEquals(7, record.size());\n+            // EOF\n+            record = parser.nextRecord();\n+            assertNull(record);\n+        }\n+    }\n+\n+    @Test\n+    public void testCSV141RFC4180() throws Exception {\n+        testCSV141Failure(CSVFormat.RFC4180, 3);\n+    }\n+\n+    @Test\n+    public void testCSV235() throws IOException {\n+        final String dqString = \"\\\"aaa\\\",\\\"b\\\"\\\"bb\\\",\\\"ccc\\\"\"; // \"aaa\",\"b\"\"bb\",\"ccc\"\n+        try (CSVParser parser = CSVFormat.RFC4180.parse(new StringReader(dqString))) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            assertFalse(records.hasNext());\n+            assertEquals(3, record.size());\n+            assertEquals(\"aaa\", record.get(0));\n+            assertEquals(\"b\\\"bb\", record.get(1));\n+            assertEquals(\"ccc\", record.get(2));\n+        }\n+    }\n+\n+    @Test\n+    public void testCSV57() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> list = parser.getRecords();\n+            assertNotNull(list);\n+            assertEquals(0, list.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testDefaultFormat() throws IOException {\n+        // @formatter:off\n+        final String code = \"\" + \"a,b#\\n\" + // 1)\n+            \"\\\"\\n\\\",\\\" \\\",#\\n\" +            // 2)\n+            \"#,\\\"\\\"\\n\" +                    // 3)\n+            \"# Final comment\\n\"             // 4)\n+        ;\n+        // @formatter:on\n+        final String[][] res = { { \"a\", \"b#\" }, { \"\\n\", \" \", \"#\" }, { \"#\", \"\" }, { \"# Final comment\" } };\n+        CSVFormat format = CSVFormat.DEFAULT;\n+        assertFalse(format.isCommentMarkerSet());\n+        final String[][] resComments = { { \"a\", \"b#\" }, { \"\\n\", \" \", \"#\" } };\n+        try (CSVParser parser = CSVParser.parse(code, format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertFalse(records.isEmpty());\n+            Utils.compare(\"Failed to parse without comments\", res, records);\n+            format = CSVFormat.DEFAULT.withCommentMarker('#');\n+        }\n+        try (CSVParser parser = CSVParser.parse(code, format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            Utils.compare(\"Failed to parse with comments\", resComments, records);\n+        }\n+    }\n+\n+    @Test\n+    public void testDuplicateHeadersAllowedByDefault() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"a,b,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader())) {\n+            // noop\n+        }\n+    }\n+\n+    @Test\n+    public void testDuplicateHeadersNotAllowed() {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> CSVParser.parse(\"a,b,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader().withAllowDuplicateHeaderNames(false)));\n+    }\n+\n+    @Test\n+    public void testEmptyFile() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(Paths.get(\"src/test/resources/org/apache/commons/csv/empty.txt\"), StandardCharsets.UTF_8,\n+                CSVFormat.DEFAULT)) {\n+            assertNull(parser.nextRecord());\n+        }\n+    }\n+\n+    @Test\n+    public void testEmptyFileHeaderParsing() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT.withFirstRecordAsHeader())) {\n+            assertNull(parser.nextRecord());\n+            assertTrue(parser.getHeaderNames().isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    public void testEmptyLineBehaviorCSV() throws Exception {\n+        final String[] codes = { \"hello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\n+        final String[][] res = { { \"hello\", \"\" } // CSV format ignores empty lines\n+        };\n+        for (final String code : codes) {\n+            try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n+                final List<CSVRecord> records = parser.getRecords();\n+                assertEquals(res.length, records.size());\n+                assertFalse(records.isEmpty());\n+                for (int i = 0; i < res.length; i++) {\n+                    assertArrayEquals(res[i], records.get(i).values());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testEmptyLineBehaviorExcel() throws Exception {\n+        final String[] codes = { \"hello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\n+        final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\n+                { \"\" } };\n+        for (final String code : codes) {\n+            try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\n+                final List<CSVRecord> records = parser.getRecords();\n+                assertEquals(res.length, records.size());\n+                assertFalse(records.isEmpty());\n+                for (int i = 0; i < res.length; i++) {\n+                    assertArrayEquals(res[i], records.get(i).values());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testEmptyString() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT)) {\n+            assertNull(parser.nextRecord());\n+        }\n+    }\n+\n+    @Test\n+    public void testEndOfFileBehaviorCSV() throws Exception {\n+        final String[] codes = { \"hello,\\r\\n\\r\\nworld,\\r\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\n+                \"hello,\\r\\n\\r\\nworld,\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\" };\n+        final String[][] res = { { \"hello\", \"\" }, // CSV format ignores empty lines\n+                { \"world\", \"\" } };\n+        for (final String code : codes) {\n+            try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n+                final List<CSVRecord> records = parser.getRecords();\n+                assertEquals(res.length, records.size());\n+                assertFalse(records.isEmpty());\n+                for (int i = 0; i < res.length; i++) {\n+                    assertArrayEquals(res[i], records.get(i).values());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testEndOfFileBehaviorExcel() throws Exception {\n+        final String[] codes = { \"hello,\\r\\n\\r\\nworld,\\r\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\n+                \"hello,\\r\\n\\r\\nworld,\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\" };\n+        final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\n+                { \"world\", \"\" } };\n+\n+        for (final String code : codes) {\n+            try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\n+                final List<CSVRecord> records = parser.getRecords();\n+                assertEquals(res.length, records.size());\n+                assertFalse(records.isEmpty());\n+                for (int i = 0; i < res.length; i++) {\n+                    assertArrayEquals(res[i], records.get(i).values());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelFormat1() throws IOException {\n+        final String code = \"value1,value2,value3,value4\\r\\na,b,c,d\\r\\n  x,,,\" + \"\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\",\\\"  \\\"\\\"world\\\"\\\"\\\",\\\"abc\\ndef\\\",\\r\\n\";\n+        final String[][] res = { { \"value1\", \"value2\", \"value3\", \"value4\" }, { \"a\", \"b\", \"c\", \"d\" }, { \"  x\", \"\", \"\", \"\" }, { \"\" },\n+                { \"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\" } };\n+        try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(res.length, records.size());\n+            assertFalse(records.isEmpty());\n+            for (int i = 0; i < res.length; i++) {\n+                assertArrayEquals(res[i], records.get(i).values());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelFormat2() throws Exception {\n+        final String code = \"foo,baar\\r\\n\\r\\nhello,\\r\\n\\r\\nworld,\\r\\n\";\n+        final String[][] res = { { \"foo\", \"baar\" }, { \"\" }, { \"hello\", \"\" }, { \"\" }, { \"world\", \"\" } };\n+        try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(res.length, records.size());\n+            assertFalse(records.isEmpty());\n+            for (int i = 0; i < res.length; i++) {\n+                assertArrayEquals(res[i], records.get(i).values());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests an exported Excel worksheet with a header row and rows that have more columns than the headers\n+     */\n+    @Test\n+    public void testExcelHeaderCountLessThanData() throws Exception {\n+        final String code = \"A,B,C,,\\r\\na,b,c,d,e\\r\\n\";\n+        try (CSVParser parser = CSVParser.parse(code, EXCEL_WITH_HEADER)) {\n+            parser.getRecords().forEach(record -> {\n+                assertEquals(\"a\", record.get(\"A\"));\n+                assertEquals(\"b\", record.get(\"B\"));\n+                assertEquals(\"c\", record.get(\"C\"));\n+            });\n+        }\n+    }\n+\n+    @Test\n+    public void testFirstEndOfLineCr() throws IOException {\n+        final String data = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n+        try (CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+            assertEquals(\"\\r\", parser.getFirstEndOfLine());\n+        }\n+    }\n+\n+    @Test\n+    public void testFirstEndOfLineCrLf() throws IOException {\n+        final String data = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n+        try (CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+            assertEquals(\"\\r\\n\", parser.getFirstEndOfLine());\n+        }\n+    }\n+\n+    @Test\n+    public void testFirstEndOfLineLf() throws IOException {\n+        final String data = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n+        try (CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+            assertEquals(\"\\n\", parser.getFirstEndOfLine());\n+        }\n+    }\n+\n+    @Test\n+    public void testForEach() throws Exception {\n+        try (Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+                CSVParser parser = CSVFormat.DEFAULT.parse(in)) {\n+            final List<CSVRecord> records = new ArrayList<>();\n+            for (final CSVRecord record : parser) {\n+                records.add(record);\n+            }\n+            assertEquals(3, records.size());\n+            assertArrayEquals(new String[] { \"a\", \"b\", \"c\" }, records.get(0).values());\n+            assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, records.get(1).values());\n+            assertArrayEquals(new String[] { \"x\", \"y\", \"z\" }, records.get(2).values());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderComment_HeaderComment1() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_AUTO_HEADER)) {\n+            parser.getRecords();\n+            // Expect a header comment\n+            assertTrue(parser.hasHeaderComment());\n+            assertEquals(\"header comment\", parser.getHeaderComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderComment_HeaderComment2() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER)) {\n+            parser.getRecords();\n+            // Expect a header comment\n+            assertTrue(parser.hasHeaderComment());\n+            assertEquals(\"header comment\", parser.getHeaderComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderComment_HeaderComment3() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\n+            parser.getRecords();\n+            // Expect no header comment - the text \"comment\" is attached to the first record\n+            assertFalse(parser.hasHeaderComment());\n+            assertNull(parser.getHeaderComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderComment_HeaderTrailerComment() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_MULTILINE_HEADER_TRAILER_COMMENT, FORMAT_AUTO_HEADER)) {\n+            parser.getRecords();\n+            // Expect a header comment\n+            assertTrue(parser.hasHeaderComment());\n+            assertEquals(\"multi-line\" + LF + \"header comment\", parser.getHeaderComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderComment_NoComment1() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_NO_COMMENT, FORMAT_AUTO_HEADER)) {\n+            parser.getRecords();\n+            // Expect no header comment\n+            assertFalse(parser.hasHeaderComment());\n+            assertNull(parser.getHeaderComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderComment_NoComment2() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_NO_COMMENT, FORMAT_EXPLICIT_HEADER)) {\n+            parser.getRecords();\n+            // Expect no header comment\n+            assertFalse(parser.hasHeaderComment());\n+            assertNull(parser.getHeaderComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderComment_NoComment3() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_NO_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\n+            parser.getRecords();\n+            // Expect no header comment\n+            assertFalse(parser.hasHeaderComment());\n+            assertNull(parser.getHeaderComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderMap() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\n+            final Map<String, Integer> headerMap = parser.getHeaderMap();\n+            final Iterator<String> columnNames = headerMap.keySet().iterator();\n+            // Headers are iterated in column order.\n+            assertEquals(\"A\", columnNames.next());\n+            assertEquals(\"B\", columnNames.next());\n+            assertEquals(\"C\", columnNames.next());\n+            final Iterator<CSVRecord> records = parser.iterator();\n+\n+            // Parse to make sure getHeaderMap did not have a side-effect.\n+            for (int i = 0; i < 3; i++) {\n+                assertTrue(records.hasNext());\n+                final CSVRecord record = records.next();\n+                assertEquals(record.get(0), record.get(\"A\"));\n+                assertEquals(record.get(1), record.get(\"B\"));\n+                assertEquals(record.get(2), record.get(\"C\"));\n+            }\n+\n+            assertFalse(records.hasNext());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderNames() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\n+            final Map<String, Integer> nameIndexMap = parser.getHeaderMap();\n+            final List<String> headerNames = parser.getHeaderNames();\n+            assertNotNull(headerNames);\n+            assertEquals(nameIndexMap.size(), headerNames.size());\n+            for (int i = 0; i < headerNames.size(); i++) {\n+                final String name = headerNames.get(i);\n+                assertEquals(i, nameIndexMap.get(name).intValue());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderNamesReadOnly() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\n+            final List<String> headerNames = parser.getHeaderNames();\n+            assertNotNull(headerNames);\n+            assertThrows(UnsupportedOperationException.class, () -> headerNames.add(\"This is a read-only list.\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testGetLine() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\n+            for (final String[] re : RESULT) {\n+                assertArrayEquals(re, parser.nextRecord().values());\n+            }\n+\n+            assertNull(parser.nextRecord());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetLineNumberWithCR() throws Exception {\n+        validateLineNumbers(String.valueOf(CR));\n+    }\n+\n+    @Test\n+    public void testGetLineNumberWithCRLF() throws Exception {\n+        validateLineNumbers(CRLF);\n+    }\n+\n+    @Test\n+    public void testGetLineNumberWithLF() throws Exception {\n+        validateLineNumbers(String.valueOf(LF));\n+    }\n+\n+    @Test\n+    public void testGetOneLine() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_1, CSVFormat.DEFAULT)) {\n+            final CSVRecord record = parser.getRecords().get(0);\n+            assertArrayEquals(RESULT[0], record.values());\n+        }\n+    }\n+\n+    /**\n+     * Tests reusing a parser to process new string records one at a time as they are being discovered. See [CSV-110].\n+     *\n+     * @throws IOException when an I/O error occurs.\n+     */\n+    @Test\n+    public void testGetOneLineOneParser() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT;\n+        try (PipedWriter writer = new PipedWriter();\n+                CSVParser parser = CSVParser.builder()\n+                        .setReader(new PipedReader(writer))\n+                        .setFormat(format)\n+                        .get()) {\n+            writer.append(CSV_INPUT_1);\n+            writer.append(format.getRecordSeparator());\n+            final CSVRecord record1 = parser.nextRecord();\n+            assertArrayEquals(RESULT[0], record1.values());\n+            writer.append(CSV_INPUT_2);\n+            writer.append(format.getRecordSeparator());\n+            final CSVRecord record2 = parser.nextRecord();\n+            assertArrayEquals(RESULT[1], record2.values());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetRecordFourBytesRead() throws Exception {\n+        final String code = \"id,a,b,c\\n\" +\n+            \"1,,,\\n\" +\n+            \"2,,,\\n\" +\n+            \"3,,,\\n\";\n+        final CSVFormat format = CSVFormat.Builder.create()\n+            .setDelimiter(',')\n+            .setQuote('\\'')\n+            .get();\n+        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setTrackBytes(true).get()) {\n+            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\n+\n+            assertEquals(0, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(1, record.getRecordNumber());\n+            assertEquals(code.indexOf('i'), record.getCharacterPosition());\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\n+\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(2, record.getRecordNumber());\n+            assertEquals(code.indexOf('1'), record.getCharacterPosition());\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(3, record.getRecordNumber());\n+            assertEquals(code.indexOf('2'), record.getCharacterPosition());\n+            assertEquals(record.getBytePosition(), 26);\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(4, record.getRecordNumber());\n+            assertEquals(code.indexOf('3'), record.getCharacterPosition());\n+            assertEquals(record.getBytePosition(), 43);\n+        }\n+    }\n+\n+    @Test\n+    public void testGetRecordNumberWithCR() throws Exception {\n+        validateRecordNumbers(String.valueOf(CR));\n+    }\n+\n+    @Test\n+    public void testGetRecordNumberWithCRLF() throws Exception {\n+        validateRecordNumbers(CRLF);\n+    }\n+\n+    @Test\n+    public void testGetRecordNumberWithLF() throws Exception {\n+        validateRecordNumbers(String.valueOf(LF));\n+    }\n+\n+    @Test\n+    public void testGetRecordPositionWithCRLF() throws Exception {\n+        validateRecordPosition(CRLF);\n+    }\n+\n+    @Test\n+    public void testGetRecordPositionWithLF() throws Exception {\n+        validateRecordPosition(String.valueOf(LF));\n+    }\n+\n+    @Test\n+    public void testGetRecords() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(RESULT.length, records.size());\n+            assertFalse(records.isEmpty());\n+            for (int i = 0; i < RESULT.length; i++) {\n+                assertArrayEquals(RESULT[i], records.get(i).values());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testGetRecordsFromBrokenInputStream() throws IOException {\n+        @SuppressWarnings(\"resource\") // We also get an exception on close, which is OK but can't assert in a try.\n+        final CSVParser parser = CSVParser.parse(new BrokenInputStream(), UTF_8, CSVFormat.DEFAULT);\n+        assertThrows(UncheckedIOException.class, parser::getRecords);\n+\n+    }\n+\n+    @Test\n+    public void testGetRecordThreeBytesRead() throws Exception {\n+        final String code = \"id,date,val5,val4\\n\" +\n+            \"11111111111111,'4017-09-01',,v4\\n\" +\n+            \"22222222222222,'4017-01-01',,v4\\n\" +\n+            \"33333333333333,'4017-01-01',,v4\\n\";\n+        final CSVFormat format = CSVFormat.Builder.create()\n+            .setDelimiter(',')\n+            .setQuote('\\'')\n+            .get();\n+        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setTrackBytes(true).get()) {\n+            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\n+\n+            assertEquals(0, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(1, record.getRecordNumber());\n+            assertEquals(code.indexOf('i'), record.getCharacterPosition());\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\n+\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(2, record.getRecordNumber());\n+            assertEquals(code.indexOf('1'), record.getCharacterPosition());\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\n+\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(3, record.getRecordNumber());\n+            assertEquals(code.indexOf('2'), record.getCharacterPosition());\n+            assertEquals(record.getBytePosition(), 95);\n+\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(4, record.getRecordNumber());\n+            assertEquals(code.indexOf('3'), record.getCharacterPosition());\n+            assertEquals(record.getBytePosition(), 154);\n+        }\n+    }\n+\n+    @Test\n+    public void testGetRecordWithMultiLineValues() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF + \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\",\n+                CSVFormat.DEFAULT.withRecordSeparator(CRLF))) {\n+            CSVRecord record;\n+            assertEquals(0, parser.getRecordNumber());\n+            assertEquals(0, parser.getCurrentLineNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(3, parser.getCurrentLineNumber());\n+            assertEquals(1, record.getRecordNumber());\n+            assertEquals(1, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(6, parser.getCurrentLineNumber());\n+            assertEquals(2, record.getRecordNumber());\n+            assertEquals(2, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(9, parser.getCurrentLineNumber());\n+            assertEquals(3, record.getRecordNumber());\n+            assertEquals(3, parser.getRecordNumber());\n+            assertNull(record = parser.nextRecord());\n+            assertEquals(9, parser.getCurrentLineNumber());\n+            assertEquals(3, parser.getRecordNumber());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetTrailerComment_HeaderComment1() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_AUTO_HEADER)) {\n+            parser.getRecords();\n+            assertFalse(parser.hasTrailerComment());\n+            assertNull(parser.getTrailerComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetTrailerComment_HeaderComment2() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER)) {\n+            parser.getRecords();\n+            assertFalse(parser.hasTrailerComment());\n+            assertNull(parser.getTrailerComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetTrailerComment_HeaderComment3() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\n+            parser.getRecords();\n+            assertFalse(parser.hasTrailerComment());\n+            assertNull(parser.getTrailerComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetTrailerComment_HeaderTrailerComment1() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_TRAILER_COMMENT, FORMAT_AUTO_HEADER)) {\n+            parser.getRecords();\n+            assertTrue(parser.hasTrailerComment());\n+            assertEquals(\"comment\", parser.getTrailerComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetTrailerComment_HeaderTrailerComment2() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_TRAILER_COMMENT, FORMAT_EXPLICIT_HEADER)) {\n+            parser.getRecords();\n+            assertTrue(parser.hasTrailerComment());\n+            assertEquals(\"comment\", parser.getTrailerComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetTrailerComment_HeaderTrailerComment3() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_HEADER_TRAILER_COMMENT, FORMAT_EXPLICIT_HEADER_NOSKIP)) {\n+            parser.getRecords();\n+            assertTrue(parser.hasTrailerComment());\n+            assertEquals(\"comment\", parser.getTrailerComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testGetTrailerComment_MultilineComment() throws IOException {\n+        try (CSVParser parser = CSVParser.parse(CSV_INPUT_MULTILINE_HEADER_TRAILER_COMMENT, FORMAT_AUTO_HEADER)) {\n+            parser.getRecords();\n+            assertTrue(parser.hasTrailerComment());\n+            assertEquals(\"multi-line\" + LF + \"comment\", parser.getTrailerComment());\n+        }\n+    }\n+\n+    @Test\n+    public void testHeader() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+\n+            for (int i = 0; i < 2; i++) {\n+                assertTrue(records.hasNext());\n+                final CSVRecord record = records.next();\n+                assertEquals(record.get(0), record.get(\"a\"));\n+                assertEquals(record.get(1), record.get(\"b\"));\n+                assertEquals(record.get(2), record.get(\"c\"));\n+            }\n+\n+            assertFalse(records.hasNext());\n+        }\n+    }\n+\n+    @Test\n+    public void testHeaderComment() throws Exception {\n+        final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withCommentMarker('#').withHeader().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            for (int i = 0; i < 2; i++) {\n+                assertTrue(records.hasNext());\n+                final CSVRecord record = records.next();\n+                assertEquals(record.get(0), record.get(\"a\"));\n+                assertEquals(record.get(1), record.get(\"b\"));\n+                assertEquals(record.get(2), record.get(\"c\"));\n+            }\n+            assertFalse(records.hasNext());\n+        }\n+    }\n+\n+    @Test\n+    public void testHeaderMissing() throws Exception {\n+        final Reader in = new StringReader(\"a,,c\\n1,2,3\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            for (int i = 0; i < 2; i++) {\n+                assertTrue(records.hasNext());\n+                final CSVRecord record = records.next();\n+                assertEquals(record.get(0), record.get(\"a\"));\n+                assertEquals(record.get(2), record.get(\"c\"));\n+            }\n+            assertFalse(records.hasNext());\n+        }\n+    }\n+\n+    @Test\n+    public void testHeaderMissingWithNull() throws Exception {\n+        final Reader in = new StringReader(\"a,,c,,e\\n1,2,3,4,5\\nv,w,x,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().withNullString(\"\").withAllowMissingColumnNames().parse(in)) {\n+            parser.iterator();\n+        }\n+    }\n+\n+    @Test\n+    public void testHeadersMissing() throws Exception {\n+        try (Reader in = new StringReader(\"a,,c,,e\\n1,2,3,4,5\\nv,w,x,y,z\");\n+                CSVParser parser = CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames().parse(in)) {\n+            parser.iterator();\n+        }\n+    }\n+\n+    @Test\n+    public void testHeadersMissingException() {\n+        final Reader in = new StringReader(\"a,,c,,e\\n1,2,3,4,5\\nv,w,x,y,z\");\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withHeader().parse(in).iterator());\n+    }\n+\n+    @Test\n+    public void testHeadersMissingOneColumnException() {\n+        final Reader in = new StringReader(\"a,,c,d,e\\n1,2,3,4,5\\nv,w,x,y,z\");\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withHeader().parse(in).iterator());\n+    }\n+\n+    @Test\n+    public void testHeadersWithNullColumnName() throws IOException {\n+        final Reader in = new StringReader(\"header1,null,header3\\n1,2,3\\n4,5,6\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().withNullString(\"null\").withAllowMissingColumnNames().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            // Expect the null header to be missing\n+            @SuppressWarnings(\"resource\")\n+            final CSVParser recordParser = record.getParser();\n+            assertEquals(Arrays.asList(\"header1\", \"header3\"), recordParser.getHeaderNames());\n+            assertEquals(2, recordParser.getHeaderMap().size());\n+        }\n+    }\n+\n+    @Test\n+    public void testIgnoreCaseHeaderMapping() throws Exception {\n+        final Reader reader = new StringReader(\"1,2,3\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"One\", \"TWO\", \"three\").withIgnoreHeaderCase().parse(reader)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            assertEquals(\"1\", record.get(\"one\"));\n+            assertEquals(\"2\", record.get(\"two\"));\n+            assertEquals(\"3\", record.get(\"THREE\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testIgnoreEmptyLines() throws IOException {\n+        final String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n+        // String code = \"world\\r\\n\\n\";\n+        // String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\n+        try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(3, records.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testInvalidFormat() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter(CR));\n+    }\n+\n+    @Test\n+    public void testIterator() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.parse(in)) {\n+            final Iterator<CSVRecord> iterator = parser.iterator();\n+            assertTrue(iterator.hasNext());\n+            assertThrows(UnsupportedOperationException.class, iterator::remove);\n+            assertArrayEquals(new String[] { \"a\", \"b\", \"c\" }, iterator.next().values());\n+            assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, iterator.next().values());\n+            assertTrue(iterator.hasNext());\n+            assertTrue(iterator.hasNext());\n+            assertTrue(iterator.hasNext());\n+            assertArrayEquals(new String[] { \"x\", \"y\", \"z\" }, iterator.next().values());\n+            assertFalse(iterator.hasNext());\n+            assertThrows(NoSuchElementException.class, iterator::next);\n+        }\n+    }\n+\n+    @Test\n+    public void testIteratorSequenceBreaking() throws IOException {\n+        final String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\n+        // Iterator hasNext() shouldn't break sequence\n+        try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows))) {\n+            final Iterator<CSVRecord> iter = parser.iterator();\n+            int recordNumber = 0;\n+            while (iter.hasNext()) {\n+                final CSVRecord record = iter.next();\n+                recordNumber++;\n+                assertEquals(String.valueOf(recordNumber), record.get(0));\n+                if (recordNumber >= 2) {\n+                    break;\n+                }\n+            }\n+            iter.hasNext();\n+            while (iter.hasNext()) {\n+                final CSVRecord record = iter.next();\n+                recordNumber++;\n+                assertEquals(String.valueOf(recordNumber), record.get(0));\n+            }\n+        }\n+        // Consecutive enhanced for loops shouldn't break sequence\n+        try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows))) {\n+            int recordNumber = 0;\n+            for (final CSVRecord record : parser) {\n+                recordNumber++;\n+                assertEquals(String.valueOf(recordNumber), record.get(0));\n+                if (recordNumber >= 2) {\n+                    break;\n+                }\n+            }\n+            for (final CSVRecord record : parser) {\n+                recordNumber++;\n+                assertEquals(String.valueOf(recordNumber), record.get(0));\n+            }\n+        }\n+        // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence\n+        try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows))) {\n+            int recordNumber = 0;\n+            for (final CSVRecord record : parser) {\n+                recordNumber++;\n+                assertEquals(String.valueOf(recordNumber), record.get(0));\n+                if (recordNumber >= 2) {\n+                    break;\n+                }\n+            }\n+            parser.iterator().hasNext();\n+            for (final CSVRecord record : parser) {\n+                recordNumber++;\n+                assertEquals(String.valueOf(recordNumber), record.get(0));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testLineFeedEndings() throws IOException {\n+        final String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n+        try (CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").withSkipHeaderRecord().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            CSVRecord record;\n+            // 1st record\n+            record = records.next();\n+            assertTrue(record.isMapped(\"A\"));\n+            assertTrue(record.isMapped(\"B\"));\n+            assertTrue(record.isMapped(\"C\"));\n+            assertTrue(record.isSet(\"A\"));\n+            assertTrue(record.isSet(\"B\"));\n+            assertFalse(record.isSet(\"C\"));\n+            assertEquals(\"1\", record.get(\"A\"));\n+            assertEquals(\"2\", record.get(\"B\"));\n+            assertFalse(record.isConsistent());\n+            // 2nd record\n+            record = records.next();\n+            assertTrue(record.isMapped(\"A\"));\n+            assertTrue(record.isMapped(\"B\"));\n+            assertTrue(record.isMapped(\"C\"));\n+            assertTrue(record.isSet(\"A\"));\n+            assertTrue(record.isSet(\"B\"));\n+            assertTrue(record.isSet(\"C\"));\n+            assertEquals(\"x\", record.get(\"A\"));\n+            assertEquals(\"y\", record.get(\"B\"));\n+            assertEquals(\"z\", record.get(\"C\"));\n+            assertTrue(record.isConsistent());\n+            // end\n+            assertFalse(records.hasNext());\n+        }\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testMongoDbCsv() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"\\\"a a\\\",b,c\" + LF + \"d,e,f\", CSVFormat.MONGODB_CSV)) {\n+            final Iterator<CSVRecord> itr1 = parser.iterator();\n+            final Iterator<CSVRecord> itr2 = parser.iterator();\n+\n+            final CSVRecord first = itr1.next();\n+            assertEquals(\"a a\", first.get(0));\n+            assertEquals(\"b\", first.get(1));\n+            assertEquals(\"c\", first.get(2));\n+\n+            final CSVRecord second = itr2.next();\n+            assertEquals(\"d\", second.get(0));\n+            assertEquals(\"e\", second.get(1));\n+            assertEquals(\"f\", second.get(2));\n+        }\n+    }\n+\n+    @Test\n+    // TODO this may lead to strange behavior, throw an exception if iterator() has already been called?\n+    public void testMultipleIterators() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"a,b,c\" + CRLF + \"d,e,f\", CSVFormat.DEFAULT)) {\n+            final Iterator<CSVRecord> itr1 = parser.iterator();\n+\n+            final CSVRecord first = itr1.next();\n+            assertEquals(\"a\", first.get(0));\n+            assertEquals(\"b\", first.get(1));\n+            assertEquals(\"c\", first.get(2));\n+\n+            final CSVRecord second = itr1.next();\n+            assertEquals(\"d\", second.get(0));\n+            assertEquals(\"e\", second.get(1));\n+            assertEquals(\"f\", second.get(2));\n+        }\n+    }\n+\n+    @Test\n+    public void testNewCSVParserNullReaderFormat() {\n+        assertThrows(NullPointerException.class, () -> new CSVParser(null, CSVFormat.DEFAULT));\n+    }\n+\n+    @Test\n+    public void testNewCSVParserReaderNullFormat() {\n+        assertThrows(NullPointerException.class, () -> new CSVParser(new StringReader(\"\"), null));\n+    }\n+\n+    @Test\n+    public void testNoHeaderMap() throws Exception {\n+        try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT)) {\n+            assertNull(parser.getHeaderMap());\n+        }\n+    }\n+\n+    @Test\n+    public void testNotValueCSV() throws IOException {\n+        final String source = \"#\";\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT.withCommentMarker('#');\n+        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\n+            final CSVRecord csvRecord = csvParser.nextRecord();\n+            assertNull(csvRecord);\n+        }\n+    }\n+\n+    @Test\n+    public void testParse() throws Exception {\n+        final ClassLoader loader = ClassLoader.getSystemClassLoader();\n+        final URL url = loader.getResource(\"org/apache/commons/csv/CSVFileParser/test.csv\");\n+        final CSVFormat format = CSVFormat.DEFAULT.builder().setHeader(\"A\", \"B\", \"C\", \"D\").get();\n+        final Charset charset = StandardCharsets.UTF_8;\n+        // Reader\n+        try (CSVParser parser = CSVParser.parse(new InputStreamReader(url.openStream(), charset), format)) {\n+            parseFully(parser);\n+        }\n+        try (CSVParser parser = CSVParser.builder().setReader(new InputStreamReader(url.openStream(), charset)).setFormat(format).get()) {\n+            parseFully(parser);\n+        }\n+        // String\n+        final Path path = Paths.get(url.toURI());\n+        final String string = new String(Files.readAllBytes(path), charset);\n+        try (CSVParser parser = CSVParser.parse(string, format)) {\n+            parseFully(parser);\n+        }\n+        try (CSVParser parser = CSVParser.builder().setCharSequence(string).setFormat(format).get()) {\n+            parseFully(parser);\n+        }\n+        // File\n+        final File file = new File(url.toURI());\n+        try (CSVParser parser = CSVParser.parse(file, charset, format)) {\n+            parseFully(parser);\n+        }\n+        try (CSVParser parser = CSVParser.builder().setFile(file).setCharset(charset).setFormat(format).get()) {\n+            parseFully(parser);\n+        }\n+        // InputStream\n+        try (CSVParser parser = CSVParser.parse(url.openStream(), charset, format)) {\n+            parseFully(parser);\n+        }\n+        try (CSVParser parser = CSVParser.builder().setInputStream(url.openStream()).setCharset(charset).setFormat(format).get()) {\n+            parseFully(parser);\n+        }\n+        // Path\n+        try (CSVParser parser = CSVParser.parse(path, charset, format)) {\n+            parseFully(parser);\n+        }\n+        try (CSVParser parser = CSVParser.builder().setPath(path).setCharset(charset).setFormat(format).get()) {\n+            parseFully(parser);\n+        }\n+        // URL\n+        try (CSVParser parser = CSVParser.parse(url, charset, format)) {\n+            parseFully(parser);\n+        }\n+        try (CSVParser parser = CSVParser.builder().setURI(url.toURI()).setCharset(charset).setFormat(format).get()) {\n+            parseFully(parser);\n+        }\n+        // InputStreamReader\n+        try (CSVParser parser = new CSVParser(new InputStreamReader(url.openStream(), charset), format)) {\n+            parseFully(parser);\n+        }\n+        try (CSVParser parser = CSVParser.builder().setReader(new InputStreamReader(url.openStream(), charset)).setFormat(format).get()) {\n+            parseFully(parser);\n+        }\n+        // InputStreamReader with longs\n+        try (CSVParser parser = new CSVParser(new InputStreamReader(url.openStream(), charset), format, /* characterOffset= */0, /* recordNumber= */1)) {\n+            parseFully(parser);\n+        }\n+        try (CSVParser parser = CSVParser.builder().setReader(new InputStreamReader(url.openStream(), charset)).setFormat(format).setCharacterOffset(0)\n+                .setRecordNumber(0).get()) {\n+            parseFully(parser);\n+        }\n+    }\n+\n+    @Test\n+    public void testParseFileNullFormat() {\n+        assertThrows(NullPointerException.class, () -> CSVParser.parse(new File(\"CSVFileParser/test.csv\"), Charset.defaultCharset(), null));\n+    }\n+\n+    @Test\n+    public void testParseNullFileFormat() {\n+        assertThrows(NullPointerException.class, () -> CSVParser.parse((File) null, Charset.defaultCharset(), CSVFormat.DEFAULT));\n+    }\n+\n+    @Test\n+    public void testParseNullPathFormat() {\n+        assertThrows(NullPointerException.class, () -> CSVParser.parse((Path) null, Charset.defaultCharset(), CSVFormat.DEFAULT));\n+    }\n+\n+    @Test\n+    public void testParseNullStringFormat() {\n+        assertThrows(NullPointerException.class, () -> CSVParser.parse((String) null, CSVFormat.DEFAULT));\n+    }\n+\n+    @Test\n+    public void testParseNullUrlCharsetFormat() {\n+        assertThrows(NullPointerException.class, () -> CSVParser.parse((URL) null, Charset.defaultCharset(), CSVFormat.DEFAULT));\n+    }\n+\n+    @Test\n+    public void testParserUrlNullCharsetFormat() {\n+        assertThrows(NullPointerException.class, () -> CSVParser.parse(new URL(\"https://commons.apache.org\"), null, CSVFormat.DEFAULT));\n+    }\n+\n+    @Test\n+    public void testParseStringNullFormat() {\n+        assertThrows(NullPointerException.class, () -> CSVParser.parse(\"csv data\", (CSVFormat) null));\n+    }\n+\n+    @Test\n+    public void testParseUrlCharsetNullFormat() {\n+        assertThrows(NullPointerException.class, () -> CSVParser.parse(new URL(\"https://commons.apache.org\"), Charset.defaultCharset(), null));\n+    }\n+\n+    @Test\n+    public void testParseWithDelimiterStringWithEscape() throws IOException {\n+        final String source = \"a![!|!]b![|]c[|]xyz\\r\\nabc[abc][|]xyz\";\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setEscape('!').get();\n+        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\n+            CSVRecord csvRecord = csvParser.nextRecord();\n+            assertEquals(\"a[|]b![|]c\", csvRecord.get(0));\n+            assertEquals(\"xyz\", csvRecord.get(1));\n+            csvRecord = csvParser.nextRecord();\n+            assertEquals(\"abc[abc]\", csvRecord.get(0));\n+            assertEquals(\"xyz\", csvRecord.get(1));\n+        }\n+    }\n+\n+    @Test\n+    public void testParseWithDelimiterStringWithQuote() throws IOException {\n+        final String source = \"'a[|]b[|]c'[|]xyz\\r\\nabc[abc][|]xyz\";\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setQuote('\\'').get();\n+        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\n+            CSVRecord csvRecord = csvParser.nextRecord();\n+            assertEquals(\"a[|]b[|]c\", csvRecord.get(0));\n+            assertEquals(\"xyz\", csvRecord.get(1));\n+            csvRecord = csvParser.nextRecord();\n+            assertEquals(\"abc[abc]\", csvRecord.get(0));\n+            assertEquals(\"xyz\", csvRecord.get(1));\n+        }\n+    }\n+\n+    @Test\n+    public void testParseWithDelimiterWithEscape() throws IOException {\n+        final String source = \"a!,b!,c,xyz\";\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT.withEscape('!');\n+        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\n+            final CSVRecord csvRecord = csvParser.nextRecord();\n+            assertEquals(\"a,b,c\", csvRecord.get(0));\n+            assertEquals(\"xyz\", csvRecord.get(1));\n+        }\n+    }\n+\n+    @Test\n+    public void testParseWithDelimiterWithQuote() throws IOException {\n+        final String source = \"'a,b,c',xyz\";\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT.withQuote('\\'');\n+        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\n+            final CSVRecord csvRecord = csvParser.nextRecord();\n+            assertEquals(\"a,b,c\", csvRecord.get(0));\n+            assertEquals(\"xyz\", csvRecord.get(1));\n+        }\n+    }\n+\n+    @Test\n+    public void testParseWithQuoteThrowsException() {\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT.withQuote('\\'');\n+        assertThrows(IOException.class, () -> csvFormat.parse(new StringReader(\"'a,b,c','\")).nextRecord());\n+        assertThrows(IOException.class, () -> csvFormat.parse(new StringReader(\"'a,b,c'abc,xyz\")).nextRecord());\n+        assertThrows(IOException.class, () -> csvFormat.parse(new StringReader(\"'abc'a,b,c',xyz\")).nextRecord());\n+    }\n+\n+    @Test\n+    public void testParseWithQuoteWithEscape() throws IOException {\n+        final String source = \"'a?,b?,c?d',xyz\";\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT.withQuote('\\'').withEscape('?');\n+        try (CSVParser csvParser = csvFormat.parse(new StringReader(source))) {\n+            final CSVRecord csvRecord = csvParser.nextRecord();\n+            assertEquals(\"a,b,c?d\", csvRecord.get(0));\n+            assertEquals(\"xyz\", csvRecord.get(1));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(CSVFormat.Predefined.class)\n+    public void testParsingPrintedEmptyFirstColumn(final CSVFormat.Predefined format) throws Exception {\n+        final String[][] lines = { { \"a\", \"b\" }, { \"\", \"x\" } };\n+        final StringWriter buf = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(buf, format.getFormat())) {\n+            printer.printRecords(Stream.of(lines));\n+        }\n+        try (CSVParser csvRecords = CSVParser.builder()\n+                .setReader(new StringReader(buf.toString()))\n+                .setFormat(format.getFormat())\n+                .get()) {\n+            for (final String[] line : lines) {\n+                assertArrayEquals(line, csvRecords.nextRecord().values());\n+            }\n+            assertNull(csvRecords.nextRecord());\n+        }\n+    }\n+\n+    @Test\n+    public void testProvidedHeader() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+\n+            for (int i = 0; i < 3; i++) {\n+                assertTrue(records.hasNext());\n+                final CSVRecord record = records.next();\n+                assertTrue(record.isMapped(\"A\"));\n+                assertTrue(record.isMapped(\"B\"));\n+                assertTrue(record.isMapped(\"C\"));\n+                assertFalse(record.isMapped(\"NOT MAPPED\"));\n+                assertEquals(record.get(0), record.get(\"A\"));\n+                assertEquals(record.get(1), record.get(\"B\"));\n+                assertEquals(record.get(2), record.get(\"C\"));\n+            }\n+\n+            assertFalse(records.hasNext());\n+        }\n+    }\n+\n+    @Test\n+    public void testProvidedHeaderAuto() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+\n+            for (int i = 0; i < 2; i++) {\n+                assertTrue(records.hasNext());\n+                final CSVRecord record = records.next();\n+                assertTrue(record.isMapped(\"a\"));\n+                assertTrue(record.isMapped(\"b\"));\n+                assertTrue(record.isMapped(\"c\"));\n+                assertFalse(record.isMapped(\"NOT MAPPED\"));\n+                assertEquals(record.get(0), record.get(\"a\"));\n+                assertEquals(record.get(1), record.get(\"b\"));\n+                assertEquals(record.get(2), record.get(\"c\"));\n+            }\n+\n+            assertFalse(records.hasNext());\n+        }\n+    }\n+\n+    @Test\n+    public void testRepeatedHeadersAreReturnedInCSVRecordHeaderNames() throws IOException {\n+        final Reader in = new StringReader(\"header1,header2,header1\\n1,2,3\\n4,5,6\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withFirstRecordAsHeader().withTrim().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            @SuppressWarnings(\"resource\")\n+            final CSVParser recordParser = record.getParser();\n+            assertEquals(Arrays.asList(\"header1\", \"header2\", \"header1\"), recordParser.getHeaderNames());\n+        }\n+    }\n+\n+    @Test\n+    public void testRoundtrip() throws Exception {\n+        final StringWriter out = new StringWriter();\n+        final String data = \"a,b,c\\r\\n1,2,3\\r\\nx,y,z\\r\\n\";\n+        try (CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT);\n+                CSVParser parse = CSVParser.parse(data, CSVFormat.DEFAULT)) {\n+            for (final CSVRecord record : parse) {\n+                printer.printRecord(record);\n+            }\n+            assertEquals(data, out.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testSkipAutoHeader() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            assertEquals(\"1\", record.get(\"a\"));\n+            assertEquals(\"2\", record.get(\"b\"));\n+            assertEquals(\"3\", record.get(\"c\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testSkipHeaderOverrideDuplicateHeaders() throws Exception {\n+        final Reader in = new StringReader(\"a,a,a\\n1,2,3\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            assertEquals(\"1\", record.get(\"X\"));\n+            assertEquals(\"2\", record.get(\"Y\"));\n+            assertEquals(\"3\", record.get(\"Z\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testSkipSetAltHeaders() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            assertEquals(\"1\", record.get(\"X\"));\n+            assertEquals(\"2\", record.get(\"Y\"));\n+            assertEquals(\"3\", record.get(\"Z\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testSkipSetHeader() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"a\", \"b\", \"c\").withSkipHeaderRecord().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            assertEquals(\"1\", record.get(\"a\"));\n+            assertEquals(\"2\", record.get(\"b\"));\n+            assertEquals(\"3\", record.get(\"c\"));\n+        }\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testStartWithEmptyLinesThenHeaders() throws Exception {\n+        final String[] codes = { \"\\r\\n\\r\\n\\r\\nhello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\n+        final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\n+                { \"\" } };\n+        for (final String code : codes) {\n+            try (CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\n+                final List<CSVRecord> records = parser.getRecords();\n+                assertEquals(res.length, records.size());\n+                assertFalse(records.isEmpty());\n+                for (int i = 0; i < res.length; i++) {\n+                    assertArrayEquals(res[i], records.get(i).values());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testStream() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.parse(in)) {\n+            final List<CSVRecord> list = parser.stream().collect(Collectors.toList());\n+            assertFalse(list.isEmpty());\n+            assertArrayEquals(new String[] { \"a\", \"b\", \"c\" }, list.get(0).values());\n+            assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, list.get(1).values());\n+            assertArrayEquals(new String[] { \"x\", \"y\", \"z\" }, list.get(2).values());\n+        }\n+    }\n+\n+    @Test\n+    public void testThrowExceptionWithLineAndPosition() throws IOException {\n+        final String csvContent = \"col1,col2,col3,col4,col5,col6,col7,col8,col9,col10\\nrec1,rec2,rec3,rec4,rec5,rec6,rec7,rec8,\\\"\\\"rec9\\\"\\\",rec10\";\n+        final StringReader stringReader = new StringReader(csvContent);\n+        // @formatter:off\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT.builder()\n+                .setHeader()\n+                .setSkipHeaderRecord(true)\n+                .get();\n+        // @formatter:on\n+        try (CSVParser csvParser = csvFormat.parse(stringReader)) {\n+            final UncheckedIOException exception = assertThrows(UncheckedIOException.class, csvParser::getRecords);\n+            assertInstanceOf(CSVException.class, exception.getCause());\n+            assertTrue(exception.getMessage().contains(\"Invalid character between encapsulated token and delimiter at line: 2, position: 94\"),\n+                    exception::getMessage);\n+        }\n+    }\n+\n+    @Test\n+    public void testTrailingDelimiter() throws Exception {\n+        final Reader in = new StringReader(\"a,a,a,\\n\\\"1\\\",\\\"2\\\",\\\"3\\\",\\nx,y,z,\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrailingDelimiter().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            assertEquals(\"1\", record.get(\"X\"));\n+            assertEquals(\"2\", record.get(\"Y\"));\n+            assertEquals(\"3\", record.get(\"Z\"));\n+            assertEquals(3, record.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testTrim() throws Exception {\n+        final Reader in = new StringReader(\"a,a,a\\n\\\" 1 \\\",\\\" 2 \\\",\\\" 3 \\\"\\nx,y,z\");\n+        try (CSVParser parser = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrim().parse(in)) {\n+            final Iterator<CSVRecord> records = parser.iterator();\n+            final CSVRecord record = records.next();\n+            assertEquals(\"1\", record.get(\"X\"));\n+            assertEquals(\"2\", record.get(\"Y\"));\n+            assertEquals(\"3\", record.get(\"Z\"));\n+            assertEquals(3, record.size());\n+        }\n+    }\n+\n+    private void validateLineNumbers(final String lineSeparator) throws IOException {\n+        try (CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator))) {\n+            assertEquals(0, parser.getCurrentLineNumber());\n+            assertNotNull(parser.nextRecord());\n+            assertEquals(1, parser.getCurrentLineNumber());\n+            assertNotNull(parser.nextRecord());\n+            assertEquals(2, parser.getCurrentLineNumber());\n+            assertNotNull(parser.nextRecord());\n+            // Read EOF without EOL should 3\n+            assertEquals(3, parser.getCurrentLineNumber());\n+            assertNull(parser.nextRecord());\n+            // Read EOF without EOL should 3\n+            assertEquals(3, parser.getCurrentLineNumber());\n+        }\n+    }\n+\n+    private void validateRecordNumbers(final String lineSeparator) throws IOException {\n+        try (CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator))) {\n+            CSVRecord record;\n+            assertEquals(0, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(1, record.getRecordNumber());\n+            assertEquals(1, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(2, record.getRecordNumber());\n+            assertEquals(2, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(3, record.getRecordNumber());\n+            assertEquals(3, parser.getRecordNumber());\n+            assertNull(record = parser.nextRecord());\n+            assertEquals(3, parser.getRecordNumber());\n+        }\n+    }\n+\n+    private void validateRecordPosition(final String lineSeparator) throws IOException {\n+        final String nl = lineSeparator; // used as linebreak in values for better distinction\n+        final String code = \"a,b,c\" + lineSeparator + \"1,2,3\" + lineSeparator +\n+                // to see if recordPosition correctly points to the enclosing quote\n+                \"'A\" + nl + \"A','B\" + nl + \"B',CC\" + lineSeparator +\n+                // unicode test... not very relevant while operating on strings instead of bytes, but for\n+                // completeness...\n+                \"\\u00c4,\\u00d6,\\u00dc\" + lineSeparator + \"EOF,EOF,EOF\";\n+        final CSVFormat format = CSVFormat.newFormat(',').withQuote('\\'').withRecordSeparator(lineSeparator);\n+        final long positionRecord3;\n+        try (CSVParser parser = CSVParser.parse(code, format)) {\n+            CSVRecord record;\n+            assertEquals(0, parser.getRecordNumber());\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(1, record.getRecordNumber());\n+            assertEquals(code.indexOf('a'), record.getCharacterPosition());\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(2, record.getRecordNumber());\n+            assertEquals(code.indexOf('1'), record.getCharacterPosition());\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            positionRecord3 = record.getCharacterPosition();\n+            assertEquals(3, record.getRecordNumber());\n+            assertEquals(code.indexOf(\"'A\"), record.getCharacterPosition());\n+            assertEquals(\"A\" + lineSeparator + \"A\", record.get(0));\n+            assertEquals(\"B\" + lineSeparator + \"B\", record.get(1));\n+            assertEquals(\"CC\", record.get(2));\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(4, record.getRecordNumber());\n+            assertEquals(code.indexOf('\\u00c4'), record.getCharacterPosition());\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(5, record.getRecordNumber());\n+            assertEquals(code.indexOf(\"EOF\"), record.getCharacterPosition());\n+        }\n+        // now try to read starting at record 3\n+        try (CSVParser parser = CSVParser.builder()\n+                .setReader(new StringReader(code.substring((int) positionRecord3)))\n+                .setFormat(format)\n+                .setCharacterOffset(positionRecord3)\n+                .setRecordNumber(3)\n+                .get()) {\n+            CSVRecord record;\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(3, record.getRecordNumber());\n+            assertEquals(code.indexOf(\"'A\"), record.getCharacterPosition());\n+            assertEquals(\"A\" + lineSeparator + \"A\", record.get(0));\n+            assertEquals(\"B\" + lineSeparator + \"B\", record.get(1));\n+            assertEquals(\"CC\", record.get(2));\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(4, record.getRecordNumber());\n+            assertEquals(code.indexOf('\\u00c4'), record.getCharacterPosition());\n+            assertEquals(\"\\u00c4\", record.get(0));\n+        } // again with ctor\n+        try (CSVParser parser = new CSVParser(new StringReader(code.substring((int) positionRecord3)), format, positionRecord3, 3)) {\n+            CSVRecord record;\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(3, record.getRecordNumber());\n+            assertEquals(code.indexOf(\"'A\"), record.getCharacterPosition());\n+            assertEquals(\"A\" + lineSeparator + \"A\", record.get(0));\n+            assertEquals(\"B\" + lineSeparator + \"B\", record.get(1));\n+            assertEquals(\"CC\", record.get(2));\n+            // nextRecord\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(4, record.getRecordNumber());\n+            assertEquals(code.indexOf('\\u00c4'), record.getCharacterPosition());\n+            assertEquals(\"\\u00c4\", record.get(0));\n+        }\n+    }\n+}\n\ndiff --git a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\nindex b4b560a1..f457460c 100644\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n@@ -1,1926 +1,1926 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv;\r\n-\r\n-import static org.apache.commons.csv.Constants.BACKSLASH;\r\n-import static org.apache.commons.csv.Constants.CR;\r\n-import static org.junit.jupiter.api.Assertions.assertArrayEquals;\r\n-import static org.junit.jupiter.api.Assertions.assertEquals;\r\n-import static org.junit.jupiter.api.Assertions.assertFalse;\r\n-import static org.junit.jupiter.api.Assertions.assertNotEquals;\r\n-import static org.junit.jupiter.api.Assertions.assertNull;\r\n-import static org.junit.jupiter.api.Assertions.assertThrows;\r\n-import static org.mockito.Mockito.mock;\r\n-import static org.mockito.Mockito.never;\r\n-import static org.mockito.Mockito.times;\r\n-import static org.mockito.Mockito.verify;\r\n-\r\n-import java.io.CharArrayWriter;\r\n-import java.io.File;\r\n-import java.io.FileReader;\r\n-import java.io.IOException;\r\n-import java.io.PrintStream;\r\n-import java.io.Reader;\r\n-import java.io.StringReader;\r\n-import java.io.StringWriter;\r\n-import java.io.Writer;\r\n-import java.nio.charset.Charset;\r\n-import java.nio.charset.StandardCharsets;\r\n-import java.nio.file.Files;\r\n-import java.nio.file.Path;\r\n-import java.sql.BatchUpdateException;\r\n-import java.sql.Connection;\r\n-import java.sql.DriverManager;\r\n-import java.sql.ResultSet;\r\n-import java.sql.SQLException;\r\n-import java.sql.Statement;\r\n-import java.util.Arrays;\r\n-import java.util.Date;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.Objects;\r\n-import java.util.Random;\r\n-import java.util.Vector;\r\n-import java.util.stream.Stream;\r\n-\r\n-import org.apache.commons.io.FileUtils;\r\n-import org.apache.commons.io.IOUtils;\r\n-import org.apache.commons.io.output.NullOutputStream;\r\n-import org.apache.commons.lang3.StringUtils;\r\n-import org.h2.tools.SimpleResultSet;\r\n-import org.junit.jupiter.api.Disabled;\r\n-import org.junit.jupiter.api.Test;\r\n-\r\n-/**\r\n- * Tests {@link CSVPrinter}.\r\n- */\r\n-public class CSVPrinterTest {\r\n-\r\n-    private static final int TABLE_RECORD_COUNT = 2;\r\n-    private static final char DQUOTE_CHAR = '\"';\r\n-    private static final char EURO_CH = '\\u20AC';\r\n-    private static final int ITERATIONS_FOR_RANDOM_TEST = 50000;\r\n-    private static final char QUOTE_CH = '\\'';\r\n-\r\n-    private static String printable(final String s) {\r\n-        final StringBuilder sb = new StringBuilder();\r\n-        for (int i = 0; i < s.length(); i++) {\r\n-            final char ch = s.charAt(i);\r\n-            if (ch <= ' ' || ch >= 128) {\r\n-                sb.append(\"(\").append((int) ch).append(\")\");\r\n-            } else {\r\n-                sb.append(ch);\r\n-            }\r\n-        }\r\n-        return sb.toString();\r\n-    }\r\n-\r\n-    private String longText2;\r\n-\r\n-    private final String recordSeparator = CSVFormat.DEFAULT.getRecordSeparator();\r\n-\r\n-    private void assertInitialState(final CSVPrinter printer) {\r\n-        assertEquals(0, printer.getRecordCount());\r\n-    }\r\n-\r\n-    private File createTempFile() throws IOException {\r\n-        return createTempPath().toFile();\r\n-    }\r\n-\r\n-    private Path createTempPath() throws IOException {\r\n-        return Files.createTempFile(getClass().getName(), \".csv\");\r\n-    }\r\n-\r\n-    private void doOneRandom(final CSVFormat format) throws Exception {\r\n-        final Random r = new Random();\r\n-\r\n-        final int nLines = r.nextInt(4) + 1;\r\n-        final int nCol = r.nextInt(3) + 1;\r\n-        // nLines=1;nCol=2;\r\n-        final String[][] lines = generateLines(nLines, nCol);\r\n-\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n-\r\n-            for (int i = 0; i < nLines; i++) {\r\n-                // for (int j=0; j<lines[i].length; j++) System.out.println(\"### VALUE=:\" + printable(lines[i][j]));\r\n-                printer.printRecord((Object[]) lines[i]);\r\n-            }\r\n-\r\n-            printer.flush();\r\n-        }\r\n-        final String result = sw.toString();\r\n-        // System.out.println(\"### :\" + printable(result));\r\n-\r\n-        try (CSVParser parser = CSVParser.parse(result, format)) {\r\n-            final List<CSVRecord> parseResult = parser.getRecords();\r\n-\r\n-            final String[][] expected = lines.clone();\r\n-            for (int i = 0; i < expected.length; i++) {\r\n-                expected[i] = expectNulls(expected[i], format);\r\n-            }\r\n-            Utils.compare(\"Printer output :\" + printable(result), expected, parseResult);\r\n-        }\r\n-    }\r\n-\r\n-    private void doRandom(final CSVFormat format, final int iter) throws Exception {\r\n-        for (int i = 0; i < iter; i++) {\r\n-            doOneRandom(format);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Converts an input CSV array into expected output values WRT NULLs. NULL strings are converted to null values because the parser will convert these\r\n-     * strings to null.\r\n-     */\r\n-    private <T> T[] expectNulls(final T[] original, final CSVFormat csvFormat) {\r\n-        final T[] fixed = original.clone();\r\n-        for (int i = 0; i < fixed.length; i++) {\r\n-            if (Objects.equals(csvFormat.getNullString(), fixed[i])) {\r\n-                fixed[i] = null;\r\n-            }\r\n-        }\r\n-        return fixed;\r\n-    }\r\n-\r\n-    private String[][] generateLines(final int nLines, final int nCol) {\r\n-        final String[][] lines = new String[nLines][];\r\n-        for (int i = 0; i < nLines; i++) {\r\n-            final String[] line = new String[nCol];\r\n-            lines[i] = line;\r\n-            for (int j = 0; j < nCol; j++) {\r\n-                line[j] = randStr();\r\n-            }\r\n-        }\r\n-        return lines;\r\n-    }\r\n-\r\n-    private Connection getH2Connection() throws SQLException, ClassNotFoundException {\r\n-        Class.forName(\"org.h2.Driver\");\r\n-        return DriverManager.getConnection(\"jdbc:h2:mem:my_test;\", \"sa\", \"\");\r\n-    }\r\n-\r\n-    private CSVPrinter printWithHeaderComments(final StringWriter sw, final Date now, final CSVFormat baseFormat) throws IOException {\r\n-        // Use withHeaderComments first to test CSV-145\r\n-        // @formatter:off\r\n-        final CSVFormat format = baseFormat.builder()\r\n-                .setHeaderComments((String[]) null) // don't blow up\r\n-                .setHeaderComments((Object[]) null) // don't blow up\r\n-                .setHeaderComments(\"Generated by Apache Commons CSV 1.1\", now)\r\n-                .setCommentMarker('#')\r\n-                .setHeader(\"Col1\", \"Col2\")\r\n-                .get();\r\n-        // @formatter:on\r\n-        final CSVPrinter printer = format.print(sw);\r\n-        printer.printRecord(\"A\", \"B\");\r\n-        printer.printRecord(\"C\", \"D\");\r\n-        printer.close();\r\n-        return printer;\r\n-    }\r\n-\r\n-    private String randStr() {\r\n-        final Random r = new Random();\r\n-        final int sz = r.nextInt(20);\r\n-        // sz = r.nextInt(3);\r\n-        final char[] buf = new char[sz];\r\n-        for (int i = 0; i < sz; i++) {\r\n-            // stick in special chars with greater frequency\r\n-            final char ch;\r\n-            final int what = r.nextInt(20);\r\n-            switch (what) {\r\n-            case 0:\r\n-                ch = '\\r';\r\n-                break;\r\n-            case 1:\r\n-                ch = '\\n';\r\n-                break;\r\n-            case 2:\r\n-                ch = '\\t';\r\n-                break;\r\n-            case 3:\r\n-                ch = '\\f';\r\n-                break;\r\n-            case 4:\r\n-                ch = ' ';\r\n-                break;\r\n-            case 5:\r\n-                ch = ',';\r\n-                break;\r\n-            case 6:\r\n-                ch = DQUOTE_CHAR;\r\n-                break;\r\n-            case 7:\r\n-                ch = '\\'';\r\n-                break;\r\n-            case 8:\r\n-                ch = BACKSLASH;\r\n-                break;\r\n-            default:\r\n-                ch = (char) r.nextInt(300);\r\n-                break;\r\n-            // default: ch = 'a'; break;\r\n-            }\r\n-            buf[i] = ch;\r\n-        }\r\n-        return new String(buf);\r\n-    }\r\n-\r\n-    private void setUpTable(final Connection connection) throws SQLException {\r\n-        try (Statement statement = connection.createStatement()) {\r\n-            statement.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255), TEXT CLOB, BIN_DATA BLOB)\");\r\n-            statement.execute(\"insert into TEST values(1, 'r1', 'long text 1', 'binary data 1')\");\r\n-            longText2 = StringUtils.repeat('a', IOUtils.DEFAULT_BUFFER_SIZE - 4);\r\n-            longText2 += \"\\\"\\r\\n\\\"b\\\"\";\r\n-            longText2 += StringUtils.repeat('c', IOUtils.DEFAULT_BUFFER_SIZE - 1);\r\n-            statement.execute(\"insert into TEST values(2, 'r2', '\" + longText2 + \"', 'binary data 2')\");\r\n-            longText2 = longText2.replace(\"\\\"\", \"\\\"\\\"\");\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCloseBackwardCompatibility() throws IOException {\r\n-        try (Writer writer = mock(Writer.class)) {\r\n-            final CSVFormat csvFormat = CSVFormat.DEFAULT;\r\n-            try (CSVPrinter printer = new CSVPrinter(writer, csvFormat)) {\r\n-                assertInitialState(printer);\r\n-            }\r\n-            verify(writer, never()).flush();\r\n-            verify(writer, times(1)).close();\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCloseWithCsvFormatAutoFlushOff() throws IOException {\r\n-        try (Writer writer = mock(Writer.class)) {\r\n-            final CSVFormat csvFormat = CSVFormat.DEFAULT.withAutoFlush(false);\r\n-            try (CSVPrinter printer = new CSVPrinter(writer, csvFormat)) {\r\n-                assertInitialState(printer);\r\n-            }\r\n-            verify(writer, never()).flush();\r\n-            verify(writer, times(1)).close();\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCloseWithCsvFormatAutoFlushOn() throws IOException {\r\n-        // System.out.println(\"start method\");\r\n-        try (Writer writer = mock(Writer.class)) {\r\n-            final CSVFormat csvFormat = CSVFormat.DEFAULT.withAutoFlush(true);\r\n-            try (CSVPrinter printer = new CSVPrinter(writer, csvFormat)) {\r\n-                assertInitialState(printer);\r\n-            }\r\n-            verify(writer, times(1)).flush();\r\n-            verify(writer, times(1)).close();\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCloseWithFlushOff() throws IOException {\r\n-        try (Writer writer = mock(Writer.class)) {\r\n-            final CSVFormat csvFormat = CSVFormat.DEFAULT;\r\n-            @SuppressWarnings(\"resource\")\r\n-            final CSVPrinter printer = new CSVPrinter(writer, csvFormat);\r\n-            assertInitialState(printer);\r\n-            printer.close(false);\r\n-            assertEquals(0, printer.getRecordCount());\r\n-            verify(writer, never()).flush();\r\n-            verify(writer, times(1)).close();\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCloseWithFlushOn() throws IOException {\r\n-        try (Writer writer = mock(Writer.class)) {\r\n-            @SuppressWarnings(\"resource\")\r\n-            final CSVPrinter printer = new CSVPrinter(writer, CSVFormat.DEFAULT);\r\n-            assertInitialState(printer);\r\n-            printer.close(true);\r\n-            assertEquals(0, printer.getRecordCount());\r\n-            verify(writer, times(1)).flush();\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCRComment() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        final Object value = \"abc\";\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(value);\r\n-            assertEquals(0, printer.getRecordCount());\r\n-            printer.printComment(\"This is a comment\\r\\non multiple lines\\rthis is next comment\\r\");\r\n-            assertEquals(\"abc\" + recordSeparator + \"# This is a comment\" + recordSeparator + \"# on multiple lines\" + recordSeparator +\r\n-                    \"# this is next comment\" + recordSeparator + \"# \" + recordSeparator, sw.toString());\r\n-            assertEquals(0, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV135() throws IOException {\r\n-        final List<String> list = new LinkedList<>();\r\n-        list.add(\"\\\"\\\"\"); // \"\"\r\n-        list.add(\"\\\\\\\\\"); // \\\\\r\n-        list.add(\"\\\\\\\"\\\\\"); // \\\"\\\r\n-        //\r\n-        // \"\",\\\\,\\\"\\ (unchanged)\r\n-        tryFormat(list, null, null, \"\\\"\\\",\\\\\\\\,\\\\\\\"\\\\\");\r\n-        //\r\n-        // \"\"\"\"\"\",\\\\,\"\\\"\"\\\" (quoted, and embedded DQ doubled)\r\n-        tryFormat(list, '\"', null, \"\\\"\\\"\\\"\\\"\\\"\\\",\\\\\\\\,\\\"\\\\\\\"\\\"\\\\\\\"\");\r\n-        //\r\n-        // \"\",\\\\\\\\,\\\\\"\\\\ (escapes escaped, not quoted)\r\n-        tryFormat(list, null, '\\\\', \"\\\"\\\",\\\\\\\\\\\\\\\\,\\\\\\\\\\\"\\\\\\\\\");\r\n-        //\r\n-        // \"\\\"\\\"\",\"\\\\\\\\\",\"\\\\\\\"\\\\\" (quoted, and embedded DQ & escape escaped)\r\n-        tryFormat(list, '\"', '\\\\', \"\\\"\\\\\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\\\\\\\\\",\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\"\");\r\n-        //\r\n-        // \"\"\"\"\"\",\\\\,\"\\\"\"\\\" (quoted, embedded DQ escaped)\r\n-        tryFormat(list, '\"', '\"', \"\\\"\\\"\\\"\\\"\\\"\\\",\\\\\\\\,\\\"\\\\\\\"\\\"\\\\\\\"\");\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testCSV259() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (Reader reader = new FileReader(\"src/test/resources/org/apache/commons/csv/CSV-259/sample.txt\");\r\n-                CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(reader);\r\n-            assertEquals(\"x!,y!,z\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimeterQuoted() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a,b,c\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"'a,b,c',xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimeterQuoteNone() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        final CSVFormat format = CSVFormat.DEFAULT.withEscape('!').withQuoteMode(QuoteMode.NONE);\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a,b,c\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"a!,b!,c,xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimeterStringQuoted() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setQuote('\\'').get())) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a[|]b[|]c\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"'a[|]b[|]c'[|]xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimeterStringQuoteNone() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        final CSVFormat format = CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setEscape('!').setQuoteMode(QuoteMode.NONE).get();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a[|]b[|]c\");\r\n-            printer.print(\"xyz\");\r\n-            printer.print(\"a[xy]bc[]\");\r\n-            assertEquals(\"a![!|!]b![!|!]c[|]xyz[|]a[xy]bc[]\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimiterEscaped() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a,b,c\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"a!,b!,c,xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimiterPlain() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a,b,c\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"a,b,c,xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDelimiterStringEscaped() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.builder().setDelimiter(\"|||\").setEscape('!').setQuote(null).get())) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a|||b|||c\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"a!|!|!|b!|!|!|c|||xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDisabledComment() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printComment(\"This is a comment\");\r\n-            assertEquals(\"\", sw.toString());\r\n-            assertEquals(0, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testDontQuoteEuroFirstChar() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(EURO_CH, \"Deux\");\r\n-            assertEquals(EURO_CH + \",Deux\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEolEscaped() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a\\rb\\nc\");\r\n-            printer.print(\"x\\fy\\bz\");\r\n-            assertEquals(\"a!rb!nc,x\\fy\\bz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEolPlain() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a\\rb\\nc\");\r\n-            printer.print(\"x\\fy\\bz\");\r\n-            assertEquals(\"a\\rb\\nc,x\\fy\\bz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEolQuoted() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"a\\rb\\nc\");\r\n-            printer.print(\"x\\by\\fz\");\r\n-            assertEquals(\"'a\\rb\\nc',x\\by\\fz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"unlikely-arg-type\")\r\n-    @Test\r\n-    public void testEquals() throws IOException {\r\n-        // Don't use assertNotEquals here\r\n-        assertFalse(CSVFormat.DEFAULT.equals(null));\r\n-        // Don't use assertNotEquals here\r\n-        assertFalse(CSVFormat.DEFAULT.equals(\"\"));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeBackslash1() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"\\\\\");\r\n-        }\r\n-        assertEquals(\"\\\\\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeBackslash2() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"\\\\\\r\");\r\n-        }\r\n-        assertEquals(\"'\\\\\\r'\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeBackslash3() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"X\\\\\\r\");\r\n-        }\r\n-        assertEquals(\"'X\\\\\\r'\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeBackslash4() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"\\\\\\\\\");\r\n-        }\r\n-        assertEquals(\"\\\\\\\\\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeBackslash5() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"\\\\\\\\\");\r\n-        }\r\n-        assertEquals(\"\\\\\\\\\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeNull1() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"\\\\\");\r\n-        }\r\n-        assertEquals(\"\\\\\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeNull2() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"\\\\\\r\");\r\n-        }\r\n-        assertEquals(\"\\\"\\\\\\r\\\"\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeNull3() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"X\\\\\\r\");\r\n-        }\r\n-        assertEquals(\"\\\"X\\\\\\r\\\"\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeNull4() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"\\\\\\\\\");\r\n-        }\r\n-        assertEquals(\"\\\\\\\\\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testEscapeNull5() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(\"\\\\\\\\\");\r\n-        }\r\n-        assertEquals(\"\\\\\\\\\", sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllArrayOfArrays() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords((Object[]) new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } });\r\n-            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllArrayOfArraysWithFirstEmptyValue2() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords((Object[]) new String[][] { { \"\" } });\r\n-            assertEquals(\"\\\"\\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllArrayOfArraysWithFirstSpaceValue1() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords((Object[]) new String[][] { { \" \", \"r1c2\" } });\r\n-            assertEquals(\"\\\" \\\",r1c2\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllArrayOfArraysWithFirstTabValue1() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords((Object[]) new String[][] { { \"\\t\", \"r1c2\" } });\r\n-            assertEquals(\"\\\"\\t\\\",r1c2\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllArrayOfLists() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords((Object[]) new List[] { Arrays.asList(\"r1c1\", \"r1c2\"), Arrays.asList(\"r2c1\", \"r2c2\") });\r\n-            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllArrayOfListsWithFirstEmptyValue2() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords((Object[]) new List[] { Arrays.asList(\"\") });\r\n-            assertEquals(\"\\\"\\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllIterableOfArrays() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords(Arrays.asList(new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } }));\r\n-            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllIterableOfArraysWithFirstEmptyValue2() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords(Arrays.asList(new String[][] { { \"\" } }));\r\n-            assertEquals(\"\\\"\\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllIterableOfLists() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords(Arrays.asList(Arrays.asList(\"r1c1\", \"r1c2\"), Arrays.asList(\"r2c1\", \"r2c2\")));\r\n-            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrintAllStreamOfArrays() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords(Stream.of(new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } }));\r\n-            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrinter1() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", \"b\");\r\n-            assertEquals(\"a,b\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testExcelPrinter2() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a,b\", \"b\");\r\n-            assertEquals(\"\\\"a,b\\\",b\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeader() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\"))) {\r\n-            assertEquals(1, printer.getRecordCount());\r\n-            printer.printRecord(\"a\", \"b\", \"c\");\r\n-            printer.printRecord(\"x\", \"y\", \"z\");\r\n-            assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeaderCommentExcel() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        final Date now = new Date();\r\n-        final CSVFormat format = CSVFormat.EXCEL;\r\n-        try (CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format)) {\r\n-            assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1,Col2\\r\\nA,B\\r\\nC,D\\r\\n\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeaderCommentTdf() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        final Date now = new Date();\r\n-        final CSVFormat format = CSVFormat.TDF;\r\n-        try (CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format)) {\r\n-            assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1\\tCol2\\r\\nA\\tB\\r\\nC\\tD\\r\\n\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testHeaderNotSet() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", \"b\", \"c\");\r\n-            printer.printRecord(\"x\", \"y\", \"z\");\r\n-            assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testInvalidFormat() {\r\n-        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter(CR));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testJdbcPrinter() throws IOException, ClassNotFoundException, SQLException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        final CSVFormat csvFormat = CSVFormat.DEFAULT;\r\n-        try (Connection connection = getH2Connection()) {\r\n-            setUpTable(connection);\r\n-            try (Statement stmt = connection.createStatement();\r\n-                    CSVPrinter printer = new CSVPrinter(sw, csvFormat);\r\n-                    ResultSet resultSet = stmt.executeQuery(\"select ID, NAME, TEXT, BIN_DATA from TEST\")) {\r\n-                assertInitialState(printer);\r\n-                printer.printRecords(resultSet);\r\n-                assertEquals(TABLE_RECORD_COUNT, printer.getRecordCount());\r\n-            }\r\n-        }\r\n-        final String csv = sw.toString();\r\n-        assertEquals(\"1,r1,\\\"long text 1\\\",\\\"YmluYXJ5IGRhdGEgMQ==\\r\\n\\\"\" + recordSeparator + \"2,r2,\\\"\" + longText2 + \"\\\",\\\"YmluYXJ5IGRhdGEgMg==\\r\\n\\\"\" +\r\n-                recordSeparator, csv);\r\n-        // Round trip the data\r\n-        try (StringReader reader = new StringReader(csv);\r\n-                CSVParser csvParser = csvFormat.parse(reader)) {\r\n-            // Row 1\r\n-            CSVRecord record = csvParser.nextRecord();\r\n-            assertEquals(\"1\", record.get(0));\r\n-            assertEquals(\"r1\", record.get(1));\r\n-            assertEquals(\"long text 1\", record.get(2));\r\n-            assertEquals(\"YmluYXJ5IGRhdGEgMQ==\\r\\n\", record.get(3));\r\n-            // Row 2\r\n-            record = csvParser.nextRecord();\r\n-            assertEquals(\"2\", record.get(0));\r\n-            assertEquals(\"r2\", record.get(1));\r\n-            assertEquals(\"YmluYXJ5IGRhdGEgMg==\\r\\n\", record.get(3));\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testJdbcPrinterWithFirstEmptyValue2() throws IOException, ClassNotFoundException, SQLException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (Connection connection = getH2Connection()) {\r\n-            try (Statement stmt = connection.createStatement();\r\n-                    ResultSet resultSet = stmt.executeQuery(\"select '' AS EMPTYVALUE from DUAL\");\r\n-                    CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet).print(sw)) {\r\n-                printer.printRecords(resultSet);\r\n-            }\r\n-        }\r\n-        assertEquals(\"EMPTYVALUE\" + recordSeparator + \"\\\"\\\"\" + recordSeparator, sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testJdbcPrinterWithResultSet() throws IOException, ClassNotFoundException, SQLException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (Connection connection = getH2Connection()) {\r\n-            setUpTable(connection);\r\n-            try (Statement stmt = connection.createStatement();\r\n-                    ResultSet resultSet = stmt.executeQuery(\"select ID, NAME, TEXT from TEST\");\r\n-                    CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet).print(sw)) {\r\n-                printer.printRecords(resultSet);\r\n-            }\r\n-        }\r\n-        assertEquals(\"ID,NAME,TEXT\" + recordSeparator + \"1,r1,\\\"long text 1\\\"\" + recordSeparator + \"2,r2,\\\"\" + longText2 + \"\\\"\" + recordSeparator,\r\n-                sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testJdbcPrinterWithResultSetHeader() throws IOException, ClassNotFoundException, SQLException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (Connection connection = getH2Connection()) {\r\n-            setUpTable(connection);\r\n-            try (Statement stmt = connection.createStatement();\r\n-                    CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-                try (ResultSet resultSet = stmt.executeQuery(\"select ID, NAME from TEST\")) {\r\n-                    printer.printRecords(resultSet, true);\r\n-                    assertEquals(TABLE_RECORD_COUNT, printer.getRecordCount());\r\n-                    assertEquals(\"ID,NAME\" + recordSeparator + \"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator, sw.toString());\r\n-                }\r\n-                try (ResultSet resultSet = stmt.executeQuery(\"select ID, NAME from TEST\")) {\r\n-                    printer.printRecords(resultSet, false);\r\n-                    assertEquals(TABLE_RECORD_COUNT * 2, printer.getRecordCount());\r\n-                    assertNotEquals(\"ID,NAME\" + recordSeparator + \"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator, sw.toString());\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testJdbcPrinterWithResultSetMetaData() throws IOException, ClassNotFoundException, SQLException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (Connection connection = getH2Connection()) {\r\n-            setUpTable(connection);\r\n-            try (Statement stmt = connection.createStatement();\r\n-                    ResultSet resultSet = stmt.executeQuery(\"select ID, NAME, TEXT from TEST\");\r\n-                    CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet.getMetaData()).print(sw)) {\r\n-                // The header is the first record.\r\n-                assertEquals(1, printer.getRecordCount());\r\n-                printer.printRecords(resultSet);\r\n-                assertEquals(3, printer.getRecordCount());\r\n-                assertEquals(\"ID,NAME,TEXT\" + recordSeparator + \"1,r1,\\\"long text 1\\\"\" + recordSeparator + \"2,r2,\\\"\" + longText2 + \"\\\"\" + recordSeparator,\r\n-                        sw.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testJira135_part1() throws IOException {\r\n-        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\r\n-        final StringWriter sw = new StringWriter();\r\n-        final List<String> list = new LinkedList<>();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n-            list.add(\"\\\"\");\r\n-            printer.printRecord(list);\r\n-        }\r\n-        final String expected = \"\\\"\\\\\\\"\\\"\" + format.getRecordSeparator();\r\n-        assertEquals(expected, sw.toString());\r\n-        final String[] record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(list.toArray(), format), record0);\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testJira135_part2() throws IOException {\r\n-        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\r\n-        final StringWriter sw = new StringWriter();\r\n-        final List<String> list = new LinkedList<>();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n-            list.add(\"\\n\");\r\n-            printer.printRecord(list);\r\n-        }\r\n-        final String expected = \"\\\"\\\\n\\\"\" + format.getRecordSeparator();\r\n-        assertEquals(expected, sw.toString());\r\n-        final String[] record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(list.toArray(), format), record0);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testJira135_part3() throws IOException {\r\n-        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\r\n-        final StringWriter sw = new StringWriter();\r\n-        final List<String> list = new LinkedList<>();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n-            list.add(\"\\\\\");\r\n-            printer.printRecord(list);\r\n-        }\r\n-        final String expected = \"\\\"\\\\\\\\\\\"\" + format.getRecordSeparator();\r\n-        assertEquals(expected, sw.toString());\r\n-        final String[] record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(list.toArray(), format), record0);\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testJira135All() throws IOException {\r\n-        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\r\n-        final StringWriter sw = new StringWriter();\r\n-        final List<String> list = new LinkedList<>();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n-            list.add(\"\\\"\");\r\n-            list.add(\"\\n\");\r\n-            list.add(\"\\\\\");\r\n-            printer.printRecord(list);\r\n-        }\r\n-        final String expected = \"\\\"\\\\\\\"\\\",\\\"\\\\n\\\",\\\"\\\\\\\"\" + format.getRecordSeparator();\r\n-        assertEquals(expected, sw.toString());\r\n-        final String[] record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(list.toArray(), format), record0);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMongoDbCsvBasic() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\r\n-            printer.printRecord(\"a\", \"b\");\r\n-            assertEquals(\"a,b\" + recordSeparator, sw.toString());\r\n-            assertEquals(1, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMongoDbCsvCommaInValue() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\r\n-            printer.printRecord(\"a,b\", \"c\");\r\n-            assertEquals(\"\\\"a,b\\\",c\" + recordSeparator, sw.toString());\r\n-            assertEquals(1, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMongoDbCsvDoubleQuoteInValue() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\r\n-            printer.printRecord(\"a \\\"c\\\" b\", \"d\");\r\n-            assertEquals(\"\\\"a \\\"\\\"c\\\"\\\" b\\\",d\" + recordSeparator, sw.toString());\r\n-            assertEquals(1, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMongoDbCsvTabInValue() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\r\n-            printer.printRecord(\"a\\tb\", \"c\");\r\n-            assertEquals(\"a\\tb,c\" + recordSeparator, sw.toString());\r\n-            assertEquals(1, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMongoDbTsvBasic() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_TSV)) {\r\n-            printer.printRecord(\"a\", \"b\");\r\n-            assertEquals(\"a\\tb\" + recordSeparator, sw.toString());\r\n-            assertEquals(1, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMongoDbTsvCommaInValue() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_TSV)) {\r\n-            printer.printRecord(\"a,b\", \"c\");\r\n-            assertEquals(\"a,b\\tc\" + recordSeparator, sw.toString());\r\n-            assertEquals(1, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMongoDbTsvTabInValue() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_TSV)) {\r\n-            printer.printRecord(\"a\\tb\", \"c\");\r\n-            assertEquals(\"\\\"a\\tb\\\"\\tc\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMultiLineComment() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'))) {\r\n-            printer.printComment(\"This is a comment\\non multiple lines\");\r\n-            assertEquals(\"# This is a comment\" + recordSeparator + \"# on multiple lines\" + recordSeparator, sw.toString());\r\n-            assertEquals(0, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMySqlNullOutput() throws IOException {\r\n-        Object[] s = new String[] { \"NULL\", null };\r\n-        CSVFormat format = CSVFormat.MYSQL.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.NON_NUMERIC);\r\n-        StringWriter writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        String expected = \"\\\"NULL\\\"\\tNULL\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        String[] record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(s, record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", null };\r\n-        format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\t\\\\N\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", \"A\" };\r\n-        format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\tA\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\n\", \"A\" };\r\n-        format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\n\\tA\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\", null };\r\n-        format = CSVFormat.MYSQL.withNullString(\"NULL\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\tNULL\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\", null };\r\n-        format = CSVFormat.MYSQL;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\t\\\\N\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\r\n-        format = CSVFormat.MYSQL;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"NULL\", \"\\\\\\r\" };\r\n-        format = CSVFormat.MYSQL;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\\\r\" };\r\n-        format = CSVFormat.MYSQL;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testMySqlNullStringDefault() {\r\n-        assertEquals(\"\\\\N\", CSVFormat.MYSQL.getNullString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNewCsvPrinterAppendableNullFormat() {\r\n-        assertThrows(NullPointerException.class, () -> new CSVPrinter(new StringWriter(), null));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNewCsvPrinterNullAppendableFormat() {\r\n-        assertThrows(NullPointerException.class, () -> new CSVPrinter(null, CSVFormat.DEFAULT));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testNotFlushable() throws IOException {\r\n-        final Appendable out = new StringBuilder();\r\n-        try (CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT)) {\r\n-            printer.printRecord(\"a\", \"b\", \"c\");\r\n-            assertEquals(\"a,b,c\" + recordSeparator, out.toString());\r\n-            printer.flush();\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testParseCustomNullValues() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        final CSVFormat format = CSVFormat.DEFAULT.withNullString(\"NULL\");\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n-            printer.printRecord(\"a\", null, \"b\");\r\n-        }\r\n-        final String csvString = sw.toString();\r\n-        assertEquals(\"a,NULL,b\" + recordSeparator, csvString);\r\n-        try (CSVParser iterable = format.parse(new StringReader(csvString))) {\r\n-            final Iterator<CSVRecord> iterator = iterable.iterator();\r\n-            final CSVRecord record = iterator.next();\r\n-            assertEquals(\"a\", record.get(0));\r\n-            assertNull(record.get(1));\r\n-            assertEquals(\"b\", record.get(2));\r\n-            assertFalse(iterator.hasNext());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPlainEscaped() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'))) {\r\n-            printer.print(\"abc\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"abc,xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPlainPlain() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\r\n-            printer.print(\"abc\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"abc,xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPlainQuoted() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\r\n-            printer.print(\"abc\");\r\n-            assertEquals(\"abc\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testPostgreSqlCsvNullOutput() throws IOException {\r\n-        Object[] s = new String[] { \"NULL\", null };\r\n-        CSVFormat format = CSVFormat.POSTGRESQL_CSV.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.ALL_NON_NULL);\r\n-        StringWriter writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        String expected = \"\\\"NULL\\\",NULL\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        String[] record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(new Object[2], record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", null };\r\n-        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\t\\\\N\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", \"A\" };\r\n-        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\tA\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\n\", \"A\" };\r\n-        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\n\\tA\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\", null };\r\n-        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"NULL\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\tNULL\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\", null };\r\n-        format = CSVFormat.POSTGRESQL_CSV;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\t\\\\N\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\r\n-        format = CSVFormat.POSTGRESQL_CSV;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"NULL\", \"\\\\\\r\" };\r\n-        format = CSVFormat.POSTGRESQL_CSV;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\\\r\" };\r\n-        format = CSVFormat.POSTGRESQL_CSV;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testPostgreSqlCsvTextOutput() throws IOException {\r\n-        Object[] s = new String[] { \"NULL\", null };\r\n-        CSVFormat format = CSVFormat.POSTGRESQL_TEXT.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.ALL_NON_NULL);\r\n-        StringWriter writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        String expected = \"\\\"NULL\\\"\\tNULL\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        String[] record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(new Object[2], record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", null };\r\n-        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\t\\\\N\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", \"A\" };\r\n-        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\tA\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\n\", \"A\" };\r\n-        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\n\\tA\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\", null };\r\n-        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"NULL\");\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\tNULL\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\", null };\r\n-        format = CSVFormat.POSTGRESQL_TEXT;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\t\\\\N\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\r\n-        format = CSVFormat.POSTGRESQL_TEXT;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"NULL\", \"\\\\\\r\" };\r\n-        format = CSVFormat.POSTGRESQL_TEXT;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-\r\n-        s = new String[] { \"\\\\\\r\" };\r\n-        format = CSVFormat.POSTGRESQL_TEXT;\r\n-        writer = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\r\n-            printer.printRecord(s);\r\n-        }\r\n-        expected = \"\\\\\\\\\\\\r\\n\";\r\n-        assertEquals(expected, writer.toString());\r\n-        record0 = toFirstRecordValues(expected, format);\r\n-        assertArrayEquals(expectNulls(s, format), record0);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPostgreSqlNullStringDefaultCsv() {\r\n-        assertEquals(\"\", CSVFormat.POSTGRESQL_CSV.getNullString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPostgreSqlNullStringDefaultText() {\r\n-        assertEquals(\"\\\\N\", CSVFormat.POSTGRESQL_TEXT.getNullString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrint() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = CSVFormat.DEFAULT.print(sw)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", \"b\\\\c\");\r\n-            assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintCSVParser() throws IOException {\r\n-        // @formatter:off\r\n-        final String code = \"a1,b1\\n\" + // 1)\r\n-                \"a2,b2\\n\" + // 2)\r\n-                \"a3,b3\\n\" + // 3)\r\n-                \"a4,b4\\n\";  // 4)\r\n-        // @formatter:on\r\n-        final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\r\n-        final CSVFormat format = CSVFormat.DEFAULT;\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = format.print(sw);\r\n-                CSVParser parser = CSVParser.parse(code, format)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords(parser);\r\n-        }\r\n-        try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertFalse(records.isEmpty());\r\n-            Utils.compare(\"Fail\", res, records);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintCSVRecord() throws IOException {\r\n-        // @formatter:off\r\n-        final String code = \"a1,b1\\n\" + // 1)\r\n-                \"a2,b2\\n\" +  // 2)\r\n-                \"a3,b3\\n\" +  // 3)\r\n-                \"a4,b4\\n\";   // 4)\r\n-        // @formatter:on\r\n-        final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\r\n-        final CSVFormat format = CSVFormat.DEFAULT;\r\n-        final StringWriter sw = new StringWriter();\r\n-        int row = 0;\r\n-        try (CSVPrinter printer = format.print(sw);\r\n-                CSVParser parser = CSVParser.parse(code, format)) {\r\n-            assertInitialState(printer);\r\n-            for (final CSVRecord record : parser) {\r\n-                printer.printRecord(record);\r\n-                assertEquals(++row, printer.getRecordCount());\r\n-            }\r\n-            assertEquals(row, printer.getRecordCount());\r\n-        }\r\n-        try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertFalse(records.isEmpty());\r\n-            Utils.compare(\"Fail\", res, records);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintCSVRecords() throws IOException {\r\n-        // @formatter:off\r\n-        final String code = \"a1,b1\\n\" + // 1)\r\n-                \"a2,b2\\n\" + // 2)\r\n-                \"a3,b3\\n\" + // 3)\r\n-                \"a4,b4\\n\";  // 4)\r\n-        // @formatter:on\r\n-        final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\r\n-        final CSVFormat format = CSVFormat.DEFAULT;\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = format.print(sw);\r\n-                CSVParser parser = CSVParser.parse(code, format)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecords(parser.getRecords());\r\n-        }\r\n-        try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertFalse(records.isEmpty());\r\n-            Utils.compare(\"Fail\", res, records);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintCustomNullValues() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withNullString(\"NULL\"))) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", null, \"b\");\r\n-            assertEquals(\"a,NULL,b\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrinter1() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", \"b\");\r\n-            assertEquals(1, printer.getRecordCount());\r\n-            assertEquals(\"a,b\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrinter2() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a,b\", \"b\");\r\n-            assertEquals(\"\\\"a,b\\\",b\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrinter3() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a, b\", \"b \");\r\n-            assertEquals(\"\\\"a, b\\\",\\\"b \\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrinter4() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", \"b\\\"c\");\r\n-            assertEquals(\"a,\\\"b\\\"\\\"c\\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrinter5() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", \"b\\nc\");\r\n-            assertEquals(\"a,\\\"b\\nc\\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrinter6() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", \"b\\r\\nc\");\r\n-            assertEquals(\"a,\\\"b\\r\\nc\\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrinter7() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", \"b\\\\c\");\r\n-            assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintNullValues() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\r\n-            assertInitialState(printer);\r\n-            printer.printRecord(\"a\", null, \"b\");\r\n-            assertEquals(\"a,,b\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintOnePositiveInteger() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.MINIMAL))) {\r\n-            assertInitialState(printer);\r\n-            printer.print(Integer.MAX_VALUE);\r\n-            assertEquals(String.valueOf(Integer.MAX_VALUE), sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Test to target the use of {@link IOUtils#copy(java.io.Reader, Appendable)} which directly buffers the value from the Reader to the Appendable.\r\n-     *\r\n-     * <p>\r\n-     * Requires the format to have no quote or escape character, value to be a {@link Reader Reader} and the output <em>MUST NOT</em> be a {@link Writer Writer}\r\n-     * but some other Appendable.\r\n-     * </p>\r\n-     *\r\n-     * @throws IOException Not expected to happen\r\n-     */\r\n-    @Test\r\n-    public void testPrintReaderWithoutQuoteToAppendable() throws IOException {\r\n-        final StringBuilder sb = new StringBuilder();\r\n-        final String content = \"testValue\";\r\n-        try (CSVPrinter printer = new CSVPrinter(sb, CSVFormat.DEFAULT.withQuote(null))) {\r\n-            assertInitialState(printer);\r\n-            final StringReader value = new StringReader(content);\r\n-            printer.print(value);\r\n-        }\r\n-        assertEquals(content, sb.toString());\r\n-    }\r\n-\r\n-    /**\r\n-     * Test to target the use of {@link IOUtils#copyLarge(java.io.Reader, Writer)} which directly buffers the value from the Reader to the Writer.\r\n-     *\r\n-     * <p>\r\n-     * Requires the format to have no quote or escape character, value to be a {@link Reader Reader} and the output <em>MUST</em> be a {@link Writer Writer}.\r\n-     * </p>\r\n-     *\r\n-     * @throws IOException Not expected to happen\r\n-     */\r\n-    @Test\r\n-    public void testPrintReaderWithoutQuoteToWriter() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        final String content = \"testValue\";\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\r\n-            final StringReader value = new StringReader(content);\r\n-            printer.print(value);\r\n-        }\r\n-        assertEquals(content, sw.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintRecordStream() throws IOException {\r\n-        // @formatter:off\r\n-        final String code = \"a1,b1\\n\" + // 1)\r\n-                \"a2,b2\\n\" + // 2)\r\n-                \"a3,b3\\n\" + // 3)\r\n-                \"a4,b4\\n\";  // 4)\r\n-        // @formatter:on\r\n-        final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\r\n-        final CSVFormat format = CSVFormat.DEFAULT;\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = format.print(sw);\r\n-                CSVParser parser = CSVParser.parse(code, format)) {\r\n-            long count = 0;\r\n-            for (final CSVRecord record : parser) {\r\n-                printer.printRecord(record.stream());\r\n-                assertEquals(++count, printer.getRecordCount());\r\n-            }\r\n-        }\r\n-        try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\r\n-            final List<CSVRecord> records = parser.getRecords();\r\n-            assertFalse(records.isEmpty());\r\n-            Utils.compare(\"Fail\", res, records);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintRecordsWithCSVRecord() throws IOException {\r\n-        final String[] values = { \"A\", \"B\", \"C\" };\r\n-        final String rowData = StringUtils.join(values, ',');\r\n-        final CharArrayWriter charArrayWriter = new CharArrayWriter(0);\r\n-        try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(rowData));\r\n-                CSVPrinter printer = CSVFormat.INFORMIX_UNLOAD.print(charArrayWriter)) {\r\n-            long count = 0;\r\n-            for (final CSVRecord record : parser) {\r\n-                printer.printRecord(record);\r\n-                assertEquals(++count, printer.getRecordCount());\r\n-            }\r\n-        }\r\n-        assertEquals(6, charArrayWriter.size());\r\n-        assertEquals(\"A|B|C\" + CSVFormat.INFORMIX_UNLOAD.getRecordSeparator(), charArrayWriter.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintRecordsWithEmptyVector() throws IOException {\r\n-        final PrintStream out = System.out;\r\n-        try {\r\n-            System.setOut(new PrintStream(NullOutputStream.INSTANCE));\r\n-            try (CSVPrinter printer = CSVFormat.POSTGRESQL_TEXT.printer()) {\r\n-                final Vector<CSVFormatTest.EmptyEnum> vector = new Vector<>();\r\n-                final int expectedCapacity = 23;\r\n-                vector.setSize(expectedCapacity);\r\n-                printer.printRecords(vector);\r\n-                assertEquals(expectedCapacity, vector.capacity());\r\n-                assertEquals(expectedCapacity, printer.getRecordCount());\r\n-            }\r\n-        } finally {\r\n-            System.setOut(out);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintRecordsWithObjectArray() throws IOException {\r\n-        final CharArrayWriter charArrayWriter = new CharArrayWriter(0);\r\n-        final Object[] objectArray = new Object[6];\r\n-        try (CSVPrinter printer = CSVFormat.INFORMIX_UNLOAD.print(charArrayWriter)) {\r\n-            final HashSet<BatchUpdateException> hashSet = new HashSet<>();\r\n-            objectArray[3] = hashSet;\r\n-            printer.printRecords(objectArray);\r\n-            assertEquals(objectArray.length, printer.getRecordCount());\r\n-        }\r\n-        assertEquals(6, charArrayWriter.size());\r\n-        assertEquals(\"\\n\\n\\n\\n\\n\\n\", charArrayWriter.toString());\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintRecordsWithResultSetOneRow() throws IOException, SQLException {\r\n-        try (CSVPrinter printer = CSVFormat.MYSQL.printer()) {\r\n-            try (ResultSet resultSet = new SimpleResultSet()) {\r\n-                assertInitialState(printer);\r\n-                printer.printRecords(resultSet);\r\n-                assertInitialState(printer);\r\n-                assertEquals(0, resultSet.getRow());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintToFileWithCharsetUtf16Be() throws IOException {\r\n-        final File file = createTempFile();\r\n-        try (CSVPrinter printer = CSVFormat.DEFAULT.print(file, StandardCharsets.UTF_16BE)) {\r\n-            printer.printRecord(\"a\", \"b\\\\c\");\r\n-        }\r\n-        assertEquals(\"a,b\\\\c\" + recordSeparator, FileUtils.readFileToString(file, StandardCharsets.UTF_16BE));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintToFileWithDefaultCharset() throws IOException {\r\n-        final File file = createTempFile();\r\n-        try (CSVPrinter printer = CSVFormat.DEFAULT.print(file, Charset.defaultCharset())) {\r\n-            printer.printRecord(\"a\", \"b\\\\c\");\r\n-        }\r\n-        assertEquals(\"a,b\\\\c\" + recordSeparator, FileUtils.readFileToString(file, Charset.defaultCharset()));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testPrintToPathWithDefaultCharset() throws IOException {\r\n-        final Path file = createTempPath();\r\n-        try (CSVPrinter printer = CSVFormat.DEFAULT.print(file, Charset.defaultCharset())) {\r\n-            printer.printRecord(\"a\", \"b\\\\c\");\r\n-        }\r\n-        assertEquals(\"a,b\\\\c\" + recordSeparator, new String(Files.readAllBytes(file), Charset.defaultCharset()));\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testQuoteAll() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.ALL))) {\r\n-            printer.printRecord(\"a\", \"b\\nc\", \"d\");\r\n-            assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",\\\"d\\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testQuoteCommaFirstChar() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) {\r\n-            printer.printRecord(\",\");\r\n-            assertEquals(\"\\\",\\\"\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testQuoteNonNumeric() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.NON_NUMERIC))) {\r\n-            printer.printRecord(\"a\", \"b\\nc\", Integer.valueOf(1));\r\n-            assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",1\" + recordSeparator, sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRandomDefault() throws Exception {\r\n-        doRandom(CSVFormat.DEFAULT, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRandomExcel() throws Exception {\r\n-        doRandom(CSVFormat.EXCEL, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testRandomMongoDbCsv() throws Exception {\r\n-        doRandom(CSVFormat.MONGODB_CSV, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRandomMySql() throws Exception {\r\n-        doRandom(CSVFormat.MYSQL, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testRandomOracle() throws Exception {\r\n-        doRandom(CSVFormat.ORACLE, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    @Disabled\r\n-    public void testRandomPostgreSqlCsv() throws Exception {\r\n-        doRandom(CSVFormat.POSTGRESQL_CSV, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRandomPostgreSqlText() throws Exception {\r\n-        doRandom(CSVFormat.POSTGRESQL_TEXT, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRandomRfc4180() throws Exception {\r\n-        doRandom(CSVFormat.RFC4180, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testRandomTdf() throws Exception {\r\n-        doRandom(CSVFormat.TDF, ITERATIONS_FOR_RANDOM_TEST);\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testSingleLineComment() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'))) {\r\n-            printer.printComment(\"This is a comment\");\r\n-            assertEquals(\"# This is a comment\" + recordSeparator, sw.toString());\r\n-            assertEquals(0, printer.getRecordCount());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testSingleQuoteQuoted() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\r\n-            printer.print(\"a'b'c\");\r\n-            printer.print(\"xyz\");\r\n-            assertEquals(\"'a''b''c',xyz\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testSkipHeaderRecordFalse() throws IOException {\r\n-        // functionally identical to testHeader, used to test CSV-153\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(false))) {\r\n-            printer.printRecord(\"a\", \"b\", \"c\");\r\n-            printer.printRecord(\"x\", \"y\", \"z\");\r\n-            assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testSkipHeaderRecordTrue() throws IOException {\r\n-        // functionally identical to testHeaderNotSet, used to test CSV-153\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(true))) {\r\n-            printer.printRecord(\"a\", \"b\", \"c\");\r\n-            printer.printRecord(\"x\", \"y\", \"z\");\r\n-            assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testTrailingDelimiterOnTwoColumns() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrailingDelimiter())) {\r\n-            printer.printRecord(\"A\", \"B\");\r\n-            assertEquals(\"A,B,\\r\\n\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testTrimOffOneColumn() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim(false))) {\r\n-            printer.print(\" A \");\r\n-            assertEquals(\"\\\" A \\\"\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testTrimOnOneColumn() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim())) {\r\n-            printer.print(\" A \");\r\n-            assertEquals(\"A\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testTrimOnTwoColumns() throws IOException {\r\n-        final StringWriter sw = new StringWriter();\r\n-        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim())) {\r\n-            printer.print(\" A \");\r\n-            printer.print(\" B \");\r\n-            assertEquals(\"A,B\", sw.toString());\r\n-        }\r\n-    }\r\n-\r\n-    private String[] toFirstRecordValues(final String expected, final CSVFormat format) throws IOException {\r\n-        try (CSVParser parser = CSVParser.parse(expected, format)) {\r\n-            return parser.getRecords().get(0).values();\r\n-        }\r\n-    }\r\n-\r\n-    private void tryFormat(final List<String> list, final Character quote, final Character escape, final String expected) throws IOException {\r\n-        final CSVFormat format = CSVFormat.DEFAULT.withQuote(quote).withEscape(escape).withRecordSeparator(null);\r\n-        final Appendable out = new StringBuilder();\r\n-        try (CSVPrinter printer = new CSVPrinter(out, format)) {\r\n-            printer.printRecord(list);\r\n-        }\r\n-        assertEquals(expected, out.toString());\r\n-    }\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import static org.apache.commons.csv.Constants.BACKSLASH;\n+import static org.apache.commons.csv.Constants.CR;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import java.io.CharArrayWriter;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.sql.BatchUpdateException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Vector;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.h2.tools.SimpleResultSet;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * Tests {@link CSVPrinter}.\n+ */\n+public class CSVPrinterTest {\n+\n+    private static final int TABLE_RECORD_COUNT = 2;\n+    private static final char DQUOTE_CHAR = '\"';\n+    private static final char EURO_CH = '\\u20AC';\n+    private static final int ITERATIONS_FOR_RANDOM_TEST = 50000;\n+    private static final char QUOTE_CH = '\\'';\n+\n+    private static String printable(final String s) {\n+        final StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < s.length(); i++) {\n+            final char ch = s.charAt(i);\n+            if (ch <= ' ' || ch >= 128) {\n+                sb.append(\"(\").append((int) ch).append(\")\");\n+            } else {\n+                sb.append(ch);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    private String longText2;\n+\n+    private final String recordSeparator = CSVFormat.DEFAULT.getRecordSeparator();\n+\n+    private void assertInitialState(final CSVPrinter printer) {\n+        assertEquals(0, printer.getRecordCount());\n+    }\n+\n+    private File createTempFile() throws IOException {\n+        return createTempPath().toFile();\n+    }\n+\n+    private Path createTempPath() throws IOException {\n+        return Files.createTempFile(getClass().getName(), \".csv\");\n+    }\n+\n+    private void doOneRandom(final CSVFormat format) throws Exception {\n+        final Random r = new Random();\n+\n+        final int nLines = r.nextInt(4) + 1;\n+        final int nCol = r.nextInt(3) + 1;\n+        // nLines=1;nCol=2;\n+        final String[][] lines = generateLines(nLines, nCol);\n+\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\n+\n+            for (int i = 0; i < nLines; i++) {\n+                // for (int j=0; j<lines[i].length; j++) System.out.println(\"### VALUE=:\" + printable(lines[i][j]));\n+                printer.printRecord((Object[]) lines[i]);\n+            }\n+\n+            printer.flush();\n+        }\n+        final String result = sw.toString();\n+        // System.out.println(\"### :\" + printable(result));\n+\n+        try (CSVParser parser = CSVParser.parse(result, format)) {\n+            final List<CSVRecord> parseResult = parser.getRecords();\n+\n+            final String[][] expected = lines.clone();\n+            for (int i = 0; i < expected.length; i++) {\n+                expected[i] = expectNulls(expected[i], format);\n+            }\n+            Utils.compare(\"Printer output :\" + printable(result), expected, parseResult);\n+        }\n+    }\n+\n+    private void doRandom(final CSVFormat format, final int iter) throws Exception {\n+        for (int i = 0; i < iter; i++) {\n+            doOneRandom(format);\n+        }\n+    }\n+\n+    /**\n+     * Converts an input CSV array into expected output values WRT NULLs. NULL strings are converted to null values because the parser will convert these\n+     * strings to null.\n+     */\n+    private <T> T[] expectNulls(final T[] original, final CSVFormat csvFormat) {\n+        final T[] fixed = original.clone();\n+        for (int i = 0; i < fixed.length; i++) {\n+            if (Objects.equals(csvFormat.getNullString(), fixed[i])) {\n+                fixed[i] = null;\n+            }\n+        }\n+        return fixed;\n+    }\n+\n+    private String[][] generateLines(final int nLines, final int nCol) {\n+        final String[][] lines = new String[nLines][];\n+        for (int i = 0; i < nLines; i++) {\n+            final String[] line = new String[nCol];\n+            lines[i] = line;\n+            for (int j = 0; j < nCol; j++) {\n+                line[j] = randStr();\n+            }\n+        }\n+        return lines;\n+    }\n+\n+    private Connection getH2Connection() throws SQLException, ClassNotFoundException {\n+        Class.forName(\"org.h2.Driver\");\n+        return DriverManager.getConnection(\"jdbc:h2:mem:my_test;\", \"sa\", \"\");\n+    }\n+\n+    private CSVPrinter printWithHeaderComments(final StringWriter sw, final Date now, final CSVFormat baseFormat) throws IOException {\n+        // Use withHeaderComments first to test CSV-145\n+        // @formatter:off\n+        final CSVFormat format = baseFormat.builder()\n+                .setHeaderComments((String[]) null) // don't blow up\n+                .setHeaderComments((Object[]) null) // don't blow up\n+                .setHeaderComments(\"Generated by Apache Commons CSV 1.1\", now)\n+                .setCommentMarker('#')\n+                .setHeader(\"Col1\", \"Col2\")\n+                .get();\n+        // @formatter:on\n+        final CSVPrinter printer = format.print(sw);\n+        printer.printRecord(\"A\", \"B\");\n+        printer.printRecord(\"C\", \"D\");\n+        printer.close();\n+        return printer;\n+    }\n+\n+    private String randStr() {\n+        final Random r = new Random();\n+        final int sz = r.nextInt(20);\n+        // sz = r.nextInt(3);\n+        final char[] buf = new char[sz];\n+        for (int i = 0; i < sz; i++) {\n+            // stick in special chars with greater frequency\n+            final char ch;\n+            final int what = r.nextInt(20);\n+            switch (what) {\n+            case 0:\n+                ch = '\\r';\n+                break;\n+            case 1:\n+                ch = '\\n';\n+                break;\n+            case 2:\n+                ch = '\\t';\n+                break;\n+            case 3:\n+                ch = '\\f';\n+                break;\n+            case 4:\n+                ch = ' ';\n+                break;\n+            case 5:\n+                ch = ',';\n+                break;\n+            case 6:\n+                ch = DQUOTE_CHAR;\n+                break;\n+            case 7:\n+                ch = '\\'';\n+                break;\n+            case 8:\n+                ch = BACKSLASH;\n+                break;\n+            default:\n+                ch = (char) r.nextInt(300);\n+                break;\n+            // default: ch = 'a'; break;\n+            }\n+            buf[i] = ch;\n+        }\n+        return new String(buf);\n+    }\n+\n+    private void setUpTable(final Connection connection) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            statement.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255), TEXT CLOB, BIN_DATA BLOB)\");\n+            statement.execute(\"insert into TEST values(1, 'r1', 'long text 1', 'binary data 1')\");\n+            longText2 = StringUtils.repeat('a', IOUtils.DEFAULT_BUFFER_SIZE - 4);\n+            longText2 += \"\\\"\\r\\n\\\"b\\\"\";\n+            longText2 += StringUtils.repeat('c', IOUtils.DEFAULT_BUFFER_SIZE - 1);\n+            statement.execute(\"insert into TEST values(2, 'r2', '\" + longText2 + \"', 'binary data 2')\");\n+            longText2 = longText2.replace(\"\\\"\", \"\\\"\\\"\");\n+        }\n+    }\n+\n+    @Test\n+    public void testCloseBackwardCompatibility() throws IOException {\n+        try (Writer writer = mock(Writer.class)) {\n+            final CSVFormat csvFormat = CSVFormat.DEFAULT;\n+            try (CSVPrinter printer = new CSVPrinter(writer, csvFormat)) {\n+                assertInitialState(printer);\n+            }\n+            verify(writer, never()).flush();\n+            verify(writer, times(1)).close();\n+        }\n+    }\n+\n+    @Test\n+    public void testCloseWithCsvFormatAutoFlushOff() throws IOException {\n+        try (Writer writer = mock(Writer.class)) {\n+            final CSVFormat csvFormat = CSVFormat.DEFAULT.withAutoFlush(false);\n+            try (CSVPrinter printer = new CSVPrinter(writer, csvFormat)) {\n+                assertInitialState(printer);\n+            }\n+            verify(writer, never()).flush();\n+            verify(writer, times(1)).close();\n+        }\n+    }\n+\n+    @Test\n+    public void testCloseWithCsvFormatAutoFlushOn() throws IOException {\n+        // System.out.println(\"start method\");\n+        try (Writer writer = mock(Writer.class)) {\n+            final CSVFormat csvFormat = CSVFormat.DEFAULT.withAutoFlush(true);\n+            try (CSVPrinter printer = new CSVPrinter(writer, csvFormat)) {\n+                assertInitialState(printer);\n+            }\n+            verify(writer, times(1)).flush();\n+            verify(writer, times(1)).close();\n+        }\n+    }\n+\n+    @Test\n+    public void testCloseWithFlushOff() throws IOException {\n+        try (Writer writer = mock(Writer.class)) {\n+            final CSVFormat csvFormat = CSVFormat.DEFAULT;\n+            @SuppressWarnings(\"resource\")\n+            final CSVPrinter printer = new CSVPrinter(writer, csvFormat);\n+            assertInitialState(printer);\n+            printer.close(false);\n+            assertEquals(0, printer.getRecordCount());\n+            verify(writer, never()).flush();\n+            verify(writer, times(1)).close();\n+        }\n+    }\n+\n+    @Test\n+    public void testCloseWithFlushOn() throws IOException {\n+        try (Writer writer = mock(Writer.class)) {\n+            @SuppressWarnings(\"resource\")\n+            final CSVPrinter printer = new CSVPrinter(writer, CSVFormat.DEFAULT);\n+            assertInitialState(printer);\n+            printer.close(true);\n+            assertEquals(0, printer.getRecordCount());\n+            verify(writer, times(1)).flush();\n+        }\n+    }\n+\n+    @Test\n+    public void testCRComment() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final Object value = \"abc\";\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'))) {\n+            assertInitialState(printer);\n+            printer.print(value);\n+            assertEquals(0, printer.getRecordCount());\n+            printer.printComment(\"This is a comment\\r\\non multiple lines\\rthis is next comment\\r\");\n+            assertEquals(\"abc\" + recordSeparator + \"# This is a comment\" + recordSeparator + \"# on multiple lines\" + recordSeparator +\n+                    \"# this is next comment\" + recordSeparator + \"# \" + recordSeparator, sw.toString());\n+            assertEquals(0, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testCSV135() throws IOException {\n+        final List<String> list = new LinkedList<>();\n+        list.add(\"\\\"\\\"\"); // \"\"\n+        list.add(\"\\\\\\\\\"); // \\\\\n+        list.add(\"\\\\\\\"\\\\\"); // \\\"\\\n+        //\n+        // \"\",\\\\,\\\"\\ (unchanged)\n+        tryFormat(list, null, null, \"\\\"\\\",\\\\\\\\,\\\\\\\"\\\\\");\n+        //\n+        // \"\"\"\"\"\",\\\\,\"\\\"\"\\\" (quoted, and embedded DQ doubled)\n+        tryFormat(list, '\"', null, \"\\\"\\\"\\\"\\\"\\\"\\\",\\\\\\\\,\\\"\\\\\\\"\\\"\\\\\\\"\");\n+        //\n+        // \"\",\\\\\\\\,\\\\\"\\\\ (escapes escaped, not quoted)\n+        tryFormat(list, null, '\\\\', \"\\\"\\\",\\\\\\\\\\\\\\\\,\\\\\\\\\\\"\\\\\\\\\");\n+        //\n+        // \"\\\"\\\"\",\"\\\\\\\\\",\"\\\\\\\"\\\\\" (quoted, and embedded DQ & escape escaped)\n+        tryFormat(list, '\"', '\\\\', \"\\\"\\\\\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\\\\\\\\\",\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\"\");\n+        //\n+        // \"\"\"\"\"\",\\\\,\"\\\"\"\\\" (quoted, embedded DQ escaped)\n+        tryFormat(list, '\"', '\"', \"\\\"\\\"\\\"\\\"\\\"\\\",\\\\\\\\,\\\"\\\\\\\"\\\"\\\\\\\"\");\n+    }\n+\n+    @Test\n+    public void testCSV259() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (Reader reader = new FileReader(\"src/test/resources/org/apache/commons/csv/CSV-259/sample.txt\");\n+                CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null))) {\n+            assertInitialState(printer);\n+            printer.print(reader);\n+            assertEquals(\"x!,y!,z\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDelimeterQuoted() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\n+            assertInitialState(printer);\n+            printer.print(\"a,b,c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"'a,b,c',xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDelimeterQuoteNone() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVFormat format = CSVFormat.DEFAULT.withEscape('!').withQuoteMode(QuoteMode.NONE);\n+        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            assertInitialState(printer);\n+            printer.print(\"a,b,c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"a!,b!,c,xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDelimeterStringQuoted() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setQuote('\\'').get())) {\n+            assertInitialState(printer);\n+            printer.print(\"a[|]b[|]c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"'a[|]b[|]c'[|]xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDelimeterStringQuoteNone() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVFormat format = CSVFormat.DEFAULT.builder().setDelimiter(\"[|]\").setEscape('!').setQuoteMode(QuoteMode.NONE).get();\n+        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            assertInitialState(printer);\n+            printer.print(\"a[|]b[|]c\");\n+            printer.print(\"xyz\");\n+            printer.print(\"a[xy]bc[]\");\n+            assertEquals(\"a![!|!]b![!|!]c[|]xyz[|]a[xy]bc[]\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDelimiterEscaped() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null))) {\n+            assertInitialState(printer);\n+            printer.print(\"a,b,c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"a!,b!,c,xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDelimiterPlain() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\n+            assertInitialState(printer);\n+            printer.print(\"a,b,c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"a,b,c,xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDelimiterStringEscaped() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.builder().setDelimiter(\"|||\").setEscape('!').setQuote(null).get())) {\n+            assertInitialState(printer);\n+            printer.print(\"a|||b|||c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"a!|!|!|b!|!|!|c|||xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDisabledComment() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printComment(\"This is a comment\");\n+            assertEquals(\"\", sw.toString());\n+            assertEquals(0, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testDontQuoteEuroFirstChar() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) {\n+            assertInitialState(printer);\n+            printer.printRecord(EURO_CH, \"Deux\");\n+            assertEquals(EURO_CH + \",Deux\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testEolEscaped() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'))) {\n+            assertInitialState(printer);\n+            printer.print(\"a\\rb\\nc\");\n+            printer.print(\"x\\fy\\bz\");\n+            assertEquals(\"a!rb!nc,x\\fy\\bz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testEolPlain() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\n+            assertInitialState(printer);\n+            printer.print(\"a\\rb\\nc\");\n+            printer.print(\"x\\fy\\bz\");\n+            assertEquals(\"a\\rb\\nc,x\\fy\\bz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testEolQuoted() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\n+            assertInitialState(printer);\n+            printer.print(\"a\\rb\\nc\");\n+            printer.print(\"x\\by\\fz\");\n+            assertEquals(\"'a\\rb\\nc',x\\by\\fz\", sw.toString());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unlikely-arg-type\")\n+    @Test\n+    public void testEquals() throws IOException {\n+        // Don't use assertNotEquals here\n+        assertFalse(CSVFormat.DEFAULT.equals(null));\n+        // Don't use assertNotEquals here\n+        assertFalse(CSVFormat.DEFAULT.equals(\"\"));\n+    }\n+\n+    @Test\n+    public void testEscapeBackslash1() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n+            assertInitialState(printer);\n+            printer.print(\"\\\\\");\n+        }\n+        assertEquals(\"\\\\\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeBackslash2() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n+            assertInitialState(printer);\n+            printer.print(\"\\\\\\r\");\n+        }\n+        assertEquals(\"'\\\\\\r'\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeBackslash3() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n+            assertInitialState(printer);\n+            printer.print(\"X\\\\\\r\");\n+        }\n+        assertEquals(\"'X\\\\\\r'\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeBackslash4() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n+            assertInitialState(printer);\n+            printer.print(\"\\\\\\\\\");\n+        }\n+        assertEquals(\"\\\\\\\\\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeBackslash5() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {\n+            assertInitialState(printer);\n+            printer.print(\"\\\\\\\\\");\n+        }\n+        assertEquals(\"\\\\\\\\\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeNull1() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n+            assertInitialState(printer);\n+            printer.print(\"\\\\\");\n+        }\n+        assertEquals(\"\\\\\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeNull2() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n+            assertInitialState(printer);\n+            printer.print(\"\\\\\\r\");\n+        }\n+        assertEquals(\"\\\"\\\\\\r\\\"\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeNull3() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n+            assertInitialState(printer);\n+            printer.print(\"X\\\\\\r\");\n+        }\n+        assertEquals(\"\\\"X\\\\\\r\\\"\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeNull4() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n+            assertInitialState(printer);\n+            printer.print(\"\\\\\\\\\");\n+        }\n+        assertEquals(\"\\\\\\\\\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testEscapeNull5() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n+            assertInitialState(printer);\n+            printer.print(\"\\\\\\\\\");\n+        }\n+        assertEquals(\"\\\\\\\\\", sw.toString());\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllArrayOfArrays() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords((Object[]) new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } });\n+            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllArrayOfArraysWithFirstEmptyValue2() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords((Object[]) new String[][] { { \"\" } });\n+            assertEquals(\"\\\"\\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllArrayOfArraysWithFirstSpaceValue1() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords((Object[]) new String[][] { { \" \", \"r1c2\" } });\n+            assertEquals(\"\\\" \\\",r1c2\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllArrayOfArraysWithFirstTabValue1() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords((Object[]) new String[][] { { \"\\t\", \"r1c2\" } });\n+            assertEquals(\"\\\"\\t\\\",r1c2\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllArrayOfLists() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords((Object[]) new List[] { Arrays.asList(\"r1c1\", \"r1c2\"), Arrays.asList(\"r2c1\", \"r2c2\") });\n+            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllArrayOfListsWithFirstEmptyValue2() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords((Object[]) new List[] { Arrays.asList(\"\") });\n+            assertEquals(\"\\\"\\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllIterableOfArrays() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords(Arrays.asList(new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } }));\n+            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllIterableOfArraysWithFirstEmptyValue2() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords(Arrays.asList(new String[][] { { \"\" } }));\n+            assertEquals(\"\\\"\\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllIterableOfLists() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords(Arrays.asList(Arrays.asList(\"r1c1\", \"r1c2\"), Arrays.asList(\"r2c1\", \"r2c2\")));\n+            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrintAllStreamOfArrays() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecords(Stream.of(new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } }));\n+            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrinter1() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", \"b\");\n+            assertEquals(\"a,b\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelPrinter2() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a,b\", \"b\");\n+            assertEquals(\"\\\"a,b\\\",b\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testHeader() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\"))) {\n+            assertEquals(1, printer.getRecordCount());\n+            printer.printRecord(\"a\", \"b\", \"c\");\n+            printer.printRecord(\"x\", \"y\", \"z\");\n+            assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testHeaderCommentExcel() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final Date now = new Date();\n+        final CSVFormat format = CSVFormat.EXCEL;\n+        try (CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format)) {\n+            assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1,Col2\\r\\nA,B\\r\\nC,D\\r\\n\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testHeaderCommentTdf() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final Date now = new Date();\n+        final CSVFormat format = CSVFormat.TDF;\n+        try (CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format)) {\n+            assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1\\tCol2\\r\\nA\\tB\\r\\nC\\tD\\r\\n\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testHeaderNotSet() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", \"b\", \"c\");\n+            printer.printRecord(\"x\", \"y\", \"z\");\n+            assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testInvalidFormat() {\n+        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withDelimiter(CR));\n+    }\n+\n+    @Test\n+    public void testJdbcPrinter() throws IOException, ClassNotFoundException, SQLException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVFormat csvFormat = CSVFormat.DEFAULT;\n+        try (Connection connection = getH2Connection()) {\n+            setUpTable(connection);\n+            try (Statement stmt = connection.createStatement();\n+                    CSVPrinter printer = new CSVPrinter(sw, csvFormat);\n+                    ResultSet resultSet = stmt.executeQuery(\"select ID, NAME, TEXT, BIN_DATA from TEST\")) {\n+                assertInitialState(printer);\n+                printer.printRecords(resultSet);\n+                assertEquals(TABLE_RECORD_COUNT, printer.getRecordCount());\n+            }\n+        }\n+        final String csv = sw.toString();\n+        assertEquals(\"1,r1,\\\"long text 1\\\",\\\"YmluYXJ5IGRhdGEgMQ==\\r\\n\\\"\" + recordSeparator + \"2,r2,\\\"\" + longText2 + \"\\\",\\\"YmluYXJ5IGRhdGEgMg==\\r\\n\\\"\" +\n+                recordSeparator, csv);\n+        // Round trip the data\n+        try (StringReader reader = new StringReader(csv);\n+                CSVParser csvParser = csvFormat.parse(reader)) {\n+            // Row 1\n+            CSVRecord record = csvParser.nextRecord();\n+            assertEquals(\"1\", record.get(0));\n+            assertEquals(\"r1\", record.get(1));\n+            assertEquals(\"long text 1\", record.get(2));\n+            assertEquals(\"YmluYXJ5IGRhdGEgMQ==\\r\\n\", record.get(3));\n+            // Row 2\n+            record = csvParser.nextRecord();\n+            assertEquals(\"2\", record.get(0));\n+            assertEquals(\"r2\", record.get(1));\n+            assertEquals(\"YmluYXJ5IGRhdGEgMg==\\r\\n\", record.get(3));\n+        }\n+    }\n+\n+    @Test\n+    public void testJdbcPrinterWithFirstEmptyValue2() throws IOException, ClassNotFoundException, SQLException {\n+        final StringWriter sw = new StringWriter();\n+        try (Connection connection = getH2Connection()) {\n+            try (Statement stmt = connection.createStatement();\n+                    ResultSet resultSet = stmt.executeQuery(\"select '' AS EMPTYVALUE from DUAL\");\n+                    CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet).print(sw)) {\n+                printer.printRecords(resultSet);\n+            }\n+        }\n+        assertEquals(\"EMPTYVALUE\" + recordSeparator + \"\\\"\\\"\" + recordSeparator, sw.toString());\n+    }\n+\n+    @Test\n+    public void testJdbcPrinterWithResultSet() throws IOException, ClassNotFoundException, SQLException {\n+        final StringWriter sw = new StringWriter();\n+        try (Connection connection = getH2Connection()) {\n+            setUpTable(connection);\n+            try (Statement stmt = connection.createStatement();\n+                    ResultSet resultSet = stmt.executeQuery(\"select ID, NAME, TEXT from TEST\");\n+                    CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet).print(sw)) {\n+                printer.printRecords(resultSet);\n+            }\n+        }\n+        assertEquals(\"ID,NAME,TEXT\" + recordSeparator + \"1,r1,\\\"long text 1\\\"\" + recordSeparator + \"2,r2,\\\"\" + longText2 + \"\\\"\" + recordSeparator,\n+                sw.toString());\n+    }\n+\n+    @Test\n+    public void testJdbcPrinterWithResultSetHeader() throws IOException, ClassNotFoundException, SQLException {\n+        final StringWriter sw = new StringWriter();\n+        try (Connection connection = getH2Connection()) {\n+            setUpTable(connection);\n+            try (Statement stmt = connection.createStatement();\n+                    CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+                try (ResultSet resultSet = stmt.executeQuery(\"select ID, NAME from TEST\")) {\n+                    printer.printRecords(resultSet, true);\n+                    assertEquals(TABLE_RECORD_COUNT, printer.getRecordCount());\n+                    assertEquals(\"ID,NAME\" + recordSeparator + \"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator, sw.toString());\n+                }\n+                try (ResultSet resultSet = stmt.executeQuery(\"select ID, NAME from TEST\")) {\n+                    printer.printRecords(resultSet, false);\n+                    assertEquals(TABLE_RECORD_COUNT * 2, printer.getRecordCount());\n+                    assertNotEquals(\"ID,NAME\" + recordSeparator + \"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator, sw.toString());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testJdbcPrinterWithResultSetMetaData() throws IOException, ClassNotFoundException, SQLException {\n+        final StringWriter sw = new StringWriter();\n+        try (Connection connection = getH2Connection()) {\n+            setUpTable(connection);\n+            try (Statement stmt = connection.createStatement();\n+                    ResultSet resultSet = stmt.executeQuery(\"select ID, NAME, TEXT from TEST\");\n+                    CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet.getMetaData()).print(sw)) {\n+                // The header is the first record.\n+                assertEquals(1, printer.getRecordCount());\n+                printer.printRecords(resultSet);\n+                assertEquals(3, printer.getRecordCount());\n+                assertEquals(\"ID,NAME,TEXT\" + recordSeparator + \"1,r1,\\\"long text 1\\\"\" + recordSeparator + \"2,r2,\\\"\" + longText2 + \"\\\"\" + recordSeparator,\n+                        sw.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testJira135_part1() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\n+        final StringWriter sw = new StringWriter();\n+        final List<String> list = new LinkedList<>();\n+        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            list.add(\"\\\"\");\n+            printer.printRecord(list);\n+        }\n+        final String expected = \"\\\"\\\\\\\"\\\"\" + format.getRecordSeparator();\n+        assertEquals(expected, sw.toString());\n+        final String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testJira135_part2() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\n+        final StringWriter sw = new StringWriter();\n+        final List<String> list = new LinkedList<>();\n+        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            list.add(\"\\n\");\n+            printer.printRecord(list);\n+        }\n+        final String expected = \"\\\"\\\\n\\\"\" + format.getRecordSeparator();\n+        assertEquals(expected, sw.toString());\n+        final String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n+    }\n+\n+    @Test\n+    public void testJira135_part3() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\n+        final StringWriter sw = new StringWriter();\n+        final List<String> list = new LinkedList<>();\n+        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            list.add(\"\\\\\");\n+            printer.printRecord(list);\n+        }\n+        final String expected = \"\\\"\\\\\\\\\\\"\" + format.getRecordSeparator();\n+        assertEquals(expected, sw.toString());\n+        final String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testJira135All() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote(DQUOTE_CHAR).withEscape(BACKSLASH);\n+        final StringWriter sw = new StringWriter();\n+        final List<String> list = new LinkedList<>();\n+        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            list.add(\"\\\"\");\n+            list.add(\"\\n\");\n+            list.add(\"\\\\\");\n+            printer.printRecord(list);\n+        }\n+        final String expected = \"\\\"\\\\\\\"\\\",\\\"\\\\n\\\",\\\"\\\\\\\"\" + format.getRecordSeparator();\n+        assertEquals(expected, sw.toString());\n+        final String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n+    }\n+\n+    @Test\n+    public void testMongoDbCsvBasic() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\n+            printer.printRecord(\"a\", \"b\");\n+            assertEquals(\"a,b\" + recordSeparator, sw.toString());\n+            assertEquals(1, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testMongoDbCsvCommaInValue() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\n+            printer.printRecord(\"a,b\", \"c\");\n+            assertEquals(\"\\\"a,b\\\",c\" + recordSeparator, sw.toString());\n+            assertEquals(1, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testMongoDbCsvDoubleQuoteInValue() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\n+            printer.printRecord(\"a \\\"c\\\" b\", \"d\");\n+            assertEquals(\"\\\"a \\\"\\\"c\\\"\\\" b\\\",d\" + recordSeparator, sw.toString());\n+            assertEquals(1, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testMongoDbCsvTabInValue() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_CSV)) {\n+            printer.printRecord(\"a\\tb\", \"c\");\n+            assertEquals(\"a\\tb,c\" + recordSeparator, sw.toString());\n+            assertEquals(1, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testMongoDbTsvBasic() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_TSV)) {\n+            printer.printRecord(\"a\", \"b\");\n+            assertEquals(\"a\\tb\" + recordSeparator, sw.toString());\n+            assertEquals(1, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testMongoDbTsvCommaInValue() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_TSV)) {\n+            printer.printRecord(\"a,b\", \"c\");\n+            assertEquals(\"a,b\\tc\" + recordSeparator, sw.toString());\n+            assertEquals(1, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testMongoDbTsvTabInValue() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.MONGODB_TSV)) {\n+            printer.printRecord(\"a\\tb\", \"c\");\n+            assertEquals(\"\\\"a\\tb\\\"\\tc\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testMultiLineComment() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'))) {\n+            printer.printComment(\"This is a comment\\non multiple lines\");\n+            assertEquals(\"# This is a comment\" + recordSeparator + \"# on multiple lines\" + recordSeparator, sw.toString());\n+            assertEquals(0, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testMySqlNullOutput() throws IOException {\n+        Object[] s = new String[] { \"NULL\", null };\n+        CSVFormat format = CSVFormat.MYSQL.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.NON_NUMERIC);\n+        StringWriter writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        String expected = \"\\\"NULL\\\"\\tNULL\\n\";\n+        assertEquals(expected, writer.toString());\n+        String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(s, record0);\n+\n+        s = new String[] { \"\\\\N\", null };\n+        format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\t\\\\N\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\N\", \"A\" };\n+        format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\tA\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\n\", \"A\" };\n+        format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\n\\tA\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\", null };\n+        format = CSVFormat.MYSQL.withNullString(\"NULL\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\tNULL\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\", null };\n+        format = CSVFormat.MYSQL;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\t\\\\N\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\n+        format = CSVFormat.MYSQL;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"NULL\", \"\\\\\\r\" };\n+        format = CSVFormat.MYSQL;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\\\r\" };\n+        format = CSVFormat.MYSQL;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+    }\n+\n+    @Test\n+    public void testMySqlNullStringDefault() {\n+        assertEquals(\"\\\\N\", CSVFormat.MYSQL.getNullString());\n+    }\n+\n+    @Test\n+    public void testNewCsvPrinterAppendableNullFormat() {\n+        assertThrows(NullPointerException.class, () -> new CSVPrinter(new StringWriter(), null));\n+    }\n+\n+    @Test\n+    public void testNewCsvPrinterNullAppendableFormat() {\n+        assertThrows(NullPointerException.class, () -> new CSVPrinter(null, CSVFormat.DEFAULT));\n+    }\n+\n+    @Test\n+    public void testNotFlushable() throws IOException {\n+        final Appendable out = new StringBuilder();\n+        try (CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT)) {\n+            printer.printRecord(\"a\", \"b\", \"c\");\n+            assertEquals(\"a,b,c\" + recordSeparator, out.toString());\n+            printer.flush();\n+        }\n+    }\n+\n+    @Test\n+    public void testParseCustomNullValues() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVFormat format = CSVFormat.DEFAULT.withNullString(\"NULL\");\n+        try (CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            printer.printRecord(\"a\", null, \"b\");\n+        }\n+        final String csvString = sw.toString();\n+        assertEquals(\"a,NULL,b\" + recordSeparator, csvString);\n+        try (CSVParser iterable = format.parse(new StringReader(csvString))) {\n+            final Iterator<CSVRecord> iterator = iterable.iterator();\n+            final CSVRecord record = iterator.next();\n+            assertEquals(\"a\", record.get(0));\n+            assertNull(record.get(1));\n+            assertEquals(\"b\", record.get(2));\n+            assertFalse(iterator.hasNext());\n+        }\n+    }\n+\n+    @Test\n+    public void testPlainEscaped() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'))) {\n+            printer.print(\"abc\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"abc,xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPlainPlain() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\n+            printer.print(\"abc\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"abc,xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPlainQuoted() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\n+            printer.print(\"abc\");\n+            assertEquals(\"abc\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testPostgreSqlCsvNullOutput() throws IOException {\n+        Object[] s = new String[] { \"NULL\", null };\n+        CSVFormat format = CSVFormat.POSTGRESQL_CSV.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.ALL_NON_NULL);\n+        StringWriter writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        String expected = \"\\\"NULL\\\",NULL\\n\";\n+        assertEquals(expected, writer.toString());\n+        String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(new Object[2], record0);\n+\n+        s = new String[] { \"\\\\N\", null };\n+        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\t\\\\N\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\N\", \"A\" };\n+        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\tA\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\n\", \"A\" };\n+        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\n\\tA\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\", null };\n+        format = CSVFormat.POSTGRESQL_CSV.withNullString(\"NULL\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\tNULL\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\", null };\n+        format = CSVFormat.POSTGRESQL_CSV;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\t\\\\N\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_CSV;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"NULL\", \"\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_CSV;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_CSV;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testPostgreSqlCsvTextOutput() throws IOException {\n+        Object[] s = new String[] { \"NULL\", null };\n+        CSVFormat format = CSVFormat.POSTGRESQL_TEXT.withQuote(DQUOTE_CHAR).withNullString(\"NULL\").withQuoteMode(QuoteMode.ALL_NON_NULL);\n+        StringWriter writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        String expected = \"\\\"NULL\\\"\\tNULL\\n\";\n+        assertEquals(expected, writer.toString());\n+        String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(new Object[2], record0);\n+\n+        s = new String[] { \"\\\\N\", null };\n+        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\t\\\\N\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\N\", \"A\" };\n+        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\tA\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\n\", \"A\" };\n+        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"\\\\N\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\n\\tA\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\", null };\n+        format = CSVFormat.POSTGRESQL_TEXT.withNullString(\"NULL\");\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\tNULL\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\", null };\n+        format = CSVFormat.POSTGRESQL_TEXT;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\t\\\\N\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_TEXT;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"NULL\", \"\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_TEXT;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+\n+        s = new String[] { \"\\\\\\r\" };\n+        format = CSVFormat.POSTGRESQL_TEXT;\n+        writer = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n+        expected = \"\\\\\\\\\\\\r\\n\";\n+        assertEquals(expected, writer.toString());\n+        record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(s, format), record0);\n+    }\n+\n+    @Test\n+    public void testPostgreSqlNullStringDefaultCsv() {\n+        assertEquals(\"\", CSVFormat.POSTGRESQL_CSV.getNullString());\n+    }\n+\n+    @Test\n+    public void testPostgreSqlNullStringDefaultText() {\n+        assertEquals(\"\\\\N\", CSVFormat.POSTGRESQL_TEXT.getNullString());\n+    }\n+\n+    @Test\n+    public void testPrint() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = CSVFormat.DEFAULT.print(sw)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", \"b\\\\c\");\n+            assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintCSVParser() throws IOException {\n+        // @formatter:off\n+        final String code = \"a1,b1\\n\" + // 1)\n+                \"a2,b2\\n\" + // 2)\n+                \"a3,b3\\n\" + // 3)\n+                \"a4,b4\\n\";  // 4)\n+        // @formatter:on\n+        final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\n+        final CSVFormat format = CSVFormat.DEFAULT;\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = format.print(sw);\n+                CSVParser parser = CSVParser.parse(code, format)) {\n+            assertInitialState(printer);\n+            printer.printRecords(parser);\n+        }\n+        try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertFalse(records.isEmpty());\n+            Utils.compare(\"Fail\", res, records);\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintCSVRecord() throws IOException {\n+        // @formatter:off\n+        final String code = \"a1,b1\\n\" + // 1)\n+                \"a2,b2\\n\" +  // 2)\n+                \"a3,b3\\n\" +  // 3)\n+                \"a4,b4\\n\";   // 4)\n+        // @formatter:on\n+        final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\n+        final CSVFormat format = CSVFormat.DEFAULT;\n+        final StringWriter sw = new StringWriter();\n+        int row = 0;\n+        try (CSVPrinter printer = format.print(sw);\n+                CSVParser parser = CSVParser.parse(code, format)) {\n+            assertInitialState(printer);\n+            for (final CSVRecord record : parser) {\n+                printer.printRecord(record);\n+                assertEquals(++row, printer.getRecordCount());\n+            }\n+            assertEquals(row, printer.getRecordCount());\n+        }\n+        try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertFalse(records.isEmpty());\n+            Utils.compare(\"Fail\", res, records);\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintCSVRecords() throws IOException {\n+        // @formatter:off\n+        final String code = \"a1,b1\\n\" + // 1)\n+                \"a2,b2\\n\" + // 2)\n+                \"a3,b3\\n\" + // 3)\n+                \"a4,b4\\n\";  // 4)\n+        // @formatter:on\n+        final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\n+        final CSVFormat format = CSVFormat.DEFAULT;\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = format.print(sw);\n+                CSVParser parser = CSVParser.parse(code, format)) {\n+            assertInitialState(printer);\n+            printer.printRecords(parser.getRecords());\n+        }\n+        try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertFalse(records.isEmpty());\n+            Utils.compare(\"Fail\", res, records);\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintCustomNullValues() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withNullString(\"NULL\"))) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", null, \"b\");\n+            assertEquals(\"a,NULL,b\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrinter1() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", \"b\");\n+            assertEquals(1, printer.getRecordCount());\n+            assertEquals(\"a,b\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrinter2() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a,b\", \"b\");\n+            assertEquals(\"\\\"a,b\\\",b\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrinter3() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a, b\", \"b \");\n+            assertEquals(\"\\\"a, b\\\",\\\"b \\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrinter4() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", \"b\\\"c\");\n+            assertEquals(\"a,\\\"b\\\"\\\"c\\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrinter5() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", \"b\\nc\");\n+            assertEquals(\"a,\\\"b\\nc\\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrinter6() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", \"b\\r\\nc\");\n+            assertEquals(\"a,\\\"b\\r\\nc\\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrinter7() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", \"b\\\\c\");\n+            assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintNullValues() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            assertInitialState(printer);\n+            printer.printRecord(\"a\", null, \"b\");\n+            assertEquals(\"a,,b\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintOnePositiveInteger() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.MINIMAL))) {\n+            assertInitialState(printer);\n+            printer.print(Integer.MAX_VALUE);\n+            assertEquals(String.valueOf(Integer.MAX_VALUE), sw.toString());\n+        }\n+    }\n+\n+    /**\n+     * Test to target the use of {@link IOUtils#copy(java.io.Reader, Appendable)} which directly buffers the value from the Reader to the Appendable.\n+     *\n+     * <p>\n+     * Requires the format to have no quote or escape character, value to be a {@link Reader Reader} and the output <em>MUST NOT</em> be a {@link Writer Writer}\n+     * but some other Appendable.\n+     * </p>\n+     *\n+     * @throws IOException Not expected to happen\n+     */\n+    @Test\n+    public void testPrintReaderWithoutQuoteToAppendable() throws IOException {\n+        final StringBuilder sb = new StringBuilder();\n+        final String content = \"testValue\";\n+        try (CSVPrinter printer = new CSVPrinter(sb, CSVFormat.DEFAULT.withQuote(null))) {\n+            assertInitialState(printer);\n+            final StringReader value = new StringReader(content);\n+            printer.print(value);\n+        }\n+        assertEquals(content, sb.toString());\n+    }\n+\n+    /**\n+     * Test to target the use of {@link IOUtils#copyLarge(java.io.Reader, Writer)} which directly buffers the value from the Reader to the Writer.\n+     *\n+     * <p>\n+     * Requires the format to have no quote or escape character, value to be a {@link Reader Reader} and the output <em>MUST</em> be a {@link Writer Writer}.\n+     * </p>\n+     *\n+     * @throws IOException Not expected to happen\n+     */\n+    @Test\n+    public void testPrintReaderWithoutQuoteToWriter() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final String content = \"testValue\";\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\n+            final StringReader value = new StringReader(content);\n+            printer.print(value);\n+        }\n+        assertEquals(content, sw.toString());\n+    }\n+\n+    @Test\n+    public void testPrintRecordStream() throws IOException {\n+        // @formatter:off\n+        final String code = \"a1,b1\\n\" + // 1)\n+                \"a2,b2\\n\" + // 2)\n+                \"a3,b3\\n\" + // 3)\n+                \"a4,b4\\n\";  // 4)\n+        // @formatter:on\n+        final String[][] res = { { \"a1\", \"b1\" }, { \"a2\", \"b2\" }, { \"a3\", \"b3\" }, { \"a4\", \"b4\" } };\n+        final CSVFormat format = CSVFormat.DEFAULT;\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = format.print(sw);\n+                CSVParser parser = CSVParser.parse(code, format)) {\n+            long count = 0;\n+            for (final CSVRecord record : parser) {\n+                printer.printRecord(record.stream());\n+                assertEquals(++count, printer.getRecordCount());\n+            }\n+        }\n+        try (CSVParser parser = CSVParser.parse(sw.toString(), format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertFalse(records.isEmpty());\n+            Utils.compare(\"Fail\", res, records);\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintRecordsWithCSVRecord() throws IOException {\n+        final String[] values = { \"A\", \"B\", \"C\" };\n+        final String rowData = StringUtils.join(values, ',');\n+        final CharArrayWriter charArrayWriter = new CharArrayWriter(0);\n+        try (CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(rowData));\n+                CSVPrinter printer = CSVFormat.INFORMIX_UNLOAD.print(charArrayWriter)) {\n+            long count = 0;\n+            for (final CSVRecord record : parser) {\n+                printer.printRecord(record);\n+                assertEquals(++count, printer.getRecordCount());\n+            }\n+        }\n+        assertEquals(6, charArrayWriter.size());\n+        assertEquals(\"A|B|C\" + CSVFormat.INFORMIX_UNLOAD.getRecordSeparator(), charArrayWriter.toString());\n+    }\n+\n+    @Test\n+    public void testPrintRecordsWithEmptyVector() throws IOException {\n+        final PrintStream out = System.out;\n+        try {\n+            System.setOut(new PrintStream(NullOutputStream.INSTANCE));\n+            try (CSVPrinter printer = CSVFormat.POSTGRESQL_TEXT.printer()) {\n+                final Vector<CSVFormatTest.EmptyEnum> vector = new Vector<>();\n+                final int expectedCapacity = 23;\n+                vector.setSize(expectedCapacity);\n+                printer.printRecords(vector);\n+                assertEquals(expectedCapacity, vector.capacity());\n+                assertEquals(expectedCapacity, printer.getRecordCount());\n+            }\n+        } finally {\n+            System.setOut(out);\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintRecordsWithObjectArray() throws IOException {\n+        final CharArrayWriter charArrayWriter = new CharArrayWriter(0);\n+        final Object[] objectArray = new Object[6];\n+        try (CSVPrinter printer = CSVFormat.INFORMIX_UNLOAD.print(charArrayWriter)) {\n+            final HashSet<BatchUpdateException> hashSet = new HashSet<>();\n+            objectArray[3] = hashSet;\n+            printer.printRecords(objectArray);\n+            assertEquals(objectArray.length, printer.getRecordCount());\n+        }\n+        assertEquals(6, charArrayWriter.size());\n+        assertEquals(\"\\n\\n\\n\\n\\n\\n\", charArrayWriter.toString());\n+    }\n+\n+    @Test\n+    public void testPrintRecordsWithResultSetOneRow() throws IOException, SQLException {\n+        try (CSVPrinter printer = CSVFormat.MYSQL.printer()) {\n+            try (ResultSet resultSet = new SimpleResultSet()) {\n+                assertInitialState(printer);\n+                printer.printRecords(resultSet);\n+                assertInitialState(printer);\n+                assertEquals(0, resultSet.getRow());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testPrintToFileWithCharsetUtf16Be() throws IOException {\n+        final File file = createTempFile();\n+        try (CSVPrinter printer = CSVFormat.DEFAULT.print(file, StandardCharsets.UTF_16BE)) {\n+            printer.printRecord(\"a\", \"b\\\\c\");\n+        }\n+        assertEquals(\"a,b\\\\c\" + recordSeparator, FileUtils.readFileToString(file, StandardCharsets.UTF_16BE));\n+    }\n+\n+    @Test\n+    public void testPrintToFileWithDefaultCharset() throws IOException {\n+        final File file = createTempFile();\n+        try (CSVPrinter printer = CSVFormat.DEFAULT.print(file, Charset.defaultCharset())) {\n+            printer.printRecord(\"a\", \"b\\\\c\");\n+        }\n+        assertEquals(\"a,b\\\\c\" + recordSeparator, FileUtils.readFileToString(file, Charset.defaultCharset()));\n+    }\n+\n+    @Test\n+    public void testPrintToPathWithDefaultCharset() throws IOException {\n+        final Path file = createTempPath();\n+        try (CSVPrinter printer = CSVFormat.DEFAULT.print(file, Charset.defaultCharset())) {\n+            printer.printRecord(\"a\", \"b\\\\c\");\n+        }\n+        assertEquals(\"a,b\\\\c\" + recordSeparator, new String(Files.readAllBytes(file), Charset.defaultCharset()));\n+    }\n+\n+    @Test\n+    public void testQuoteAll() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.ALL))) {\n+            printer.printRecord(\"a\", \"b\\nc\", \"d\");\n+            assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",\\\"d\\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testQuoteCommaFirstChar() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) {\n+            printer.printRecord(\",\");\n+            assertEquals(\"\\\",\\\"\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testQuoteNonNumeric() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.NON_NUMERIC))) {\n+            printer.printRecord(\"a\", \"b\\nc\", Integer.valueOf(1));\n+            assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",1\" + recordSeparator, sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testRandomDefault() throws Exception {\n+        doRandom(CSVFormat.DEFAULT, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    public void testRandomExcel() throws Exception {\n+        doRandom(CSVFormat.EXCEL, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testRandomMongoDbCsv() throws Exception {\n+        doRandom(CSVFormat.MONGODB_CSV, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    public void testRandomMySql() throws Exception {\n+        doRandom(CSVFormat.MYSQL, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testRandomOracle() throws Exception {\n+        doRandom(CSVFormat.ORACLE, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    @Disabled\n+    public void testRandomPostgreSqlCsv() throws Exception {\n+        doRandom(CSVFormat.POSTGRESQL_CSV, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    public void testRandomPostgreSqlText() throws Exception {\n+        doRandom(CSVFormat.POSTGRESQL_TEXT, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    public void testRandomRfc4180() throws Exception {\n+        doRandom(CSVFormat.RFC4180, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    public void testRandomTdf() throws Exception {\n+        doRandom(CSVFormat.TDF, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n+    public void testSingleLineComment() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'))) {\n+            printer.printComment(\"This is a comment\");\n+            assertEquals(\"# This is a comment\" + recordSeparator, sw.toString());\n+            assertEquals(0, printer.getRecordCount());\n+        }\n+    }\n+\n+    @Test\n+    public void testSingleQuoteQuoted() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\n+            printer.print(\"a'b'c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"'a''b''c',xyz\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testSkipHeaderRecordFalse() throws IOException {\n+        // functionally identical to testHeader, used to test CSV-153\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(false))) {\n+            printer.printRecord(\"a\", \"b\", \"c\");\n+            printer.printRecord(\"x\", \"y\", \"z\");\n+            assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testSkipHeaderRecordTrue() throws IOException {\n+        // functionally identical to testHeaderNotSet, used to test CSV-153\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(true))) {\n+            printer.printRecord(\"a\", \"b\", \"c\");\n+            printer.printRecord(\"x\", \"y\", \"z\");\n+            assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testTrailingDelimiterOnTwoColumns() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrailingDelimiter())) {\n+            printer.printRecord(\"A\", \"B\");\n+            assertEquals(\"A,B,\\r\\n\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testTrimOffOneColumn() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim(false))) {\n+            printer.print(\" A \");\n+            assertEquals(\"\\\" A \\\"\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testTrimOnOneColumn() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim())) {\n+            printer.print(\" A \");\n+            assertEquals(\"A\", sw.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testTrimOnTwoColumns() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim())) {\n+            printer.print(\" A \");\n+            printer.print(\" B \");\n+            assertEquals(\"A,B\", sw.toString());\n+        }\n+    }\n+\n+    private String[] toFirstRecordValues(final String expected, final CSVFormat format) throws IOException {\n+        try (CSVParser parser = CSVParser.parse(expected, format)) {\n+            return parser.getRecords().get(0).values();\n+        }\n+    }\n+\n+    private void tryFormat(final List<String> list, final Character quote, final Character escape, final String expected) throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withQuote(quote).withEscape(escape).withRecordSeparator(null);\n+        final Appendable out = new StringBuilder();\n+        try (CSVPrinter printer = new CSVPrinter(out, format)) {\n+            printer.printRecord(list);\n+        }\n+        assertEquals(expected, out.toString());\n+    }\n+\n+}\n\ndiff --git a/src/test/java/org/apache/commons/csv/PerformanceTest.java b/src/test/java/org/apache/commons/csv/PerformanceTest.java\nindex f692ae8e..bf0d4838 100644\n--- a/src/test/java/org/apache/commons/csv/PerformanceTest.java\n+++ b/src/test/java/org/apache/commons/csv/PerformanceTest.java\n@@ -1,345 +1,345 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv;\r\n-\r\n-import static org.apache.commons.io.IOUtils.EOF;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.File;\r\n-import java.io.FileInputStream;\r\n-import java.io.FileOutputStream;\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStream;\r\n-import java.io.Reader;\r\n-import java.lang.reflect.Constructor;\r\n-import java.lang.reflect.InvocationTargetException;\r\n-import java.nio.charset.StandardCharsets;\r\n-import java.nio.file.Files;\r\n-import java.nio.file.Paths;\r\n-import java.util.zip.GZIPInputStream;\r\n-\r\n-import org.apache.commons.io.FileUtils;\r\n-import org.apache.commons.io.IOUtils;\r\n-\r\n-/**\r\n- * Basic test harness.\r\n- */\r\n-@SuppressWarnings(\"boxing\")\r\n-public class PerformanceTest {\r\n-\r\n-    @FunctionalInterface\r\n-    private interface CSVParserFactory {\r\n-        CSVParser createParser() throws IOException;\r\n-    }\r\n-\r\n-    // Container for basic statistics\r\n-    private static final class Stats {\r\n-        final int count;\r\n-        final int fields;\r\n-\r\n-        Stats(final int c, final int f) {\r\n-            count = c;\r\n-            fields = f;\r\n-        }\r\n-    }\r\n-\r\n-    private static final String[] PROPERTY_NAMES = { \"java.version\", // Java Runtime Environment version\r\n-            \"java.vendor\", // Java Runtime Environment vendor\r\n-//        \"java.vm.specification.version\", // Java Virtual Machine specification version\r\n-//        \"java.vm.specification.vendor\",  // Java Virtual Machine specification vendor\r\n-//        \"java.vm.specification.name\",    // Java Virtual Machine specification name\r\n-            \"java.vm.version\", // Java Virtual Machine implementation version\r\n-//        \"java.vm.vendor\",                // Java Virtual Machine implementation vendor\r\n-            \"java.vm.name\", // Java Virtual Machine implementation name\r\n-//        \"java.specification.version\",    // Java Runtime Environment specification version\r\n-//        \"java.specification.vendor\",     // Java Runtime Environment specification vendor\r\n-//        \"java.specification.name\",       // Java Runtime Environment specification name\r\n-\r\n-            \"os.name\", // Operating system name\r\n-            \"os.arch\", // Operating system architecture\r\n-            \"os.version\", // Operating system version\r\n-    };\r\n-    private static int max = 11; // skip first test\r\n-\r\n-    private static int num; // number of elapsed times recorded\r\n-\r\n-    private static final long[] ELAPSED_TIMES = new long[max];\r\n-    private static final CSVFormat format = CSVFormat.EXCEL;\r\n-\r\n-    private static final String TEST_RESRC = \"org/apache/commons/csv/perf/worldcitiespop.txt.gz\";\r\n-\r\n-    private static final File BIG_FILE = new File(FileUtils.getTempDirectoryPath(), \"worldcitiespop.txt\");\r\n-\r\n-    private static Reader createReader() throws IOException {\r\n-        return new InputStreamReader(new FileInputStream(BIG_FILE), StandardCharsets.ISO_8859_1);\r\n-    }\r\n-\r\n-    private static Lexer createTestCSVLexer(final String test, final ExtendedBufferedReader input)\r\n-            throws InstantiationException, IllegalAccessException, InvocationTargetException, Exception {\r\n-        return test.startsWith(\"CSVLexer\") ? getLexerCtor(test).newInstance(format, input) : new Lexer(format, input);\r\n-    }\r\n-\r\n-    private static Constructor<Lexer> getLexerCtor(final String clazz) throws Exception {\r\n-        @SuppressWarnings(\"unchecked\")\r\n-        final Class<Lexer> lexer = (Class<Lexer>) Class.forName(\"org.apache.commons.csv.\" + clazz);\r\n-        return lexer.getConstructor(CSVFormat.class, ExtendedBufferedReader.class);\r\n-    }\r\n-\r\n-    private static Stats iterate(final Iterable<CSVRecord> iterable) {\r\n-        int count = 0;\r\n-        int fields = 0;\r\n-        for (final CSVRecord record : iterable) {\r\n-            count++;\r\n-            fields += record.size();\r\n-        }\r\n-        return new Stats(count, fields);\r\n-    }\r\n-\r\n-    public static void main(final String[] args) throws Exception {\r\n-        if (BIG_FILE.exists()) {\r\n-            System.out.printf(\"Found test fixture %s: %,d bytes.%n\", BIG_FILE, BIG_FILE.length());\r\n-        } else {\r\n-            System.out.println(\"Decompressing test fixture to: \" + BIG_FILE + \"...\");\r\n-            try (InputStream input = new GZIPInputStream(PerformanceTest.class.getClassLoader().getResourceAsStream(TEST_RESRC));\r\n-                    OutputStream output = new FileOutputStream(BIG_FILE)) {\r\n-                IOUtils.copy(input, output);\r\n-                System.out.println(String.format(\"Decompressed test fixture %s: %,d bytes.\", BIG_FILE, BIG_FILE.length()));\r\n-            }\r\n-        }\r\n-        final int argc = args.length;\r\n-        if (argc > 0) {\r\n-            max = Integer.parseInt(args[0]);\r\n-        }\r\n-\r\n-        final String[] tests;\r\n-        if (argc > 1) {\r\n-            tests = new String[argc - 1];\r\n-            System.arraycopy(args, 1, tests, 0, argc - 1);\r\n-        } else {\r\n-            tests = new String[] { \"file\", \"split\", \"extb\", \"exts\", \"csv\", \"csv-path\", \"csv-path-db\", \"csv-url\", \"lexreset\", \"lexnew\" };\r\n-        }\r\n-        for (final String p : PROPERTY_NAMES) {\r\n-            System.out.printf(\"%s=%s%n\", p, System.getProperty(p));\r\n-        }\r\n-        System.out.printf(\"Max count: %d%n%n\", max);\r\n-\r\n-        for (final String test : tests) {\r\n-            switch (test) {\r\n-            case \"file\":\r\n-                testReadBigFile(false);\r\n-                break;\r\n-            case \"split\":\r\n-                testReadBigFile(true);\r\n-                break;\r\n-            case \"csv\":\r\n-                testParseCommonsCSV();\r\n-                break;\r\n-            case \"csv-path\":\r\n-                testParsePath();\r\n-                break;\r\n-            case \"csv-path-db\":\r\n-                testParsePathDoubleBuffering();\r\n-                break;\r\n-            case \"csv-url\":\r\n-                testParseURL();\r\n-                break;\r\n-            case \"lexreset\":\r\n-                testCSVLexer(false, test);\r\n-                break;\r\n-            case \"lexnew\":\r\n-                testCSVLexer(true, test);\r\n-                break;\r\n-            default:\r\n-                if (test.startsWith(\"CSVLexer\")) {\r\n-                    testCSVLexer(false, test);\r\n-                } else if (\"extb\".equals(test)) {\r\n-                    testExtendedBuffer(false);\r\n-                } else if (\"exts\".equals(test)) {\r\n-                    testExtendedBuffer(true);\r\n-                } else {\r\n-                    System.out.printf(\"Invalid test name: %s%n\", test);\r\n-                }\r\n-                break;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private static Stats readAll(final BufferedReader in, final boolean split) throws IOException {\r\n-        int count = 0;\r\n-        int fields = 0;\r\n-        String record;\r\n-        while ((record = in.readLine()) != null) {\r\n-            count++;\r\n-            fields += split ? record.split(\",\").length : 1;\r\n-        }\r\n-        return new Stats(count, fields);\r\n-    }\r\n-\r\n-    // calculate and show average\r\n-    private static void show() {\r\n-        if (num > 1) {\r\n-            long tot = 0;\r\n-            for (int i = 1; i < num; i++) { // skip first test\r\n-                tot += ELAPSED_TIMES[i];\r\n-            }\r\n-            System.out.printf(\"%-20s: %5dms%n%n\", \"Average(not first)\", tot / (num - 1));\r\n-        }\r\n-        num = 0; // ready for next set\r\n-    }\r\n-\r\n-    // Display end stats; store elapsed for average\r\n-    private static void show(final String msg, final Stats s, final long start) {\r\n-        final long elapsed = System.currentTimeMillis() - start;\r\n-        System.out.printf(\"%-20s: %5dms %d lines %d fields%n\", msg, elapsed, s.count, s.fields);\r\n-        ELAPSED_TIMES[num] = elapsed;\r\n-        num++;\r\n-    }\r\n-\r\n-    private static void testCSVLexer(final boolean newToken, final String test) throws Exception {\r\n-        Token token = new Token();\r\n-        String dynamic = \"\";\r\n-        for (int i = 0; i < max; i++) {\r\n-            final String simpleName;\r\n-            final Stats stats;\r\n-            final long startMillis;\r\n-            try (ExtendedBufferedReader input = new ExtendedBufferedReader(createReader());\r\n-                    Lexer lexer = createTestCSVLexer(test, input)) {\r\n-                if (test.startsWith(\"CSVLexer\")) {\r\n-                    dynamic = \"!\";\r\n-                }\r\n-                simpleName = lexer.getClass().getSimpleName();\r\n-                int count = 0;\r\n-                int fields = 0;\r\n-                startMillis = System.currentTimeMillis();\r\n-                do {\r\n-                    if (newToken) {\r\n-                        token = new Token();\r\n-                    } else {\r\n-                        token.reset();\r\n-                    }\r\n-                    lexer.nextToken(token);\r\n-                    switch (token.type) {\r\n-                    case EOF:\r\n-                        break;\r\n-                    case EORECORD:\r\n-                        fields++;\r\n-                        count++;\r\n-                        break;\r\n-                    case INVALID:\r\n-                        throw new IOException(\"invalid parse sequence <\" + token.content.toString() + \">\");\r\n-                    case TOKEN:\r\n-                        fields++;\r\n-                        break;\r\n-                    case COMMENT: // not really expecting these\r\n-                        break;\r\n-                    default:\r\n-                        throw new IllegalStateException(\"Unexpected Token type: \" + token.type);\r\n-                    }\r\n-                } while (!token.type.equals(Token.Type.EOF));\r\n-                stats = new Stats(count, fields);\r\n-            }\r\n-            show(simpleName + dynamic + \" \" + (newToken ? \"new\" : \"reset\"), stats, startMillis);\r\n-        }\r\n-        show();\r\n-    }\r\n-\r\n-    private static void testExtendedBuffer(final boolean makeString) throws Exception {\r\n-        for (int i = 0; i < max; i++) {\r\n-            int fields = 0;\r\n-            int lines = 0;\r\n-            final long startMillis;\r\n-            try (ExtendedBufferedReader in = new ExtendedBufferedReader(createReader())) {\r\n-                startMillis = System.currentTimeMillis();\r\n-                int read;\r\n-                if (makeString) {\r\n-                    StringBuilder sb = new StringBuilder();\r\n-                    while ((read = in.read()) != EOF) {\r\n-                        sb.append((char) read);\r\n-                        if (read == ',') { // count delimiters\r\n-                            sb.toString();\r\n-                            sb = new StringBuilder();\r\n-                            fields++;\r\n-                        } else if (read == '\\n') {\r\n-                            sb.toString();\r\n-                            sb = new StringBuilder();\r\n-                            lines++;\r\n-                        }\r\n-                    }\r\n-                } else {\r\n-                    while ((read = in.read()) != EOF) {\r\n-                        if (read == ',') { // count delimiters\r\n-                            fields++;\r\n-                        } else if (read == '\\n') {\r\n-                            lines++;\r\n-                        }\r\n-                    }\r\n-                }\r\n-                fields += lines; // EOL is a delimiter too\r\n-            }\r\n-            show(\"Extended\" + (makeString ? \" toString\" : \"\"), new Stats(lines, fields), startMillis);\r\n-        }\r\n-        show();\r\n-    }\r\n-\r\n-    private static void testParseCommonsCSV() throws Exception {\r\n-        testParser(\"CSV\", () -> CSVParser.builder().setReader(createReader()).setFormat(format).get());\r\n-    }\r\n-\r\n-    private static void testParsePath() throws Exception {\r\n-        testParser(\"CSV-PATH\", () -> CSVParser.parse(Files.newInputStream(Paths.get(BIG_FILE.toURI())), StandardCharsets.ISO_8859_1, format));\r\n-    }\r\n-\r\n-    private static void testParsePathDoubleBuffering() throws Exception {\r\n-        testParser(\"CSV-PATH-DB\", () -> CSVParser.parse(Files.newBufferedReader(Paths.get(BIG_FILE.toURI()), StandardCharsets.ISO_8859_1), format));\r\n-    }\r\n-\r\n-    private static void testParser(final String msg, final CSVParserFactory fac) throws Exception {\r\n-        for (int i = 0; i < max; i++) {\r\n-            final long startMillis;\r\n-            final Stats stats;\r\n-            try (CSVParser parser = fac.createParser()) {\r\n-                startMillis = System.currentTimeMillis();\r\n-                stats = iterate(parser);\r\n-            }\r\n-            show(msg, stats, startMillis);\r\n-        }\r\n-        show();\r\n-    }\r\n-\r\n-    private static void testParseURL() throws Exception {\r\n-        testParser(\"CSV-URL\", () -> CSVParser.parse(BIG_FILE.toURI().toURL(), StandardCharsets.ISO_8859_1, format));\r\n-    }\r\n-\r\n-    private static void testReadBigFile(final boolean split) throws Exception {\r\n-        for (int i = 0; i < max; i++) {\r\n-            final long startMillis;\r\n-            final Stats stats;\r\n-            try (BufferedReader in = new BufferedReader(createReader())) {\r\n-                startMillis = System.currentTimeMillis();\r\n-                stats = readAll(in, split);\r\n-            }\r\n-            show(split ? \"file+split\" : \"file\", stats, startMillis);\r\n-        }\r\n-        show();\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import static org.apache.commons.io.IOUtils.EOF;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.Reader;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.IOUtils;\n+\n+/**\n+ * Basic test harness.\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class PerformanceTest {\n+\n+    @FunctionalInterface\n+    private interface CSVParserFactory {\n+        CSVParser createParser() throws IOException;\n+    }\n+\n+    // Container for basic statistics\n+    private static final class Stats {\n+        final int count;\n+        final int fields;\n+\n+        Stats(final int c, final int f) {\n+            count = c;\n+            fields = f;\n+        }\n+    }\n+\n+    private static final String[] PROPERTY_NAMES = { \"java.version\", // Java Runtime Environment version\n+            \"java.vendor\", // Java Runtime Environment vendor\n+//        \"java.vm.specification.version\", // Java Virtual Machine specification version\n+//        \"java.vm.specification.vendor\",  // Java Virtual Machine specification vendor\n+//        \"java.vm.specification.name\",    // Java Virtual Machine specification name\n+            \"java.vm.version\", // Java Virtual Machine implementation version\n+//        \"java.vm.vendor\",                // Java Virtual Machine implementation vendor\n+            \"java.vm.name\", // Java Virtual Machine implementation name\n+//        \"java.specification.version\",    // Java Runtime Environment specification version\n+//        \"java.specification.vendor\",     // Java Runtime Environment specification vendor\n+//        \"java.specification.name\",       // Java Runtime Environment specification name\n+\n+            \"os.name\", // Operating system name\n+            \"os.arch\", // Operating system architecture\n+            \"os.version\", // Operating system version\n+    };\n+    private static int max = 11; // skip first test\n+\n+    private static int num; // number of elapsed times recorded\n+\n+    private static final long[] ELAPSED_TIMES = new long[max];\n+    private static final CSVFormat format = CSVFormat.EXCEL;\n+\n+    private static final String TEST_RESRC = \"org/apache/commons/csv/perf/worldcitiespop.txt.gz\";\n+\n+    private static final File BIG_FILE = new File(FileUtils.getTempDirectoryPath(), \"worldcitiespop.txt\");\n+\n+    private static Reader createReader() throws IOException {\n+        return new InputStreamReader(new FileInputStream(BIG_FILE), StandardCharsets.ISO_8859_1);\n+    }\n+\n+    private static Lexer createTestCSVLexer(final String test, final ExtendedBufferedReader input)\n+            throws InstantiationException, IllegalAccessException, InvocationTargetException, Exception {\n+        return test.startsWith(\"CSVLexer\") ? getLexerCtor(test).newInstance(format, input) : new Lexer(format, input);\n+    }\n+\n+    private static Constructor<Lexer> getLexerCtor(final String clazz) throws Exception {\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<Lexer> lexer = (Class<Lexer>) Class.forName(\"org.apache.commons.csv.\" + clazz);\n+        return lexer.getConstructor(CSVFormat.class, ExtendedBufferedReader.class);\n+    }\n+\n+    private static Stats iterate(final Iterable<CSVRecord> iterable) {\n+        int count = 0;\n+        int fields = 0;\n+        for (final CSVRecord record : iterable) {\n+            count++;\n+            fields += record.size();\n+        }\n+        return new Stats(count, fields);\n+    }\n+\n+    public static void main(final String[] args) throws Exception {\n+        if (BIG_FILE.exists()) {\n+            System.out.printf(\"Found test fixture %s: %,d bytes.%n\", BIG_FILE, BIG_FILE.length());\n+        } else {\n+            System.out.println(\"Decompressing test fixture to: \" + BIG_FILE + \"...\");\n+            try (InputStream input = new GZIPInputStream(PerformanceTest.class.getClassLoader().getResourceAsStream(TEST_RESRC));\n+                    OutputStream output = new FileOutputStream(BIG_FILE)) {\n+                IOUtils.copy(input, output);\n+                System.out.println(String.format(\"Decompressed test fixture %s: %,d bytes.\", BIG_FILE, BIG_FILE.length()));\n+            }\n+        }\n+        final int argc = args.length;\n+        if (argc > 0) {\n+            max = Integer.parseInt(args[0]);\n+        }\n+\n+        final String[] tests;\n+        if (argc > 1) {\n+            tests = new String[argc - 1];\n+            System.arraycopy(args, 1, tests, 0, argc - 1);\n+        } else {\n+            tests = new String[] { \"file\", \"split\", \"extb\", \"exts\", \"csv\", \"csv-path\", \"csv-path-db\", \"csv-url\", \"lexreset\", \"lexnew\" };\n+        }\n+        for (final String p : PROPERTY_NAMES) {\n+            System.out.printf(\"%s=%s%n\", p, System.getProperty(p));\n+        }\n+        System.out.printf(\"Max count: %d%n%n\", max);\n+\n+        for (final String test : tests) {\n+            switch (test) {\n+            case \"file\":\n+                testReadBigFile(false);\n+                break;\n+            case \"split\":\n+                testReadBigFile(true);\n+                break;\n+            case \"csv\":\n+                testParseCommonsCSV();\n+                break;\n+            case \"csv-path\":\n+                testParsePath();\n+                break;\n+            case \"csv-path-db\":\n+                testParsePathDoubleBuffering();\n+                break;\n+            case \"csv-url\":\n+                testParseURL();\n+                break;\n+            case \"lexreset\":\n+                testCSVLexer(false, test);\n+                break;\n+            case \"lexnew\":\n+                testCSVLexer(true, test);\n+                break;\n+            default:\n+                if (test.startsWith(\"CSVLexer\")) {\n+                    testCSVLexer(false, test);\n+                } else if (\"extb\".equals(test)) {\n+                    testExtendedBuffer(false);\n+                } else if (\"exts\".equals(test)) {\n+                    testExtendedBuffer(true);\n+                } else {\n+                    System.out.printf(\"Invalid test name: %s%n\", test);\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    private static Stats readAll(final BufferedReader in, final boolean split) throws IOException {\n+        int count = 0;\n+        int fields = 0;\n+        String record;\n+        while ((record = in.readLine()) != null) {\n+            count++;\n+            fields += split ? record.split(\",\").length : 1;\n+        }\n+        return new Stats(count, fields);\n+    }\n+\n+    // calculate and show average\n+    private static void show() {\n+        if (num > 1) {\n+            long tot = 0;\n+            for (int i = 1; i < num; i++) { // skip first test\n+                tot += ELAPSED_TIMES[i];\n+            }\n+            System.out.printf(\"%-20s: %5dms%n%n\", \"Average(not first)\", tot / (num - 1));\n+        }\n+        num = 0; // ready for next set\n+    }\n+\n+    // Display end stats; store elapsed for average\n+    private static void show(final String msg, final Stats s, final long start) {\n+        final long elapsed = System.currentTimeMillis() - start;\n+        System.out.printf(\"%-20s: %5dms %d lines %d fields%n\", msg, elapsed, s.count, s.fields);\n+        ELAPSED_TIMES[num] = elapsed;\n+        num++;\n+    }\n+\n+    private static void testCSVLexer(final boolean newToken, final String test) throws Exception {\n+        Token token = new Token();\n+        String dynamic = \"\";\n+        for (int i = 0; i < max; i++) {\n+            final String simpleName;\n+            final Stats stats;\n+            final long startMillis;\n+            try (ExtendedBufferedReader input = new ExtendedBufferedReader(createReader());\n+                    Lexer lexer = createTestCSVLexer(test, input)) {\n+                if (test.startsWith(\"CSVLexer\")) {\n+                    dynamic = \"!\";\n+                }\n+                simpleName = lexer.getClass().getSimpleName();\n+                int count = 0;\n+                int fields = 0;\n+                startMillis = System.currentTimeMillis();\n+                do {\n+                    if (newToken) {\n+                        token = new Token();\n+                    } else {\n+                        token.reset();\n+                    }\n+                    lexer.nextToken(token);\n+                    switch (token.type) {\n+                    case EOF:\n+                        break;\n+                    case EORECORD:\n+                        fields++;\n+                        count++;\n+                        break;\n+                    case INVALID:\n+                        throw new IOException(\"invalid parse sequence <\" + token.content.toString() + \">\");\n+                    case TOKEN:\n+                        fields++;\n+                        break;\n+                    case COMMENT: // not really expecting these\n+                        break;\n+                    default:\n+                        throw new IllegalStateException(\"Unexpected Token type: \" + token.type);\n+                    }\n+                } while (!token.type.equals(Token.Type.EOF));\n+                stats = new Stats(count, fields);\n+            }\n+            show(simpleName + dynamic + \" \" + (newToken ? \"new\" : \"reset\"), stats, startMillis);\n+        }\n+        show();\n+    }\n+\n+    private static void testExtendedBuffer(final boolean makeString) throws Exception {\n+        for (int i = 0; i < max; i++) {\n+            int fields = 0;\n+            int lines = 0;\n+            final long startMillis;\n+            try (ExtendedBufferedReader in = new ExtendedBufferedReader(createReader())) {\n+                startMillis = System.currentTimeMillis();\n+                int read;\n+                if (makeString) {\n+                    StringBuilder sb = new StringBuilder();\n+                    while ((read = in.read()) != EOF) {\n+                        sb.append((char) read);\n+                        if (read == ',') { // count delimiters\n+                            sb.toString();\n+                            sb = new StringBuilder();\n+                            fields++;\n+                        } else if (read == '\\n') {\n+                            sb.toString();\n+                            sb = new StringBuilder();\n+                            lines++;\n+                        }\n+                    }\n+                } else {\n+                    while ((read = in.read()) != EOF) {\n+                        if (read == ',') { // count delimiters\n+                            fields++;\n+                        } else if (read == '\\n') {\n+                            lines++;\n+                        }\n+                    }\n+                }\n+                fields += lines; // EOL is a delimiter too\n+            }\n+            show(\"Extended\" + (makeString ? \" toString\" : \"\"), new Stats(lines, fields), startMillis);\n+        }\n+        show();\n+    }\n+\n+    private static void testParseCommonsCSV() throws Exception {\n+        testParser(\"CSV\", () -> CSVParser.builder().setReader(createReader()).setFormat(format).get());\n+    }\n+\n+    private static void testParsePath() throws Exception {\n+        testParser(\"CSV-PATH\", () -> CSVParser.parse(Files.newInputStream(Paths.get(BIG_FILE.toURI())), StandardCharsets.ISO_8859_1, format));\n+    }\n+\n+    private static void testParsePathDoubleBuffering() throws Exception {\n+        testParser(\"CSV-PATH-DB\", () -> CSVParser.parse(Files.newBufferedReader(Paths.get(BIG_FILE.toURI()), StandardCharsets.ISO_8859_1), format));\n+    }\n+\n+    private static void testParser(final String msg, final CSVParserFactory fac) throws Exception {\n+        for (int i = 0; i < max; i++) {\n+            final long startMillis;\n+            final Stats stats;\n+            try (CSVParser parser = fac.createParser()) {\n+                startMillis = System.currentTimeMillis();\n+                stats = iterate(parser);\n+            }\n+            show(msg, stats, startMillis);\n+        }\n+        show();\n+    }\n+\n+    private static void testParseURL() throws Exception {\n+        testParser(\"CSV-URL\", () -> CSVParser.parse(BIG_FILE.toURI().toURL(), StandardCharsets.ISO_8859_1, format));\n+    }\n+\n+    private static void testReadBigFile(final boolean split) throws Exception {\n+        for (int i = 0; i < max; i++) {\n+            final long startMillis;\n+            final Stats stats;\n+            try (BufferedReader in = new BufferedReader(createReader())) {\n+                startMillis = System.currentTimeMillis();\n+                stats = readAll(in, split);\n+            }\n+            show(split ? \"file+split\" : \"file\", stats, startMillis);\n+        }\n+        show();\n+    }\n+}\n+\n\ndiff --git a/src/test/java/org/apache/commons/csv/issues/JiraCsv198Test.java b/src/test/java/org/apache/commons/csv/issues/JiraCsv198Test.java\nindex cee88f15..641797fe 100644\n--- a/src/test/java/org/apache/commons/csv/issues/JiraCsv198Test.java\n+++ b/src/test/java/org/apache/commons/csv/issues/JiraCsv198Test.java\n@@ -1,54 +1,54 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv.issues;\r\n-\r\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.InputStreamReader;\r\n-import java.io.UnsupportedEncodingException;\r\n-import java.nio.charset.StandardCharsets;\r\n-\r\n-import org.apache.commons.csv.CSVFormat;\r\n-import org.apache.commons.csv.CSVParser;\r\n-import org.junit.jupiter.api.Test;\r\n-\r\n-public class JiraCsv198Test {\r\n-\r\n-    // @formatter:off\r\n-    private static final CSVFormat CSV_FORMAT = CSVFormat.EXCEL.builder()\r\n-        .setDelimiter('^')\r\n-        .setHeader()\r\n-        .setSkipHeaderRecord(true)\r\n-        .get();\r\n-    // @formatter:on\r\n-\r\n-    @Test\r\n-    public void test() throws UnsupportedEncodingException, IOException {\r\n-        final InputStream pointsOfReference = getClass().getResourceAsStream(\"/org/apache/commons/csv/CSV-198/optd_por_public.csv\");\r\n-        assertNotNull(pointsOfReference);\r\n-        try (@SuppressWarnings(\"resource\")\r\n-        CSVParser parser = CSV_FORMAT.parse(new InputStreamReader(pointsOfReference, StandardCharsets.UTF_8))) {\r\n-            parser.forEach(record -> assertNotNull(record.get(\"location_type\")));\r\n-        }\r\n-    }\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv.issues;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.commons.csv.CSVFormat;\n+import org.apache.commons.csv.CSVParser;\n+import org.junit.jupiter.api.Test;\n+\n+public class JiraCsv198Test {\n+\n+    // @formatter:off\n+    private static final CSVFormat CSV_FORMAT = CSVFormat.EXCEL.builder()\n+        .setDelimiter('^')\n+        .setHeader()\n+        .setSkipHeaderRecord(true)\n+        .get();\n+    // @formatter:on\n+\n+    @Test\n+    public void test() throws UnsupportedEncodingException, IOException {\n+        final InputStream pointsOfReference = getClass().getResourceAsStream(\"/org/apache/commons/csv/CSV-198/optd_por_public.csv\");\n+        assertNotNull(pointsOfReference);\n+        try (@SuppressWarnings(\"resource\")\n+        CSVParser parser = CSV_FORMAT.parse(new InputStreamReader(pointsOfReference, StandardCharsets.UTF_8))) {\n+            parser.forEach(record -> assertNotNull(record.get(\"location_type\")));\n+        }\n+    }\n+\n+}\n\ndiff --git a/src/test/java/org/apache/commons/csv/issues/JiraCsv211Test.java b/src/test/java/org/apache/commons/csv/issues/JiraCsv211Test.java\nindex 9da17465..a4e3960c 100644\n--- a/src/test/java/org/apache/commons/csv/issues/JiraCsv211Test.java\n+++ b/src/test/java/org/apache/commons/csv/issues/JiraCsv211Test.java\n@@ -1,54 +1,54 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv.issues;\r\n-\r\n-import static org.junit.jupiter.api.Assertions.assertEquals;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.StringReader;\r\n-\r\n-import org.apache.commons.csv.CSVFormat;\r\n-import org.apache.commons.csv.CSVParser;\r\n-import org.junit.jupiter.api.Test;\r\n-\r\n-public class JiraCsv211Test {\r\n-\r\n-    @Test\r\n-    public void testJiraCsv211Format() throws IOException {\r\n-        // @formatter:off\r\n-        final CSVFormat printFormat = CSVFormat.DEFAULT.builder()\r\n-            .setDelimiter('\\t')\r\n-            .setHeader(\"ID\", \"Name\", \"Country\", \"Age\")\r\n-            .get();\r\n-        // @formatter:on\r\n-        final String formatted = printFormat.format(\"1\", \"Jane Doe\", \"USA\", \"\");\r\n-        assertEquals(\"ID\\tName\\tCountry\\tAge\\r\\n1\\tJane Doe\\tUSA\\t\", formatted);\r\n-\r\n-        final CSVFormat parseFormat = CSVFormat.DEFAULT.builder().setDelimiter('\\t').setHeader().setSkipHeaderRecord(true).get();\r\n-        try (CSVParser parser = parseFormat.parse(new StringReader(formatted))) {\r\n-            parser.forEach(record -> {\r\n-                assertEquals(\"1\", record.get(0));\r\n-                assertEquals(\"Jane Doe\", record.get(1));\r\n-                assertEquals(\"USA\", record.get(2));\r\n-                assertEquals(\"\", record.get(3));\r\n-            });\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv.issues;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+\n+import org.apache.commons.csv.CSVFormat;\n+import org.apache.commons.csv.CSVParser;\n+import org.junit.jupiter.api.Test;\n+\n+public class JiraCsv211Test {\n+\n+    @Test\n+    public void testJiraCsv211Format() throws IOException {\n+        // @formatter:off\n+        final CSVFormat printFormat = CSVFormat.DEFAULT.builder()\n+            .setDelimiter('\\t')\n+            .setHeader(\"ID\", \"Name\", \"Country\", \"Age\")\n+            .get();\n+        // @formatter:on\n+        final String formatted = printFormat.format(\"1\", \"Jane Doe\", \"USA\", \"\");\n+        assertEquals(\"ID\\tName\\tCountry\\tAge\\r\\n1\\tJane Doe\\tUSA\\t\", formatted);\n+\n+        final CSVFormat parseFormat = CSVFormat.DEFAULT.builder().setDelimiter('\\t').setHeader().setSkipHeaderRecord(true).get();\n+        try (CSVParser parser = parseFormat.parse(new StringReader(formatted))) {\n+            parser.forEach(record -> {\n+                assertEquals(\"1\", record.get(0));\n+                assertEquals(\"Jane Doe\", record.get(1));\n+                assertEquals(\"USA\", record.get(2));\n+                assertEquals(\"\", record.get(3));\n+            });\n+        }\n+    }\n+}\n\ndiff --git a/src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java b/src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java\nindex 4e614816..0be6a52f 100644\n--- a/src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java\n+++ b/src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java\n@@ -1,216 +1,216 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   https://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-package org.apache.commons.csv.issues;\r\n-\r\n-import static org.junit.jupiter.api.Assertions.assertEquals;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.Reader;\r\n-import java.io.StringReader;\r\n-\r\n-import org.apache.commons.csv.CSVFormat;\r\n-import org.apache.commons.csv.CSVParser;\r\n-import org.apache.commons.csv.CSVPrinter;\r\n-import org.apache.commons.csv.CSVRecord;\r\n-import org.junit.jupiter.api.Test;\r\n-\r\n-public class JiraCsv288Test {\r\n-\r\n-    private void print(final CSVRecord csvRecord, final CSVPrinter csvPrinter) throws IOException {\r\n-        for (final String value : csvRecord) {\r\n-            csvPrinter.print(value);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Before fix:\r\n-    // expected: <a,b,c,d,,f> but was: <a,b,c,d,|f>\r\n-    public void testParseWithABADelimiter() throws Exception {\r\n-        final Reader in = new StringReader(\"a|~|b|~|c|~|d|~||~|f\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser parser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"|~|\").get())) {\r\n-            for (final CSVRecord csvRecord : parser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Before fix:\r\n-    // expected: <a,b,c,d,,f> but was: <a,b|c,d,|f>\r\n-    public void testParseWithDoublePipeDelimiter() throws Exception {\r\n-        final Reader in = new StringReader(\"a||b||c||d||||f\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Regression, already passed before fix\r\n-\r\n-    public void testParseWithDoublePipeDelimiterDoubleCharValue() throws Exception {\r\n-        final Reader in = new StringReader(\"a||bb||cc||dd||f\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,bb,cc,dd,f\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Before fix:\r\n-    // expected: <a,b,c,d,,f,> but was: <a,b|c,d,|f>\r\n-    public void testParseWithDoublePipeDelimiterEndsWithDelimiter() throws Exception {\r\n-        final Reader in = new StringReader(\"a||b||c||d||||f||\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f,\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Before fix:\r\n-    // expected: <a,b||c,d,,f> but was: <a,b||c,d,|f>\r\n-    public void testParseWithDoublePipeDelimiterQuoted() throws Exception {\r\n-        final Reader in = new StringReader(\"a||\\\"b||c\\\"||d||||f\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b||c,d,,f\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Regression, already passed before fix\r\n-    public void testParseWithSinglePipeDelimiterEndsWithDelimiter() throws Exception {\r\n-        final Reader in = new StringReader(\"a|b|c|d||f|\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"|\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f,\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Before fix:\r\n-    // expected: <a,b,c,d,,f> but was: <a,b|c,d,|f>\r\n-    public void testParseWithTriplePipeDelimiter() throws Exception {\r\n-        final Reader in = new StringReader(\"a|||b|||c|||d||||||f\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"|||\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Regression, already passed before fix\r\n-    public void testParseWithTwoCharDelimiter1() throws Exception {\r\n-        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Regression, already passed before fix\r\n-    public void testParseWithTwoCharDelimiter2() throws Exception {\r\n-        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f~\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f~\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Regression, already passed before fix\r\n-    public void testParseWithTwoCharDelimiter3() throws Exception {\r\n-        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f|\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f|\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Regression, already passed before fix\r\n-    public void testParseWithTwoCharDelimiter4() throws Exception {\r\n-        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f~~||g\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f~,|g\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    // Before fix:\r\n-    // expected: <a,b,c,d,,f,> but was: <a,b,c,d,,f>\r\n-    public void testParseWithTwoCharDelimiterEndsWithDelimiter() throws Exception {\r\n-        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f~|\");\r\n-        final StringBuilder stringBuilder = new StringBuilder();\r\n-        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n-                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\r\n-            for (final CSVRecord csvRecord : csvParser) {\r\n-                print(csvRecord, csvPrinter);\r\n-                assertEquals(\"a,b,c,d,,f,\", stringBuilder.toString());\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.csv.issues;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+\n+import org.apache.commons.csv.CSVFormat;\n+import org.apache.commons.csv.CSVParser;\n+import org.apache.commons.csv.CSVPrinter;\n+import org.apache.commons.csv.CSVRecord;\n+import org.junit.jupiter.api.Test;\n+\n+public class JiraCsv288Test {\n+\n+    private void print(final CSVRecord csvRecord, final CSVPrinter csvPrinter) throws IOException {\n+        for (final String value : csvRecord) {\n+            csvPrinter.print(value);\n+        }\n+    }\n+\n+    @Test\n+    // Before fix:\n+    // expected: <a,b,c,d,,f> but was: <a,b,c,d,|f>\n+    public void testParseWithABADelimiter() throws Exception {\n+        final Reader in = new StringReader(\"a|~|b|~|c|~|d|~||~|f\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser parser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"|~|\").get())) {\n+            for (final CSVRecord csvRecord : parser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Before fix:\n+    // expected: <a,b,c,d,,f> but was: <a,b|c,d,|f>\n+    public void testParseWithDoublePipeDelimiter() throws Exception {\n+        final Reader in = new StringReader(\"a||b||c||d||||f\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Regression, already passed before fix\n+\n+    public void testParseWithDoublePipeDelimiterDoubleCharValue() throws Exception {\n+        final Reader in = new StringReader(\"a||bb||cc||dd||f\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,bb,cc,dd,f\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Before fix:\n+    // expected: <a,b,c,d,,f,> but was: <a,b|c,d,|f>\n+    public void testParseWithDoublePipeDelimiterEndsWithDelimiter() throws Exception {\n+        final Reader in = new StringReader(\"a||b||c||d||||f||\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f,\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Before fix:\n+    // expected: <a,b||c,d,,f> but was: <a,b||c,d,|f>\n+    public void testParseWithDoublePipeDelimiterQuoted() throws Exception {\n+        final Reader in = new StringReader(\"a||\\\"b||c\\\"||d||||f\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"||\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b||c,d,,f\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Regression, already passed before fix\n+    public void testParseWithSinglePipeDelimiterEndsWithDelimiter() throws Exception {\n+        final Reader in = new StringReader(\"a|b|c|d||f|\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"|\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f,\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Before fix:\n+    // expected: <a,b,c,d,,f> but was: <a,b|c,d,|f>\n+    public void testParseWithTriplePipeDelimiter() throws Exception {\n+        final Reader in = new StringReader(\"a|||b|||c|||d||||||f\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"|||\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Regression, already passed before fix\n+    public void testParseWithTwoCharDelimiter1() throws Exception {\n+        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Regression, already passed before fix\n+    public void testParseWithTwoCharDelimiter2() throws Exception {\n+        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f~\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f~\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Regression, already passed before fix\n+    public void testParseWithTwoCharDelimiter3() throws Exception {\n+        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f|\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f|\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Regression, already passed before fix\n+    public void testParseWithTwoCharDelimiter4() throws Exception {\n+        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f~~||g\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f~,|g\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    // Before fix:\n+    // expected: <a,b,c,d,,f,> but was: <a,b,c,d,,f>\n+    public void testParseWithTwoCharDelimiterEndsWithDelimiter() throws Exception {\n+        final Reader in = new StringReader(\"a~|b~|c~|d~|~|f~|\");\n+        final StringBuilder stringBuilder = new StringBuilder();\n+        try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\n+                CSVParser csvParser = CSVParser.parse(in, CSVFormat.Builder.create().setDelimiter(\"~|\").get())) {\n+            for (final CSVRecord csvRecord : csvParser) {\n+                print(csvRecord, csvPrinter);\n+                assertEquals(\"a,b,c,d,,f,\", stringBuilder.toString());\n+            }\n+        }\n+    }\n+}",
    "stats": {
      "source_files": 8,
      "test_files": 7,
      "filtered": true
    }
  },
  "has_method_changes": true,
  "v1_execution": {
    "version": "v1",
    "commit_used": "2bf6e53e95cc6094f584fe748847fd847b3eafd2",
    "build": {
      "success": true,
      "duration_seconds": 14.932558,
      "command": "mvn compile -DskipTests",
      "return_code": 0,
      "stdout": "",
      "stderr": ""
    },
    "test": {
      "success": true,
      "duration_seconds": 60.062436,
      "total_tests": 0,
      "passed": 0,
      "failed": 0,
      "skipped": 0,
      "errors": 0,
      "failed_tests": [],
      "error_tests": [],
      "return_code": -1,
      "stdout": "",
      "stderr": ""
    },
    "coverage": {
      "available": true,
      "jacoco_report_path": "/tmp/tubench_analysis_worktrees/commons-csv_441922/commons-csv_2bf6e53e_v1_20260123_145947_360229/target/site/jacoco/jacoco.xml",
      "method_coverage": {
        "total_methods": 12,
        "covered_methods": 12,
        "coverage_ratio": 1.0,
        "details": [
          {
            "method": "org.apache.commons.csv.CSVPrinter.close",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.endOfRecord",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.flush",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.getOut",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.getRecordCount",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.print",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.printComment",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.printHeaders",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.println",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.printRecord",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.printRecordObject",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.printRecords",
            "covered": true
          }
        ]
      },
      "line_coverage": 0.9950248756218906,
      "covered_lines": 1200,
      "total_lines": 1206
    },
    "worktree_path": "/tmp/tubench_analysis_worktrees/commons-csv_441922/commons-csv_2bf6e53e_v1_20260123_145947_360229"
  },
  "v05_execution": {
    "version": "v05",
    "commit_used": "2bf6e53e95cc6094f584fe748847fd847b3eafd2",
    "build": {
      "success": true,
      "duration_seconds": 15.209634,
      "command": "mvn compile -DskipTests",
      "return_code": 0,
      "stdout": "",
      "stderr": ""
    },
    "test": {
      "success": true,
      "duration_seconds": 60.250677,
      "total_tests": 0,
      "passed": 0,
      "failed": 0,
      "skipped": 0,
      "errors": 0,
      "failed_tests": [],
      "error_tests": [],
      "return_code": -1,
      "stdout": "",
      "stderr": ""
    },
    "coverage": {
      "available": true,
      "jacoco_report_path": "/tmp/tubench_analysis_worktrees/commons-csv_441922/commons-csv_2bf6e53e_v05_20260123_145947_364059/target/site/jacoco/jacoco.xml",
      "method_coverage": {
        "total_methods": 12,
        "covered_methods": 12,
        "coverage_ratio": 1.0,
        "details": [
          {
            "method": "org.apache.commons.csv.CSVPrinter.close",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.endOfRecord",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.flush",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.getOut",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.getRecordCount",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.print",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.printComment",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.printHeaders",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.println",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.printRecord",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.printRecordObject",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.printRecords",
            "covered": true
          }
        ]
      },
      "line_coverage": 0.9950248756218906,
      "covered_lines": 1200,
      "total_lines": 1206
    },
    "worktree_path": "/tmp/tubench_analysis_worktrees/commons-csv_441922/commons-csv_2bf6e53e_v05_20260123_145947_364059",
    "patch_applied": true
  },
  "t05_execution": {
    "version": "t05",
    "commit_used": "2bf6e53e95cc6094f584fe748847fd847b3eafd2",
    "build": {
      "success": false,
      "error_message": "Failed to apply patch: [Errno 7] Argument list too long: '/bin/sh'"
    },
    "test": {
      "success": false
    },
    "coverage": {
      "available": false
    },
    "worktree_path": "/tmp/tubench_analysis_worktrees/commons-csv_441922/commons-csv_2bf6e53e_t05_20260123_145947_365342",
    "patch_applied": false
  },
  "v0_execution": {
    "version": "v0",
    "commit_used": "669023ac454642c34181d82b678539f2a020b3a0",
    "build": {
      "success": true,
      "duration_seconds": 15.304125,
      "command": "mvn compile -DskipTests",
      "return_code": 0,
      "stdout": "",
      "stderr": ""
    },
    "test": {
      "success": true,
      "duration_seconds": 60.223266,
      "total_tests": 0,
      "passed": 0,
      "failed": 0,
      "skipped": 0,
      "errors": 0,
      "failed_tests": [],
      "error_tests": [],
      "return_code": -1,
      "stdout": "",
      "stderr": ""
    },
    "coverage": {
      "available": true,
      "jacoco_report_path": "/tmp/tubench_analysis_worktrees/commons-csv_441922/commons-csv_669023ac_v0_20260123_145947_366204/target/site/jacoco/jacoco.xml",
      "method_coverage": {
        "total_methods": 12,
        "covered_methods": 12,
        "coverage_ratio": 1.0,
        "details": [
          {
            "method": "org.apache.commons.csv.CSVPrinter.close",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.endOfRecord",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.flush",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.getOut",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.getRecordCount",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.print",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.printComment",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.printHeaders",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.println",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.printRecord",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.printRecordObject",
            "covered": true
          },
          {
            "method": "org.apache.commons.csv.CSVPrinter.printRecords",
            "covered": true
          }
        ]
      },
      "line_coverage": 0.9950248756218906,
      "covered_lines": 1200,
      "total_lines": 1206
    },
    "worktree_path": "/tmp/tubench_analysis_worktrees/commons-csv_441922/commons-csv_669023ac_v0_20260123_145947_366204"
  },
  "classification": {
    "scenario": "C",
    "scenario_description": "V-0.5T-0.5",
    "type1_execution_error": {
      "detected": false,
      "subtype": null,
      "confidence": null,
      "evidence": {}
    },
    "type2_coverage_decrease": {
      "detected": false,
      "confidence": null,
      "evidence": {}
    },
    "type3_adaptive_change": {
      "detected": true,
      "confidence": "high",
      "evidence": {
        "reason": "Type1Type2",
        "scenario": "C",
        "scenario_meaning": ""
      }
    },
    "all_types": [
      "type3_adaptive_change"
    ],
    "primary_type": "type3_adaptive_change",
    "types_count": 1
  },
  "qualified": true,
  "analysis_timestamp": "2026-01-23T15:01:03.075133"
}