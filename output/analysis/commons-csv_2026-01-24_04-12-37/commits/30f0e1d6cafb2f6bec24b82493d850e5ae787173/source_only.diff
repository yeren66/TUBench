diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index c245957e..8632cf78 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -46,6 +46,9 @@
       <action type="fix" dev="ggregory" due-to="Gary Gregory">Remove -nouses directive from maven-bundle-plugin. OSGi package imports now state 'uses' definitions for package imports, this doesn't affect JPMS (from org.apache.commons:commons-parent:80).</action>
       <!-- ADD -->
       <action type="add" dev="ggregory" due-to="Gary Gregory">Define and use Maven property commons.jmh.version.</action> 
+      <action type="add" dev="ggregory" due-to="Gary Gregory">Add CSVFormat.Builder.setMaxRows(long).</action> 
+      <action type="add" dev="ggregory" due-to="Gary Gregory">Add CSVFormat.getMaxRows().</action> 
+      <action type="add" dev="ggregory" due-to="Gary Gregory">CSVPrinter.printRecords(ResultSet) knows how to use CSVFormat's maxRows.</action> 
       <!-- UPDATE -->
       <action type="update" dev="ggregory" due-to="Gary Gregory">Bump com.opencsv:opencsv from 5.9 to 5.10.</action>
       <action type="update" dev="ggregory" due-to="Gary Gregory">Bump commons-codec:commons-codec from 1.17.2 to 1.18.0 #522.</action>

diff --git a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java
index 70c033a1..ea1613ba 100644
--- a/src/main/java/org/apache/commons/csv/CSVFormat.java
+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java
@@ -270,32 +270,36 @@ public final class CSVFormat implements Serializable {
 
         private boolean trim;
 
+        /** The maximum number of rows to process, excluding the header row. */
+        private long maxRows;
+
         private Builder() {
             // empty
         }
 
         private Builder(final CSVFormat csvFormat) {
-            this.delimiter = csvFormat.delimiter;
-            this.quoteCharacter = csvFormat.quoteCharacter;
-            this.quoteMode = csvFormat.quoteMode;
+            this.allowMissingColumnNames = csvFormat.allowMissingColumnNames;
+            this.autoFlush = csvFormat.autoFlush;
             this.commentMarker = csvFormat.commentMarker;
+            this.delimiter = csvFormat.delimiter;
+            this.duplicateHeaderMode = csvFormat.duplicateHeaderMode;
             this.escapeCharacter = csvFormat.escapeCharacter;
-            this.ignoreSurroundingSpaces = csvFormat.ignoreSurroundingSpaces;
-            this.allowMissingColumnNames = csvFormat.allowMissingColumnNames;
-            this.ignoreEmptyLines = csvFormat.ignoreEmptyLines;
-            this.recordSeparator = csvFormat.recordSeparator;
-            this.nullString = csvFormat.nullString;
             this.headerComments = csvFormat.headerComments;
             this.headers = csvFormat.headers;
-            this.skipHeaderRecord = csvFormat.skipHeaderRecord;
+            this.ignoreEmptyLines = csvFormat.ignoreEmptyLines;
             this.ignoreHeaderCase = csvFormat.ignoreHeaderCase;
+            this.ignoreSurroundingSpaces = csvFormat.ignoreSurroundingSpaces;
             this.lenientEof = csvFormat.lenientEof;
+            this.maxRows = csvFormat.maxRows;
+            this.nullString = csvFormat.nullString;
+            this.quoteCharacter = csvFormat.quoteCharacter;
+            this.quoteMode = csvFormat.quoteMode;
+            this.quotedNullString = csvFormat.quotedNullString;
+            this.recordSeparator = csvFormat.recordSeparator;
+            this.skipHeaderRecord = csvFormat.skipHeaderRecord;
             this.trailingData = csvFormat.trailingData;
             this.trailingDelimiter = csvFormat.trailingDelimiter;
             this.trim = csvFormat.trim;
-            this.autoFlush = csvFormat.autoFlush;
-            this.quotedNullString = csvFormat.quotedNullString;
-            this.duplicateHeaderMode = csvFormat.duplicateHeaderMode;
         }
 
         /**
@@ -738,6 +742,18 @@ public final class CSVFormat implements Serializable {
             return this;
         }
 
+        /**
+         * Sets the maximum number of rows to process, excluding the header row.
+         *
+         * @param maxRows the maximum number of rows to process, excluding the header row.
+         * @return This instance.
+         * @since 1.14.0
+         */
+        public Builder setMaxRows(final long maxRows) {
+            this.maxRows = maxRows;
+            return this;
+        }
+
         /**
          * Sets the String to convert to and from {@code null}. No substitution occurs if {@code null}.
          *
@@ -857,6 +873,7 @@ public final class CSVFormat implements Serializable {
             return this;
         }
 
+
         /**
          * Sets whether to trim leading and trailing blanks.
          *
@@ -1580,28 +1597,32 @@ public final class CSVFormat implements Serializable {
     /** Whether to trim leading and trailing blanks. */
     private final boolean trim;
 
+    /** The maximum number of rows to process, excluding the header row. */
+    private final long maxRows;
+
     private CSVFormat(final Builder builder) {
-        this.delimiter = builder.delimiter;
-        this.quoteCharacter = builder.quoteCharacter;
-        this.quoteMode = builder.quoteMode;
+        this.allowMissingColumnNames = builder.allowMissingColumnNames;
+        this.autoFlush = builder.autoFlush;
         this.commentMarker = builder.commentMarker;
+        this.delimiter = builder.delimiter;
+        this.duplicateHeaderMode = builder.duplicateHeaderMode;
         this.escapeCharacter = builder.escapeCharacter;
-        this.ignoreSurroundingSpaces = builder.ignoreSurroundingSpaces;
-        this.allowMissingColumnNames = builder.allowMissingColumnNames;
-        this.ignoreEmptyLines = builder.ignoreEmptyLines;
-        this.recordSeparator = builder.recordSeparator;
-        this.nullString = builder.nullString;
         this.headerComments = builder.headerComments;
         this.headers = builder.headers;
-        this.skipHeaderRecord = builder.skipHeaderRecord;
+        this.ignoreEmptyLines = builder.ignoreEmptyLines;
         this.ignoreHeaderCase = builder.ignoreHeaderCase;
+        this.ignoreSurroundingSpaces = builder.ignoreSurroundingSpaces;
         this.lenientEof = builder.lenientEof;
+        this.maxRows = builder.maxRows;
+        this.nullString = builder.nullString;
+        this.quoteCharacter = builder.quoteCharacter;
+        this.quoteMode = builder.quoteMode;
+        this.quotedNullString = builder.quotedNullString;
+        this.recordSeparator = builder.recordSeparator;
+        this.skipHeaderRecord = builder.skipHeaderRecord;
         this.trailingData = builder.trailingData;
         this.trailingDelimiter = builder.trailingDelimiter;
         this.trim = builder.trim;
-        this.autoFlush = builder.autoFlush;
-        this.quotedNullString = builder.quotedNullString;
-        this.duplicateHeaderMode = builder.duplicateHeaderMode;
         validate();
     }
 
@@ -1898,6 +1919,16 @@ public final class CSVFormat implements Serializable {
         return lenientEof;
     }
 
+    /**
+     * Gets the maximum number of rows to process, excluding the header row.
+     *
+     * @return The maximum number of rows to process, excluding the header row.
+     * @since 1.14.0
+     */
+    public long getMaxRows() {
+        return maxRows;
+    }
+
     /**
      * Gets the String to convert to and from {@code null}.
      * <ul>
@@ -1982,10 +2013,9 @@ public final class CSVFormat implements Serializable {
         int result = 1;
         result = prime * result + Arrays.hashCode(headerComments);
         result = prime * result + Arrays.hashCode(headers);
-        result = prime * result + Objects.hash(allowMissingColumnNames, autoFlush, commentMarker, delimiter, duplicateHeaderMode, escapeCharacter,
+        return prime * result + Objects.hash(allowMissingColumnNames, autoFlush, commentMarker, delimiter, duplicateHeaderMode, escapeCharacter,
                 ignoreEmptyLines, ignoreHeaderCase, ignoreSurroundingSpaces, lenientEof, nullString, quoteCharacter, quoteMode, quotedNullString,
                 recordSeparator, skipHeaderRecord, trailingData, trailingDelimiter, trim);
-        return result;
     }
 
     /**

diff --git a/src/main/java/org/apache/commons/csv/CSVPrinter.java b/src/main/java/org/apache/commons/csv/CSVPrinter.java
index 67088c38..a09e0b63 100644
--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java
+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java
@@ -32,6 +32,7 @@ import java.sql.Blob;
 import java.sql.Clob;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.sql.Statement;
 import java.util.Arrays;
 import java.util.Objects;
 import java.util.stream.Stream;
@@ -428,17 +429,19 @@ public final class CSVPrinter implements Flushable, Closeable {
 
     /**
      * Prints all the objects in the given JDBC result set.
+     * <p>
+     * You can use {@link CSVFormat.Builder#setMaxRows(long)} to limit how many rows a result set produces. This is most useful when you cannot limit rows
+     * through {@link Statement#setLargeMaxRows(long)}.
+     * </p>
      *
-     * @param resultSet
-     *             The values to print.
-     * @throws IOException
-     *             If an I/O error occurs.
-     * @throws SQLException
-     *             Thrown when a database access error occurs.
+     * @param resultSet The values to print.
+     * @throws IOException  If an I/O error occurs.
+     * @throws SQLException Thrown when a database access error occurs.
      */
     public void printRecords(final ResultSet resultSet) throws SQLException, IOException {
         final int columnCount = resultSet.getMetaData().getColumnCount();
-        while (resultSet.next()) {
+        final long maxRows = format.getMaxRows();
+        while (resultSet.next() && (maxRows < 1 || resultSet.getRow() <= maxRows)) {
             for (int i = 1; i <= columnCount; i++) {
                 final Object object = resultSet.getObject(i);
                 if (object instanceof Clob) {
@@ -459,6 +462,10 @@ public final class CSVPrinter implements Flushable, Closeable {
 
     /**
      * Prints all the objects with metadata in the given JDBC result set based on the header boolean.
+     * <p>
+     * You can use {@link CSVFormat.Builder#setMaxRows(long)} to limit how many rows a result set produces. This is most useful when you cannot limit rows
+     * through {@link Statement#setLargeMaxRows(long)}.
+     * </p>
      *
      * @param resultSet source of row data.
      * @param printHeader whether to print headers.
