diff --git a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java
index a7067657..1c88d9c7 100644
--- a/src/main/java/org/apache/commons/csv/CSVParser.java
+++ b/src/main/java/org/apache/commons/csv/CSVParser.java
@@ -155,7 +155,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {
         private CSVFormat format;
         private long characterOffset;
         private long recordNumber = 1;
-        private boolean enableByteTracking;
+        private boolean trackBytes;
 
         /**
          * Constructs a new instance.
@@ -167,7 +167,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {
         @SuppressWarnings("resource")
         @Override
         public CSVParser get() throws IOException {
-            return new CSVParser(getReader(), format != null ? format : CSVFormat.DEFAULT, characterOffset, recordNumber, getCharset(), enableByteTracking);
+            return new CSVParser(getReader(), format != null ? format : CSVFormat.DEFAULT, characterOffset, recordNumber, getCharset(), trackBytes);
         }
 
         /**
@@ -181,18 +181,6 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {
             return asThis();
         }
 
-        /**
-         * Sets whether to enable byte tracking for the parser.
-         *
-         * @param enableByteTracking {@code true} to enable byte tracking; {@code false} to disable it.
-         * @return this instance.
-         * @since 1.13.0
-         */
-        public Builder setEnableByteTracking(final boolean enableByteTracking) {
-            this.enableByteTracking = enableByteTracking;
-            return asThis();
-        }
-
         /**
          * Sets the CSV format. A copy of the given format is kept.
          *
@@ -215,6 +203,18 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {
             return asThis();
         }
 
+        /**
+         * Sets whether to enable byte tracking for the parser.
+         *
+         * @param trackBytes {@code true} to enable byte tracking; {@code false} to disable it.
+         * @return this instance.
+         * @since 1.13.0
+         */
+        public Builder setTrackBytes(final boolean trackBytes) {
+            this.trackBytes = trackBytes;
+            return asThis();
+        }
+
     }
 
     final class CSVRecordIterator implements Iterator<CSVRecord> {
@@ -544,7 +544,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {
      *            The next record number to assign.
      * @param charset
      *            The character encoding to be used for the reader when enableByteTracking is true.
-     * @param enableByteTracking
+     * @param trackBytes
      *           {@code true} to enable byte tracking for the parser; {@code false} to disable it.
      * @throws IllegalArgumentException
      *             If the parameters of the format are inconsistent or if either the reader or format is null.
@@ -553,12 +553,12 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {
      * @throws CSVException Thrown on invalid input.
      */
     private CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber,
-        final Charset charset, final boolean enableByteTracking)
+        final Charset charset, final boolean trackBytes)
         throws IOException {
         Objects.requireNonNull(reader, "reader");
         Objects.requireNonNull(format, "format");
         this.format = format.copy();
-        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader, charset, enableByteTracking));
+        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader, charset, trackBytes));
         this.csvRecordIterator = new CSVRecordIterator();
         this.headers = createHeaders();
         this.characterOffset = characterOffset;
diff --git a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java
index 957c78bb..3769ffa4 100644
--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java
+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java
@@ -76,11 +76,11 @@ final class ExtendedBufferedReader extends UnsynchronizedBufferedReader {
      *
      * @param reader the reader supports a look-ahead option.
      * @param charset the character set for encoding, or {@code null} if not applicable.
-     * @param enableByteTracking {@code true} to enable byte tracking; {@code false} to disable it.
+     * @param trackBytes {@code true} to enable byte tracking; {@code false} to disable it.
      */
-    ExtendedBufferedReader(final Reader reader, final Charset charset, final boolean enableByteTracking) {
+    ExtendedBufferedReader(final Reader reader, final Charset charset, final boolean trackBytes) {
         super(reader);
-        if (charset != null && enableByteTracking) {
+        if (charset != null && trackBytes) {
             encoder = charset.newEncoder();
         }
     }
diff --git a/src/test/java/org/apache/commons/csv/CSVParserTest.java b/src/test/java/org/apache/commons/csv/CSVParserTest.java
index 2f508b36..ee1fd8f8 100644
--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java
+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java
@@ -818,7 +818,7 @@ public class CSVParserTest {
             .setDelimiter(',')
             .setQuote('\'')
             .get();
-        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setEnableByteTracking(true).get()) {
+        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setTrackBytes(true).get()) {
             CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);
 
             assertEquals(0, parser.getRecordNumber());
@@ -897,7 +897,7 @@ public class CSVParserTest {
             .setDelimiter(',')
             .setQuote('\'')
             .get();
-        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setEnableByteTracking(true).get() ) {
+        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setTrackBytes(true).get() ) {
             CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);
 
             assertEquals(0, parser.getRecordNumber());
diff --git a/src/test/java/org/apache/commons/csv/JiraCsv196Test.java b/src/test/java/org/apache/commons/csv/JiraCsv196Test.java
index 54d28256..cff3a772 100644
--- a/src/test/java/org/apache/commons/csv/JiraCsv196Test.java
+++ b/src/test/java/org/apache/commons/csv/JiraCsv196Test.java
@@ -37,7 +37,7 @@ public class JiraCsv196Test {
     public void testParseFourBytes() throws IOException {
         final CSVFormat format = CSVFormat.Builder.create().setDelimiter(',').setQuote('\'').get();
         try (CSVParser parser = new CSVParser.Builder().setFormat(format).setReader(getTestInput("org/apache/commons/csv/CSV-196/emoji.csv"))
-                .setCharset(StandardCharsets.UTF_8).setEnableByteTracking(true).get()) {
+                .setCharset(StandardCharsets.UTF_8).setTrackBytes(true).get()) {
             final long[] charByteKey = { 0, 84, 701, 1318, 1935 };
             int idx = 0;
             for (CSVRecord record : parser) {
@@ -50,7 +50,7 @@ public class JiraCsv196Test {
     public void testParseThreeBytes() throws IOException {
         final CSVFormat format = CSVFormat.Builder.create().setDelimiter(',').setQuote('\'').get();
         try (CSVParser parser = new CSVParser.Builder().setFormat(format).setReader(getTestInput("org/apache/commons/csv/CSV-196/japanese.csv"))
-                .setCharset(StandardCharsets.UTF_8).setEnableByteTracking(true).get()) {
+                .setCharset(StandardCharsets.UTF_8).setTrackBytes(true).get()) {
             final long[] charByteKey = { 0, 89, 242, 395 };
             int idx = 0;
             for (CSVRecord record : parser) {