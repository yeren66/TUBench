{
  "cache_key": "commons-csv_76981db68af50e0475a2d5d0fcc6bdf87efb18f1_method",
  "cached_at": "2026-01-24T04:57:09.820407",
  "project": "commons-csv",
  "commit_hash": "76981db68af50e0475a2d5d0fcc6bdf87efb18f1",
  "phase": "method",
  "data": {
    "commit_hash": "76981db68af50e0475a2d5d0fcc6bdf87efb18f1",
    "parent_hash": "5e5512fd068213d099920b00971ca3fe1185511c",
    "basic_info": {
      "project": "commons-csv",
      "commit_hash": "76981db68af50e0475a2d5d0fcc6bdf87efb18f1",
      "short_hash": "76981db6",
      "parent_hash": "5e5512fd068213d099920b00971ca3fe1185511c",
      "parent_short_hash": "5e5512fd",
      "author": "Gary Gregory",
      "date": "2025-01-02 20:14:13",
      "message": "Sort members",
      "message_subject": "Sort members"
    },
    "file_changes": {
      "source_files": [
        {
          "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "change_type": "modified",
          "old_path": null,
          "is_java": true
        },
        {
          "path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
          "change_type": "modified",
          "old_path": null,
          "is_java": true
        },
        {
          "path": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "change_type": "modified",
          "old_path": null,
          "is_java": true
        },
        {
          "path": "src/main/java/org/apache/commons/csv/Lexer.java",
          "change_type": "modified",
          "old_path": null,
          "is_java": true
        }
      ],
      "test_files": [
        {
          "path": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
          "change_type": "modified",
          "old_path": null,
          "is_java": true
        }
      ],
      "other_files": [],
      "summary": {
        "total_files": 5,
        "source_count": 4,
        "test_count": 1,
        "other_count": 0
      }
    },
    "method_changes": {
      "source_methods": [
        {
          "class": "Builder",
          "method": "setCharacterOffset",
          "parameters": [
            "long"
          ],
          "start_line": 179,
          "end_line": 182,
          "file": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "package": "org.apache.commons.csv"
        },
        {
          "class": "Builder",
          "method": "setEnableByteTracking",
          "parameters": [
            "boolean"
          ],
          "start_line": 191,
          "end_line": 194,
          "file": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "package": "org.apache.commons.csv"
        },
        {
          "class": "Builder",
          "method": "setRecordNumber",
          "parameters": [
            "long"
          ],
          "start_line": 213,
          "end_line": 216,
          "file": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "package": "org.apache.commons.csv"
        },
        {
          "class": "CSVRecord",
          "method": "get",
          "parameters": [
            "String"
          ],
          "start_line": 124,
          "end_line": 142,
          "file": "src/main/java/org/apache/commons/csv/CSVRecord.java",
          "package": "org.apache.commons.csv"
        },
        {
          "class": "CSVRecord",
          "method": "getBytePosition",
          "parameters": [],
          "start_line": 150,
          "end_line": 152,
          "file": "src/main/java/org/apache/commons/csv/CSVRecord.java",
          "package": "org.apache.commons.csv"
        },
        {
          "class": "CSVRecord",
          "method": "getCharacterPosition",
          "parameters": [],
          "start_line": 160,
          "end_line": 162,
          "file": "src/main/java/org/apache/commons/csv/CSVRecord.java",
          "package": "org.apache.commons.csv"
        },
        {
          "class": "ExtendedBufferedReader",
          "method": "close",
          "parameters": [],
          "start_line": 95,
          "end_line": 99,
          "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "package": "org.apache.commons.csv"
        },
        {
          "class": "ExtendedBufferedReader",
          "method": "getBytesRead",
          "parameters": [],
          "start_line": 106,
          "end_line": 108,
          "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "package": "org.apache.commons.csv"
        },
        {
          "class": "ExtendedBufferedReader",
          "method": "getEncodedCharLength",
          "parameters": [
            "int"
          ],
          "start_line": 136,
          "end_line": 153,
          "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "package": "org.apache.commons.csv"
        },
        {
          "class": "ExtendedBufferedReader",
          "method": "read",
          "parameters": [],
          "start_line": 199,
          "end_line": 211,
          "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "package": "org.apache.commons.csv"
        },
        {
          "class": "ExtendedBufferedReader",
          "method": "reset",
          "parameters": [],
          "start_line": 273,
          "end_line": 279,
          "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "package": "org.apache.commons.csv"
        },
        {
          "class": "Lexer",
          "method": "close",
          "parameters": [],
          "start_line": 95,
          "end_line": 97,
          "file": "src/main/java/org/apache/commons/csv/Lexer.java",
          "package": "org.apache.commons.csv"
        },
        {
          "class": "Lexer",
          "method": "getBytesRead",
          "parameters": [],
          "start_line": 104,
          "end_line": 106,
          "file": "src/main/java/org/apache/commons/csv/Lexer.java",
          "package": "org.apache.commons.csv"
        },
        {
          "class": "Lexer",
          "method": "getCharacterPosition",
          "parameters": [],
          "start_line": 113,
          "end_line": 115,
          "file": "src/main/java/org/apache/commons/csv/Lexer.java",
          "package": "org.apache.commons.csv"
        }
      ],
      "test_methods": [
        {
          "class": "CSVParserTest",
          "method": "testGetHeaderComment_NoComment3",
          "parameters": [],
          "start_line": 697,
          "end_line": 704,
          "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
          "package": "org.apache.commons.csv",
          "is_test_method": true
        },
        {
          "class": "CSVParserTest",
          "method": "testGetHeaderMap",
          "parameters": [],
          "start_line": 707,
          "end_line": 728,
          "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
          "package": "org.apache.commons.csv",
          "is_test_method": true
        },
        {
          "class": "CSVParserTest",
          "method": "testGetOneLineOneParser",
          "parameters": [],
          "start_line": 793,
          "end_line": 809,
          "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
          "package": "org.apache.commons.csv",
          "is_test_method": true
        },
        {
          "class": "CSVParserTest",
          "method": "testGetRecordFourBytesRead",
          "parameters": [],
          "start_line": 812,
          "end_line": 843,
          "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
          "package": "org.apache.commons.csv",
          "is_test_method": true
        },
        {
          "class": "CSVParserTest",
          "method": "testGetRecordNumberWithCR",
          "parameters": [],
          "start_line": 846,
          "end_line": 848,
          "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
          "package": "org.apache.commons.csv",
          "is_test_method": true
        },
        {
          "class": "CSVParserTest",
          "method": "testGetRecordsFromBrokenInputStream",
          "parameters": [],
          "start_line": 883,
          "end_line": 888,
          "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
          "package": "org.apache.commons.csv",
          "is_test_method": true
        },
        {
          "class": "CSVParserTest",
          "method": "testGetRecordThreeBytesRead",
          "parameters": [],
          "start_line": 891,
          "end_line": 924,
          "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
          "package": "org.apache.commons.csv",
          "is_test_method": true
        },
        {
          "class": "CSVParserTest",
          "method": "testGetRecordWithMultiLineValues",
          "parameters": [],
          "start_line": 927,
          "end_line": 949,
          "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
          "package": "org.apache.commons.csv",
          "is_test_method": true
        }
      ],
      "summary": {
        "source_methods_count": 14,
        "test_methods_count": 8
      }
    },
    "diff_info": {
      "full_diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex 07028ea7..a7067657 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -181,6 +181,18 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n             return asThis();\n         }\n \n+        /**\n+         * Sets whether to enable byte tracking for the parser.\n+         *\n+         * @param enableByteTracking {@code true} to enable byte tracking; {@code false} to disable it.\n+         * @return this instance.\n+         * @since 1.13.0\n+         */\n+        public Builder setEnableByteTracking(final boolean enableByteTracking) {\n+            this.enableByteTracking = enableByteTracking;\n+            return asThis();\n+        }\n+\n         /**\n          * Sets the CSV format. A copy of the given format is kept.\n          *\n@@ -203,18 +215,6 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n             return asThis();\n         }\n \n-        /**\n-         * Sets whether to enable byte tracking for the parser.\n-         *\n-         * @param enableByteTracking {@code true} to enable byte tracking; {@code false} to disable it.\n-         * @return this instance.\n-         * @since 1.13.0\n-         */\n-        public Builder setEnableByteTracking(final boolean enableByteTracking) {\n-            this.enableByteTracking = enableByteTracking;\n-            return asThis();\n-        }\n-\n     }\n \n     final class CSVRecordIterator implements Iterator<CSVRecord> {\ndiff --git a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex 284220c3..689cd0a2 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -141,16 +141,6 @@ public final class CSVRecord implements Serializable, Iterable<String> {\n         }\n     }\n \n-    /**\n-     * Returns the start position of this record as a character position in the source stream. This may or may not\n-     * correspond to the byte position depending on the character set.\n-     *\n-     * @return the position of this record in the source stream.\n-     */\n-    public long getCharacterPosition() {\n-        return characterPosition;\n-    }\n-\n     /**\n      * Returns the starting position of this record in the source stream, measured in bytes.\n      *\n@@ -161,6 +151,16 @@ public final class CSVRecord implements Serializable, Iterable<String> {\n         return bytePosition;\n     }\n \n+    /**\n+     * Returns the start position of this record as a character position in the source stream. This may or may not\n+     * correspond to the byte position depending on the character set.\n+     *\n+     * @return the position of this record in the source stream.\n+     */\n+    public long getCharacterPosition() {\n+        return characterPosition;\n+    }\n+\n     /**\n      * Returns the comment for this record, if any.\n      * Note that comments are attached to the following record.\ndiff --git a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\nindex 6043ccaf..31890db8 100644\n--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n@@ -98,6 +98,60 @@ final class ExtendedBufferedReader extends UnsynchronizedBufferedReader {\n         super.close();\n     }\n \n+    /**\n+     * Gets the number of bytes read by the reader.\n+     *\n+     * @return the number of bytes read by the read\n+     */\n+    long getBytesRead() {\n+        return this.bytesRead;\n+    }\n+\n+    /**\n+     * Gets the byte length of the given character based on the the original Unicode\n+     * specification, which defined characters as fixed-width 16-bit entities.\n+     * <p>\n+     * The Unicode characters are divided into two main ranges:\n+     * <ul>\n+     *   <li><b>U+0000 to U+FFFF (Basic Multilingual Plane, BMP):</b>\n+     *     <ul>\n+     *       <li>Represented using a single 16-bit {@code char}.</li>\n+     *       <li>Includes UTF-8 encodings of 1-byte, 2-byte, and some 3-byte characters.</li>\n+     *     </ul>\n+     *   </li>\n+     *   <li><b>U+10000 to U+10FFFF (Supplementary Characters):</b>\n+     *     <ul>\n+     *       <li>Represented as a pair of {@code char}s:</li>\n+     *       <li>The first {@code char} is from the high-surrogates range (\\uD800-\\uDBFF).</li>\n+     *       <li>The second {@code char} is from the low-surrogates range (\\uDC00-\\uDFFF).</li>\n+     *       <li>Includes UTF-8 encodings of some 3-byte characters and all 4-byte characters.</li>\n+     *     </ul>\n+     *   </li>\n+     * </ul>\n+     *\n+     * @param current the current character to process.\n+     * @return the byte length of the character.\n+     * @throws CharacterCodingException if the character cannot be encoded.\n+     */\n+    private int getEncodedCharLength(int current) throws CharacterCodingException {\n+        final char cChar = (char) current;\n+        final char lChar = (char) lastChar;\n+        if (!Character.isSurrogate(cChar)) {\n+            return encoder.encode(\n+                CharBuffer.wrap(new char[] {cChar})).limit();\n+        } else {\n+            if (Character.isHighSurrogate(cChar)) {\n+                // Move on to the next char (low surrogate)\n+                return 0;\n+            } else if (Character.isSurrogatePair(lChar, cChar)) {\n+                return encoder.encode(\n+                    CharBuffer.wrap(new char[] {lChar, cChar})).limit();\n+            } else {\n+                throw new CharacterCodingException();\n+            }\n+        }\n+    }\n+\n     /**\n      * Returns the last character that was read as an integer (0 to 65535). This will be the last character returned by\n      * any of the read methods. This will not include a character read using the {@link #peek()} method. If no\n@@ -156,51 +210,6 @@ final class ExtendedBufferedReader extends UnsynchronizedBufferedReader {\n         return lastChar;\n     }\n \n-    /**\n-     * Gets the byte length of the given character based on the the original Unicode\n-     * specification, which defined characters as fixed-width 16-bit entities.\n-     * <p>\n-     * The Unicode characters are divided into two main ranges:\n-     * <ul>\n-     *   <li><b>U+0000 to U+FFFF (Basic Multilingual Plane, BMP):</b>\n-     *     <ul>\n-     *       <li>Represented using a single 16-bit {@code char}.</li>\n-     *       <li>Includes UTF-8 encodings of 1-byte, 2-byte, and some 3-byte characters.</li>\n-     *     </ul>\n-     *   </li>\n-     *   <li><b>U+10000 to U+10FFFF (Supplementary Characters):</b>\n-     *     <ul>\n-     *       <li>Represented as a pair of {@code char}s:</li>\n-     *       <li>The first {@code char} is from the high-surrogates range (\\uD800-\\uDBFF).</li>\n-     *       <li>The second {@code char} is from the low-surrogates range (\\uDC00-\\uDFFF).</li>\n-     *       <li>Includes UTF-8 encodings of some 3-byte characters and all 4-byte characters.</li>\n-     *     </ul>\n-     *   </li>\n-     * </ul>\n-     *\n-     * @param current the current character to process.\n-     * @return the byte length of the character.\n-     * @throws CharacterCodingException if the character cannot be encoded.\n-     */\n-    private int getEncodedCharLength(int current) throws CharacterCodingException {\n-        final char cChar = (char) current;\n-        final char lChar = (char) lastChar;\n-        if (!Character.isSurrogate(cChar)) {\n-            return encoder.encode(\n-                CharBuffer.wrap(new char[] {cChar})).limit();\n-        } else {\n-            if (Character.isHighSurrogate(cChar)) {\n-                // Move on to the next char (low surrogate)\n-                return 0;\n-            } else if (Character.isSurrogatePair(lChar, cChar)) {\n-                return encoder.encode(\n-                    CharBuffer.wrap(new char[] {lChar, cChar})).limit();\n-            } else {\n-                throw new CharacterCodingException();\n-            }\n-        }\n-    }\n-\n     @Override\n     public int read(final char[] buf, final int offset, final int length) throws IOException {\n         if (length == 0) {\n@@ -269,13 +278,4 @@ final class ExtendedBufferedReader extends UnsynchronizedBufferedReader {\n         super.reset();\n     }\n \n-    /**\n-     * Gets the number of bytes read by the reader.\n-     *\n-     * @return the number of bytes read by the read\n-     */\n-    long getBytesRead() {\n-        return this.bytesRead;\n-    }\n-\n }\ndiff --git a/src/main/java/org/apache/commons/csv/Lexer.java b/src/main/java/org/apache/commons/csv/Lexer.java\nindex 2e7d2d04..2e9e7137 100644\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n@@ -97,21 +97,21 @@ final class Lexer implements Closeable {\n     }\n \n     /**\n-     * Returns the current character position\n+     * Gets the number of bytes read\n      *\n-     * @return the current character position\n+     * @return the number of bytes read\n      */\n-    long getCharacterPosition() {\n-        return reader.getPosition();\n+    long getBytesRead() {\n+        return reader.getBytesRead();\n     }\n \n     /**\n-     * Gets the number of bytes read\n+     * Returns the current character position\n      *\n-     * @return the number of bytes read\n+     * @return the current character position\n      */\n-    long getBytesRead() {\n-        return reader.getBytesRead();\n+    long getCharacterPosition() {\n+        return reader.getPosition();\n     }\n \n     /**\ndiff --git a/src/test/java/org/apache/commons/csv/CSVParserTest.java b/src/test/java/org/apache/commons/csv/CSVParserTest.java\nindex c42a3c25..2f508b36 100644\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n@@ -703,76 +703,6 @@ public class CSVParserTest {\n         }\r\n     }\r\n \r\n-    @Test\r\n-    public void testGetRecordThreeBytesRead() throws Exception {\r\n-        final String code = \"id,date,val5,val4\\n\" +\r\n-            \"11111111111111,'4017-09-01',„Åç„Å°„Çì„Å®ÁØÄÂàÜËøë„Åè„Å´„ÅØÂí≤„ÅÑ„Å¶„ÇãÔΩû,v4\\n\" +\r\n-            \"22222222222222,'4017-01-01',„Åä„ÅØ„Çà„ÅÜÁßÅ„ÅÆÂèã‰∫∫ÔΩû,v4\\n\" +\r\n-            \"33333333333333,'4017-01-01',„Åç„ÇãËá™ÁÑ∂„ÅÆÂäõ„Å£„Å¶„Åô„Åî„ÅÑ„Å™ÔΩû,v4\\n\";\r\n-        final CSVFormat format = CSVFormat.Builder.create()\r\n-            .setDelimiter(',')\r\n-            .setQuote('\\'')\r\n-            .get();\r\n-        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setEnableByteTracking(true).get() ) {\r\n-            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n-\r\n-            assertEquals(0, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(1, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n-\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(2, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n-\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), 95);\r\n-\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(4, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), 154);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordFourBytesRead() throws Exception {\r\n-        final String code = \"id,a,b,c\\n\" +\r\n-            \"1,üòä,ü§î,üòÇ\\n\" +\r\n-            \"2,üòä,ü§î,üòÇ\\n\" +\r\n-            \"3,üòä,ü§î,üòÇ\\n\";\r\n-        final CSVFormat format = CSVFormat.Builder.create()\r\n-            .setDelimiter(',')\r\n-            .setQuote('\\'')\r\n-            .get();\r\n-        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setEnableByteTracking(true).get()) {\r\n-            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n-\r\n-            assertEquals(0, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(1, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n-\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(2, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), 26);\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(4, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), 43);\r\n-        }\r\n-    }\r\n-\r\n     @Test\r\n     public void testGetHeaderMap() throws Exception {\r\n         try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\r\n@@ -878,6 +808,40 @@ public class CSVParserTest {\n         }\r\n     }\r\n \r\n+    @Test\r\n+    public void testGetRecordFourBytesRead() throws Exception {\r\n+        final String code = \"id,a,b,c\\n\" +\r\n+            \"1,üòä,ü§î,üòÇ\\n\" +\r\n+            \"2,üòä,ü§î,üòÇ\\n\" +\r\n+            \"3,üòä,ü§î,üòÇ\\n\";\r\n+        final CSVFormat format = CSVFormat.Builder.create()\r\n+            .setDelimiter(',')\r\n+            .setQuote('\\'')\r\n+            .get();\r\n+        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setEnableByteTracking(true).get()) {\r\n+            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n+\r\n+            assertEquals(0, parser.getRecordNumber());\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(1, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n+\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(2, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(3, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), 26);\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(4, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), 43);\r\n+        }\r\n+    }\r\n+\r\n     @Test\r\n     public void testGetRecordNumberWithCR() throws Exception {\r\n         validateRecordNumbers(String.valueOf(CR));\r\n@@ -923,6 +887,42 @@ public class CSVParserTest {\n \r\n     }\r\n \r\n+    @Test\r\n+    public void testGetRecordThreeBytesRead() throws Exception {\r\n+        final String code = \"id,date,val5,val4\\n\" +\r\n+            \"11111111111111,'4017-09-01',„Åç„Å°„Çì„Å®ÁØÄÂàÜËøë„Åè„Å´„ÅØÂí≤„ÅÑ„Å¶„ÇãÔΩû,v4\\n\" +\r\n+            \"22222222222222,'4017-01-01',„Åä„ÅØ„Çà„ÅÜÁßÅ„ÅÆÂèã‰∫∫ÔΩû,v4\\n\" +\r\n+            \"33333333333333,'4017-01-01',„Åç„ÇãËá™ÁÑ∂„ÅÆÂäõ„Å£„Å¶„Åô„Åî„ÅÑ„Å™ÔΩû,v4\\n\";\r\n+        final CSVFormat format = CSVFormat.Builder.create()\r\n+            .setDelimiter(',')\r\n+            .setQuote('\\'')\r\n+            .get();\r\n+        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setEnableByteTracking(true).get() ) {\r\n+            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n+\r\n+            assertEquals(0, parser.getRecordNumber());\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(1, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n+\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(2, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n+\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(3, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), 95);\r\n+\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(4, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), 154);\r\n+        }\r\n+    }\r\n+\r\n     @Test\r\n     public void testGetRecordWithMultiLineValues() throws Exception {\r\n         try (CSVParser parser = CSVParser.parse(\"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF + \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\",\r",
      "source_only_diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex 07028ea7..a7067657 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -181,6 +181,18 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n             return asThis();\n         }\n \n+        /**\n+         * Sets whether to enable byte tracking for the parser.\n+         *\n+         * @param enableByteTracking {@code true} to enable byte tracking; {@code false} to disable it.\n+         * @return this instance.\n+         * @since 1.13.0\n+         */\n+        public Builder setEnableByteTracking(final boolean enableByteTracking) {\n+            this.enableByteTracking = enableByteTracking;\n+            return asThis();\n+        }\n+\n         /**\n          * Sets the CSV format. A copy of the given format is kept.\n          *\n@@ -203,18 +215,6 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n             return asThis();\n         }\n \n-        /**\n-         * Sets whether to enable byte tracking for the parser.\n-         *\n-         * @param enableByteTracking {@code true} to enable byte tracking; {@code false} to disable it.\n-         * @return this instance.\n-         * @since 1.13.0\n-         */\n-        public Builder setEnableByteTracking(final boolean enableByteTracking) {\n-            this.enableByteTracking = enableByteTracking;\n-            return asThis();\n-        }\n-\n     }\n \n     final class CSVRecordIterator implements Iterator<CSVRecord> {\n\ndiff --git a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex 284220c3..689cd0a2 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -141,16 +141,6 @@ public final class CSVRecord implements Serializable, Iterable<String> {\n         }\n     }\n \n-    /**\n-     * Returns the start position of this record as a character position in the source stream. This may or may not\n-     * correspond to the byte position depending on the character set.\n-     *\n-     * @return the position of this record in the source stream.\n-     */\n-    public long getCharacterPosition() {\n-        return characterPosition;\n-    }\n-\n     /**\n      * Returns the starting position of this record in the source stream, measured in bytes.\n      *\n@@ -161,6 +151,16 @@ public final class CSVRecord implements Serializable, Iterable<String> {\n         return bytePosition;\n     }\n \n+    /**\n+     * Returns the start position of this record as a character position in the source stream. This may or may not\n+     * correspond to the byte position depending on the character set.\n+     *\n+     * @return the position of this record in the source stream.\n+     */\n+    public long getCharacterPosition() {\n+        return characterPosition;\n+    }\n+\n     /**\n      * Returns the comment for this record, if any.\n      * Note that comments are attached to the following record.\n\ndiff --git a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\nindex 6043ccaf..31890db8 100644\n--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n@@ -98,6 +98,60 @@ final class ExtendedBufferedReader extends UnsynchronizedBufferedReader {\n         super.close();\n     }\n \n+    /**\n+     * Gets the number of bytes read by the reader.\n+     *\n+     * @return the number of bytes read by the read\n+     */\n+    long getBytesRead() {\n+        return this.bytesRead;\n+    }\n+\n+    /**\n+     * Gets the byte length of the given character based on the the original Unicode\n+     * specification, which defined characters as fixed-width 16-bit entities.\n+     * <p>\n+     * The Unicode characters are divided into two main ranges:\n+     * <ul>\n+     *   <li><b>U+0000 to U+FFFF (Basic Multilingual Plane, BMP):</b>\n+     *     <ul>\n+     *       <li>Represented using a single 16-bit {@code char}.</li>\n+     *       <li>Includes UTF-8 encodings of 1-byte, 2-byte, and some 3-byte characters.</li>\n+     *     </ul>\n+     *   </li>\n+     *   <li><b>U+10000 to U+10FFFF (Supplementary Characters):</b>\n+     *     <ul>\n+     *       <li>Represented as a pair of {@code char}s:</li>\n+     *       <li>The first {@code char} is from the high-surrogates range (\\uD800-\\uDBFF).</li>\n+     *       <li>The second {@code char} is from the low-surrogates range (\\uDC00-\\uDFFF).</li>\n+     *       <li>Includes UTF-8 encodings of some 3-byte characters and all 4-byte characters.</li>\n+     *     </ul>\n+     *   </li>\n+     * </ul>\n+     *\n+     * @param current the current character to process.\n+     * @return the byte length of the character.\n+     * @throws CharacterCodingException if the character cannot be encoded.\n+     */\n+    private int getEncodedCharLength(int current) throws CharacterCodingException {\n+        final char cChar = (char) current;\n+        final char lChar = (char) lastChar;\n+        if (!Character.isSurrogate(cChar)) {\n+            return encoder.encode(\n+                CharBuffer.wrap(new char[] {cChar})).limit();\n+        } else {\n+            if (Character.isHighSurrogate(cChar)) {\n+                // Move on to the next char (low surrogate)\n+                return 0;\n+            } else if (Character.isSurrogatePair(lChar, cChar)) {\n+                return encoder.encode(\n+                    CharBuffer.wrap(new char[] {lChar, cChar})).limit();\n+            } else {\n+                throw new CharacterCodingException();\n+            }\n+        }\n+    }\n+\n     /**\n      * Returns the last character that was read as an integer (0 to 65535). This will be the last character returned by\n      * any of the read methods. This will not include a character read using the {@link #peek()} method. If no\n@@ -156,51 +210,6 @@ final class ExtendedBufferedReader extends UnsynchronizedBufferedReader {\n         return lastChar;\n     }\n \n-    /**\n-     * Gets the byte length of the given character based on the the original Unicode\n-     * specification, which defined characters as fixed-width 16-bit entities.\n-     * <p>\n-     * The Unicode characters are divided into two main ranges:\n-     * <ul>\n-     *   <li><b>U+0000 to U+FFFF (Basic Multilingual Plane, BMP):</b>\n-     *     <ul>\n-     *       <li>Represented using a single 16-bit {@code char}.</li>\n-     *       <li>Includes UTF-8 encodings of 1-byte, 2-byte, and some 3-byte characters.</li>\n-     *     </ul>\n-     *   </li>\n-     *   <li><b>U+10000 to U+10FFFF (Supplementary Characters):</b>\n-     *     <ul>\n-     *       <li>Represented as a pair of {@code char}s:</li>\n-     *       <li>The first {@code char} is from the high-surrogates range (\\uD800-\\uDBFF).</li>\n-     *       <li>The second {@code char} is from the low-surrogates range (\\uDC00-\\uDFFF).</li>\n-     *       <li>Includes UTF-8 encodings of some 3-byte characters and all 4-byte characters.</li>\n-     *     </ul>\n-     *   </li>\n-     * </ul>\n-     *\n-     * @param current the current character to process.\n-     * @return the byte length of the character.\n-     * @throws CharacterCodingException if the character cannot be encoded.\n-     */\n-    private int getEncodedCharLength(int current) throws CharacterCodingException {\n-        final char cChar = (char) current;\n-        final char lChar = (char) lastChar;\n-        if (!Character.isSurrogate(cChar)) {\n-            return encoder.encode(\n-                CharBuffer.wrap(new char[] {cChar})).limit();\n-        } else {\n-            if (Character.isHighSurrogate(cChar)) {\n-                // Move on to the next char (low surrogate)\n-                return 0;\n-            } else if (Character.isSurrogatePair(lChar, cChar)) {\n-                return encoder.encode(\n-                    CharBuffer.wrap(new char[] {lChar, cChar})).limit();\n-            } else {\n-                throw new CharacterCodingException();\n-            }\n-        }\n-    }\n-\n     @Override\n     public int read(final char[] buf, final int offset, final int length) throws IOException {\n         if (length == 0) {\n@@ -269,13 +278,4 @@ final class ExtendedBufferedReader extends UnsynchronizedBufferedReader {\n         super.reset();\n     }\n \n-    /**\n-     * Gets the number of bytes read by the reader.\n-     *\n-     * @return the number of bytes read by the read\n-     */\n-    long getBytesRead() {\n-        return this.bytesRead;\n-    }\n-\n }\n\ndiff --git a/src/main/java/org/apache/commons/csv/Lexer.java b/src/main/java/org/apache/commons/csv/Lexer.java\nindex 2e7d2d04..2e9e7137 100644\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n@@ -97,21 +97,21 @@ final class Lexer implements Closeable {\n     }\n \n     /**\n-     * Returns the current character position\n+     * Gets the number of bytes read\n      *\n-     * @return the current character position\n+     * @return the number of bytes read\n      */\n-    long getCharacterPosition() {\n-        return reader.getPosition();\n+    long getBytesRead() {\n+        return reader.getBytesRead();\n     }\n \n     /**\n-     * Gets the number of bytes read\n+     * Returns the current character position\n      *\n-     * @return the number of bytes read\n+     * @return the current character position\n      */\n-    long getBytesRead() {\n-        return reader.getBytesRead();\n+    long getCharacterPosition() {\n+        return reader.getPosition();\n     }\n \n     /**\n",
      "test_only_diff": "diff --git a/src/test/java/org/apache/commons/csv/CSVParserTest.java b/src/test/java/org/apache/commons/csv/CSVParserTest.java\nindex c42a3c25..2f508b36 100644\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n@@ -703,76 +703,6 @@ public class CSVParserTest {\n         }\r\n     }\r\n \r\n-    @Test\r\n-    public void testGetRecordThreeBytesRead() throws Exception {\r\n-        final String code = \"id,date,val5,val4\\n\" +\r\n-            \"11111111111111,'4017-09-01',„Åç„Å°„Çì„Å®ÁØÄÂàÜËøë„Åè„Å´„ÅØÂí≤„ÅÑ„Å¶„ÇãÔΩû,v4\\n\" +\r\n-            \"22222222222222,'4017-01-01',„Åä„ÅØ„Çà„ÅÜÁßÅ„ÅÆÂèã‰∫∫ÔΩû,v4\\n\" +\r\n-            \"33333333333333,'4017-01-01',„Åç„ÇãËá™ÁÑ∂„ÅÆÂäõ„Å£„Å¶„Åô„Åî„ÅÑ„Å™ÔΩû,v4\\n\";\r\n-        final CSVFormat format = CSVFormat.Builder.create()\r\n-            .setDelimiter(',')\r\n-            .setQuote('\\'')\r\n-            .get();\r\n-        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setEnableByteTracking(true).get() ) {\r\n-            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n-\r\n-            assertEquals(0, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(1, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n-\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(2, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n-\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), 95);\r\n-\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(4, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), 154);\r\n-        }\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testGetRecordFourBytesRead() throws Exception {\r\n-        final String code = \"id,a,b,c\\n\" +\r\n-            \"1,üòä,ü§î,üòÇ\\n\" +\r\n-            \"2,üòä,ü§î,üòÇ\\n\" +\r\n-            \"3,üòä,ü§î,üòÇ\\n\";\r\n-        final CSVFormat format = CSVFormat.Builder.create()\r\n-            .setDelimiter(',')\r\n-            .setQuote('\\'')\r\n-            .get();\r\n-        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setEnableByteTracking(true).get()) {\r\n-            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n-\r\n-            assertEquals(0, parser.getRecordNumber());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(1, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n-\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(2, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(3, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), 26);\r\n-            assertNotNull(record = parser.nextRecord());\r\n-            assertEquals(4, record.getRecordNumber());\r\n-            assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n-            assertEquals(record.getBytePosition(), 43);\r\n-        }\r\n-    }\r\n-\r\n     @Test\r\n     public void testGetHeaderMap() throws Exception {\r\n         try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\r\n@@ -878,6 +808,40 @@ public class CSVParserTest {\n         }\r\n     }\r\n \r\n+    @Test\r\n+    public void testGetRecordFourBytesRead() throws Exception {\r\n+        final String code = \"id,a,b,c\\n\" +\r\n+            \"1,üòä,ü§î,üòÇ\\n\" +\r\n+            \"2,üòä,ü§î,üòÇ\\n\" +\r\n+            \"3,üòä,ü§î,üòÇ\\n\";\r\n+        final CSVFormat format = CSVFormat.Builder.create()\r\n+            .setDelimiter(',')\r\n+            .setQuote('\\'')\r\n+            .get();\r\n+        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setEnableByteTracking(true).get()) {\r\n+            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n+\r\n+            assertEquals(0, parser.getRecordNumber());\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(1, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n+\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(2, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(3, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), 26);\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(4, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), 43);\r\n+        }\r\n+    }\r\n+\r\n     @Test\r\n     public void testGetRecordNumberWithCR() throws Exception {\r\n         validateRecordNumbers(String.valueOf(CR));\r\n@@ -923,6 +887,42 @@ public class CSVParserTest {\n \r\n     }\r\n \r\n+    @Test\r\n+    public void testGetRecordThreeBytesRead() throws Exception {\r\n+        final String code = \"id,date,val5,val4\\n\" +\r\n+            \"11111111111111,'4017-09-01',„Åç„Å°„Çì„Å®ÁØÄÂàÜËøë„Åè„Å´„ÅØÂí≤„ÅÑ„Å¶„ÇãÔΩû,v4\\n\" +\r\n+            \"22222222222222,'4017-01-01',„Åä„ÅØ„Çà„ÅÜÁßÅ„ÅÆÂèã‰∫∫ÔΩû,v4\\n\" +\r\n+            \"33333333333333,'4017-01-01',„Åç„ÇãËá™ÁÑ∂„ÅÆÂäõ„Å£„Å¶„Åô„Åî„ÅÑ„Å™ÔΩû,v4\\n\";\r\n+        final CSVFormat format = CSVFormat.Builder.create()\r\n+            .setDelimiter(',')\r\n+            .setQuote('\\'')\r\n+            .get();\r\n+        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setEnableByteTracking(true).get() ) {\r\n+            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n+\r\n+            assertEquals(0, parser.getRecordNumber());\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(1, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n+\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(2, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n+\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(3, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), 95);\r\n+\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(4, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), 154);\r\n+        }\r\n+    }\r\n+\r\n     @Test\r\n     public void testGetRecordWithMultiLineValues() throws Exception {\r\n         try (CSVParser parser = CSVParser.parse(\"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF + \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\",\r",
      "stats": {
        "source_files": 4,
        "test_files": 1,
        "filtered": true
      },
      "change_stats": {
        "full": {
          "files": [
            {
              "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
              "lines_added": 12,
              "lines_removed": 12,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
              "lines_added": 10,
              "lines_removed": 10,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
              "lines_added": 54,
              "lines_removed": 54,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/main/java/org/apache/commons/csv/Lexer.java",
              "lines_added": 8,
              "lines_removed": 8,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
              "lines_added": 70,
              "lines_removed": 70,
              "is_new": false,
              "is_deleted": false
            }
          ],
          "total_lines_added": 154,
          "total_lines_removed": 154
        },
        "source": {
          "files": [
            {
              "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
              "lines_added": 12,
              "lines_removed": 12,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
              "lines_added": 10,
              "lines_removed": 10,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
              "lines_added": 54,
              "lines_removed": 54,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/main/java/org/apache/commons/csv/Lexer.java",
              "lines_added": 8,
              "lines_removed": 8,
              "is_new": false,
              "is_deleted": false
            }
          ],
          "total_lines_added": 84,
          "total_lines_removed": 84
        },
        "test": {
          "files": [
            {
              "path": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
              "lines_added": 70,
              "lines_removed": 70,
              "is_new": false,
              "is_deleted": false
            }
          ],
          "total_lines_added": 70,
          "total_lines_removed": 70
        }
      }
    },
    "method_change_stats": {
      "source": [
        {
          "package": "org.apache.commons.csv",
          "class": "Builder",
          "method": "setEnableByteTracking",
          "parameters": [
            "boolean"
          ],
          "file": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "added_lines": 4,
          "removed_lines": 4,
          "total_changed_lines": 8
        },
        {
          "package": "org.apache.commons.csv",
          "class": "CSVRecord",
          "method": "getCharacterPosition",
          "parameters": [],
          "file": "src/main/java/org/apache/commons/csv/CSVRecord.java",
          "added_lines": 3,
          "removed_lines": 3,
          "total_changed_lines": 6
        },
        {
          "package": "org.apache.commons.csv",
          "class": "ExtendedBufferedReader",
          "method": "getBytesRead",
          "parameters": [],
          "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "added_lines": 3,
          "removed_lines": 3,
          "total_changed_lines": 6
        },
        {
          "package": "org.apache.commons.csv",
          "class": "ExtendedBufferedReader",
          "method": "getEncodedCharLength",
          "parameters": [
            "int"
          ],
          "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "added_lines": 18,
          "removed_lines": 18,
          "total_changed_lines": 36
        },
        {
          "package": "org.apache.commons.csv",
          "class": "Lexer",
          "method": "getBytesRead",
          "parameters": [],
          "file": "src/main/java/org/apache/commons/csv/Lexer.java",
          "added_lines": 2,
          "removed_lines": 2,
          "total_changed_lines": 4
        },
        {
          "package": "org.apache.commons.csv",
          "class": "Lexer",
          "method": "getCharacterPosition",
          "parameters": [],
          "file": "src/main/java/org/apache/commons/csv/Lexer.java",
          "added_lines": 2,
          "removed_lines": 2,
          "total_changed_lines": 4
        }
      ],
      "test": [
        {
          "package": "org.apache.commons.csv",
          "class": "CSVParserTest",
          "method": "testGetRecordThreeBytesRead",
          "parameters": [],
          "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
          "added_lines": 34,
          "removed_lines": 34,
          "total_changed_lines": 68
        },
        {
          "package": "org.apache.commons.csv",
          "class": "CSVParserTest",
          "method": "testGetRecordFourBytesRead",
          "parameters": [],
          "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
          "added_lines": 32,
          "removed_lines": 32,
          "total_changed_lines": 64
        }
      ]
    },
    "has_method_changes": true
  }
}