{
  "cache_key": "commons-csv_b40039bb8bade1c1d71bce6ecc46479e53eeb76c_method",
  "cached_at": "2026-01-25T17:58:43.055372",
  "project": "commons-csv",
  "commit_hash": "b40039bb8bade1c1d71bce6ecc46479e53eeb76c",
  "phase": "method",
  "data": {
    "commit_hash": "b40039bb8bade1c1d71bce6ecc46479e53eeb76c",
    "parent_hash": "dd7b4b3e7753d177e18c4c0ef90fa89a1f66b673",
    "basic_info": {
      "project": "commons-csv",
      "commit_hash": "b40039bb8bade1c1d71bce6ecc46479e53eeb76c",
      "short_hash": "b40039bb",
      "parent_hash": "dd7b4b3e7753d177e18c4c0ef90fa89a1f66b673",
      "parent_short_hash": "dd7b4b3e",
      "author": "Gary Gregory",
      "date": "2025-01-02 19:58:51",
      "message": "Merge pull request #502 from marklogic/CSV-196-master\n\nCSV-196-TrackBytePositions",
      "message_subject": "Merge pull request #502 from marklogic/CSV-196-master"
    },
    "file_changes": {
      "source_files": [
        {
          "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "change_type": "modified",
          "old_path": null,
          "is_java": true
        },
        {
          "path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
          "change_type": "modified",
          "old_path": null,
          "is_java": true
        },
        {
          "path": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "change_type": "modified",
          "old_path": null,
          "is_java": true
        },
        {
          "path": "src/main/java/org/apache/commons/csv/Lexer.java",
          "change_type": "modified",
          "old_path": null,
          "is_java": true
        }
      ],
      "test_files": [
        {
          "path": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
          "change_type": "modified",
          "old_path": null,
          "is_java": true
        },
        {
          "path": "src/test/java/org/apache/commons/csv/CSVRecordTest.java",
          "change_type": "modified",
          "old_path": null,
          "is_java": true
        },
        {
          "path": "src/test/java/org/apache/commons/csv/JiraCsv196Test.java",
          "change_type": "added",
          "old_path": null,
          "is_java": true
        }
      ],
      "other_files": [
        {
          "path": "pom.xml",
          "change_type": "modified",
          "old_path": null,
          "is_java": false
        },
        {
          "path": "src/test/resources/org/apache/commons/csv/CSV-196/emoji.csv",
          "change_type": "added",
          "old_path": null,
          "is_java": false
        },
        {
          "path": "src/test/resources/org/apache/commons/csv/CSV-196/japanese.csv",
          "change_type": "added",
          "old_path": null,
          "is_java": false
        }
      ],
      "summary": {
        "total_files": 10,
        "source_count": 4,
        "test_count": 3,
        "other_count": 3
      }
    },
    "method_changes": {
      "source_methods": [
        {
          "class": "CSVParser.Builder",
          "method": "get",
          "parameters": [],
          "start_line": 169,
          "end_line": 171,
          "package": "org.apache.commons.csv",
          "file": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "return_type": null,
          "modifiers": []
        },
        {
          "class": "CSVParser.Builder",
          "method": "setEnableByteTracking",
          "parameters": [
            "boolean"
          ],
          "start_line": 213,
          "end_line": 216,
          "package": "org.apache.commons.csv",
          "file": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "return_type": null,
          "modifiers": []
        },
        {
          "class": "CSVParser",
          "method": "nextRecord",
          "parameters": [],
          "start_line": 884,
          "end_line": 930,
          "package": "org.apache.commons.csv",
          "file": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "return_type": null,
          "modifiers": []
        },
        {
          "class": "CSVRecord",
          "method": "getBytePosition",
          "parameters": [],
          "start_line": 160,
          "end_line": 162,
          "package": "org.apache.commons.csv",
          "file": "src/main/java/org/apache/commons/csv/CSVRecord.java",
          "return_type": null,
          "modifiers": []
        },
        {
          "class": "ExtendedBufferedReader",
          "method": "mark",
          "parameters": [
            "int"
          ],
          "start_line": 136,
          "end_line": 142,
          "package": "org.apache.commons.csv",
          "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "return_type": null,
          "modifiers": []
        },
        {
          "class": "ExtendedBufferedReader",
          "method": "read",
          "parameters": [],
          "start_line": 145,
          "end_line": 157,
          "package": "org.apache.commons.csv",
          "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "return_type": null,
          "modifiers": []
        },
        {
          "class": "ExtendedBufferedReader",
          "method": "getEncodedCharLength",
          "parameters": [
            "int"
          ],
          "start_line": 185,
          "end_line": 202,
          "package": "org.apache.commons.csv",
          "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "return_type": null,
          "modifiers": []
        },
        {
          "class": "ExtendedBufferedReader",
          "method": "reset",
          "parameters": [],
          "start_line": 264,
          "end_line": 270,
          "package": "org.apache.commons.csv",
          "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "return_type": null,
          "modifiers": []
        },
        {
          "class": "ExtendedBufferedReader",
          "method": "getBytesRead",
          "parameters": [],
          "start_line": 277,
          "end_line": 279,
          "package": "org.apache.commons.csv",
          "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "return_type": null,
          "modifiers": []
        },
        {
          "class": "Lexer",
          "method": "getBytesRead",
          "parameters": [],
          "start_line": 113,
          "end_line": 115,
          "package": "org.apache.commons.csv",
          "file": "src/main/java/org/apache/commons/csv/Lexer.java",
          "return_type": null,
          "modifiers": []
        }
      ],
      "test_methods": [
        {
          "class": "CSVParserTest",
          "method": "testGetRecordThreeBytesRead",
          "parameters": [],
          "start_line": 707,
          "end_line": 740,
          "package": "org.apache.commons.csv",
          "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
          "return_type": null,
          "modifiers": [],
          "is_test_method": true
        },
        {
          "class": "CSVParserTest",
          "method": "testGetRecordFourBytesRead",
          "parameters": [],
          "start_line": 743,
          "end_line": 774,
          "package": "org.apache.commons.csv",
          "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
          "return_type": null,
          "modifiers": [],
          "is_test_method": true
        },
        {
          "class": "CSVRecordTest",
          "method": "testCSVRecordNULLValues",
          "parameters": [],
          "start_line": 88,
          "end_line": 94,
          "package": "org.apache.commons.csv",
          "file": "src/test/java/org/apache/commons/csv/CSVRecordTest.java",
          "return_type": null,
          "modifiers": [],
          "is_test_method": true
        },
        {
          "class": "JiraCsv196Test",
          "method": "parseThreeBytes",
          "parameters": [],
          "start_line": 33,
          "end_line": 50,
          "package": "org.apache.commons.csv",
          "file": "src/test/java/org/apache/commons/csv/JiraCsv196Test.java",
          "return_type": null,
          "modifiers": [],
          "is_test_method": false
        },
        {
          "class": "JiraCsv196Test",
          "method": "parseFourBytes",
          "parameters": [],
          "start_line": 54,
          "end_line": 71,
          "package": "org.apache.commons.csv",
          "file": "src/test/java/org/apache/commons/csv/JiraCsv196Test.java",
          "return_type": null,
          "modifiers": [],
          "is_test_method": false
        },
        {
          "class": "JiraCsv196Test",
          "method": "getTestInput",
          "parameters": [
            "String"
          ],
          "start_line": 73,
          "end_line": 76,
          "package": "org.apache.commons.csv",
          "file": "src/test/java/org/apache/commons/csv/JiraCsv196Test.java",
          "return_type": null,
          "modifiers": [],
          "is_test_method": false
        }
      ],
      "summary": {
        "source_methods_count": 10,
        "test_methods_count": 6
      }
    },
    "diff_info": {
      "full_diff": "diff --git a/pom.xml b/pom.xml\nindex 8679177d..63fad988 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -245,6 +245,8 @@\n               <exclude>src/test/resources/org/apache/commons/csv/CSV-141/csv-141.csv</exclude>\n               <exclude>src/test/resources/org/apache/commons/csv/csv-167/sample1.csv</exclude>\n               <exclude>src/test/resources/org/apache/commons/csv/CSV-198/optd_por_public.csv</exclude>\n+              <exclude>src/test/resources/org/apache/commons/csv/CSV-196/emoji.csv</exclude>\n+              <exclude>src/test/resources/org/apache/commons/csv/CSV-196/japanese.csv</exclude>\n               <exclude>src/test/resources/org/apache/commons/csv/CSV-213/999751170.patch.csv</exclude>\n               <exclude>src/test/resources/org/apache/commons/csv/CSVFileParser/bom.csv</exclude>\n               <exclude>src/test/resources/org/apache/commons/csv/CSVFileParser/test.csv</exclude>\ndiff --git a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex d0db9e6c..d9bb01fc 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -155,6 +155,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n         private CSVFormat format;\n         private long characterOffset;\n         private long recordNumber = 1;\n+        private boolean enableByteTracking;\n \n         /**\n          * Constructs a new instance.\n@@ -166,7 +167,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n         @SuppressWarnings(\"resource\")\n         @Override\n         public CSVParser get() throws IOException {\n-            return new CSVParser(getReader(), format != null ? format : CSVFormat.DEFAULT, characterOffset, recordNumber);\n+            return new CSVParser(getReader(), format != null ? format : CSVFormat.DEFAULT, characterOffset, recordNumber, getCharset(), enableByteTracking);\n         }\n \n         /**\n@@ -202,6 +203,18 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n             return asThis();\n         }\n \n+        /**\n+         * Sets whether to enable byte tracking for the parser.\n+         *\n+         * @param enableByteTracking {@code true} to enable byte tracking; {@code false} to disable it.\n+         * @return this instance.\n+         * @since 1.13.0\n+         */\n+        public Builder setEnableByteTracking(final boolean enableByteTracking) {\n+            this.enableByteTracking = enableByteTracking;\n+            return asThis();\n+        }\n+\n     }\n \n     final class CSVRecordIterator implements Iterator<CSVRecord> {\n@@ -510,11 +523,43 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n     @Deprecated\n     @SuppressWarnings(\"resource\")\n     public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n+        throws IOException {\n+            this(reader, format, characterOffset, recordNumber, null, false);\n+        }\n+\n+    /**\n+     * Constructs a new instance using the given {@link CSVFormat}\n+     *\n+     * <p>\n+     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n+     * unless you close the {@code reader}.\n+     * </p>\n+     *\n+     * @param reader\n+     *            a Reader containing CSV-formatted input. Must not be null.\n+     * @param format\n+     *            the CSVFormat used for CSV parsing. Must not be null.\n+     * @param characterOffset\n+     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n+     * @param recordNumber\n+     *            The next record number to assign.\n+     * @param charset\n+     *            The character encoding to be used for the reader when enableByteTracking is true.\n+     * @param enableByteTracking\n+     *           {@code true} to enable byte tracking for the parser; {@code false} to disable it.\n+     * @throws IllegalArgumentException\n+     *             If the parameters of the format are inconsistent or if either the reader or format is null.\n+     * @throws IOException\n+     *             If there is a problem reading the header or skipping the first record.\n+     * @throws CSVException Thrown on invalid input.\n+     */\n+    private CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber,\n+        final Charset charset, final boolean enableByteTracking)\n         throws IOException {\n         Objects.requireNonNull(reader, \"reader\");\n         Objects.requireNonNull(format, \"format\");\n         this.format = format.copy();\n-        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n+        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader, charset, enableByteTracking));\n         this.csvRecordIterator = new CSVRecordIterator();\n         this.headers = createHeaders();\n         this.characterOffset = characterOffset;\n@@ -841,6 +886,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n         recordList.clear();\n         StringBuilder sb = null;\n         final long startCharPosition = lexer.getCharacterPosition() + characterOffset;\n+        final long startBytePosition = lexer.getBytesRead() + this.characterOffset;\n         do {\n             reusableToken.reset();\n             lexer.nextToken(reusableToken);\n@@ -878,7 +924,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n             recordNumber++;\n             final String comment = Objects.toString(sb, null);\n             result = new CSVRecord(this, recordList.toArray(Constants.EMPTY_STRING_ARRAY), comment,\n-                recordNumber, startCharPosition);\n+                recordNumber, startCharPosition, startBytePosition);\n         }\n         return result;\n     }\ndiff --git a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex 948edbe7..284220c3 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -50,6 +50,11 @@ public final class CSVRecord implements Serializable, Iterable<String> {\n      */\n     private final long characterPosition;\n \n+    /**\n+     * The starting position of this record in the source stream, measured in bytes.\n+     */\n+    private final long bytePosition;\n+\n     /** The accumulated comments (if any) */\n     private final String comment;\n \n@@ -62,15 +67,15 @@ public final class CSVRecord implements Serializable, Iterable<String> {\n     /** The parser that originates this record. This is not serialized. */\n     private final transient CSVParser parser;\n \n-    CSVRecord(final CSVParser parser, final String[] values, final String comment, final long recordNumber,\n-            final long characterPosition) {\n+    CSVRecord(final CSVParser parser, final String[] values,  final String comment, final long recordNumber,\n+            final long characterPosition, final long bytePosition) {\n         this.recordNumber = recordNumber;\n         this.values = values != null ? values : Constants.EMPTY_STRING_ARRAY;\n         this.parser = parser;\n         this.comment = comment;\n         this.characterPosition = characterPosition;\n+        this.bytePosition = bytePosition;\n     }\n-\n     /**\n      * Returns a value by {@link Enum}.\n      *\n@@ -146,6 +151,16 @@ public final class CSVRecord implements Serializable, Iterable<String> {\n         return characterPosition;\n     }\n \n+    /**\n+     * Returns the starting position of this record in the source stream, measured in bytes.\n+     *\n+     * @return the byte position of this record in the source stream.\n+     * @since 1.13.0\n+     */\n+    public long getBytePosition() {\n+        return bytePosition;\n+    }\n+\n     /**\n      * Returns the comment for this record, if any.\n      * Note that comments are attached to the following record.\ndiff --git a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\nindex e476ad8f..6043ccaf 100644\n--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n@@ -26,6 +26,10 @@ import static org.apache.commons.io.IOUtils.EOF;\n \n import java.io.IOException;\n import java.io.Reader;\n+import java.nio.CharBuffer;\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetEncoder;\n \n import org.apache.commons.io.IOUtils;\n import org.apache.commons.io.input.UnsynchronizedBufferedReader;\n@@ -51,6 +55,13 @@ final class ExtendedBufferedReader extends UnsynchronizedBufferedReader {\n     private long position;\n     private long positionMark;\n \n+    /** The number of bytes read so far. */\n+    private long bytesRead;\n+    private long bytesReadMark;\n+\n+    /** Encoder for calculating the number of bytes for each character read. */\n+    private CharsetEncoder encoder;\n+\n     /**\n      * Constructs a new instance using the default buffer size.\n      */\n@@ -58,6 +69,22 @@ final class ExtendedBufferedReader extends UnsynchronizedBufferedReader {\n         super(reader);\n     }\n \n+    /**\n+     * Constructs a new instance with the specified reader, character set,\n+     * and byte tracking option. Initializes an encoder if byte tracking is enabled\n+     * and a character set is provided.\n+     *\n+     * @param reader the reader supports a look-ahead option.\n+     * @param charset the character set for encoding, or {@code null} if not applicable.\n+     * @param enableByteTracking {@code true} to enable byte tracking; {@code false} to disable it.\n+     */\n+    ExtendedBufferedReader(final Reader reader, Charset charset, boolean enableByteTracking) {\n+        super(reader);\n+        if (charset != null && enableByteTracking) {\n+            encoder = charset.newEncoder();\n+        }\n+    }\n+\n     /**\n      * Closes the stream.\n      *\n@@ -110,6 +137,7 @@ final class ExtendedBufferedReader extends UnsynchronizedBufferedReader {\n         lineNumberMark = lineNumber;\n         lastCharMark = lastChar;\n         positionMark = position;\n+        bytesReadMark = bytesRead;\n         super.mark(readAheadLimit);\n     }\n \n@@ -120,11 +148,59 @@ final class ExtendedBufferedReader extends UnsynchronizedBufferedReader {\n             current == EOF && lastChar != CR && lastChar != LF && lastChar != EOF) {\n             lineNumber++;\n         }\n+        if (encoder != null) {\n+            this.bytesRead += getEncodedCharLength(current);\n+        }\n         lastChar = current;\n         position++;\n         return lastChar;\n     }\n \n+    /**\n+     * Gets the byte length of the given character based on the the original Unicode\n+     * specification, which defined characters as fixed-width 16-bit entities.\n+     * <p>\n+     * The Unicode characters are divided into two main ranges:\n+     * <ul>\n+     *   <li><b>U+0000 to U+FFFF (Basic Multilingual Plane, BMP):</b>\n+     *     <ul>\n+     *       <li>Represented using a single 16-bit {@code char}.</li>\n+     *       <li>Includes UTF-8 encodings of 1-byte, 2-byte, and some 3-byte characters.</li>\n+     *     </ul>\n+     *   </li>\n+     *   <li><b>U+10000 to U+10FFFF (Supplementary Characters):</b>\n+     *     <ul>\n+     *       <li>Represented as a pair of {@code char}s:</li>\n+     *       <li>The first {@code char} is from the high-surrogates range (\\uD800-\\uDBFF).</li>\n+     *       <li>The second {@code char} is from the low-surrogates range (\\uDC00-\\uDFFF).</li>\n+     *       <li>Includes UTF-8 encodings of some 3-byte characters and all 4-byte characters.</li>\n+     *     </ul>\n+     *   </li>\n+     * </ul>\n+     *\n+     * @param current the current character to process.\n+     * @return the byte length of the character.\n+     * @throws CharacterCodingException if the character cannot be encoded.\n+     */\n+    private int getEncodedCharLength(int current) throws CharacterCodingException {\n+        final char cChar = (char) current;\n+        final char lChar = (char) lastChar;\n+        if (!Character.isSurrogate(cChar)) {\n+            return encoder.encode(\n+                CharBuffer.wrap(new char[] {cChar})).limit();\n+        } else {\n+            if (Character.isHighSurrogate(cChar)) {\n+                // Move on to the next char (low surrogate)\n+                return 0;\n+            } else if (Character.isSurrogatePair(lChar, cChar)) {\n+                return encoder.encode(\n+                    CharBuffer.wrap(new char[] {lChar, cChar})).limit();\n+            } else {\n+                throw new CharacterCodingException();\n+            }\n+        }\n+    }\n+\n     @Override\n     public int read(final char[] buf, final int offset, final int length) throws IOException {\n         if (length == 0) {\n@@ -189,7 +265,17 @@ final class ExtendedBufferedReader extends UnsynchronizedBufferedReader {\n         lineNumber = lineNumberMark;\n         lastChar = lastCharMark;\n         position = positionMark;\n+        bytesRead = bytesReadMark;\n         super.reset();\n     }\n \n+    /**\n+     * Gets the number of bytes read by the reader.\n+     *\n+     * @return the number of bytes read by the read\n+     */\n+    long getBytesRead() {\n+        return this.bytesRead;\n+    }\n+\n }\ndiff --git a/src/main/java/org/apache/commons/csv/Lexer.java b/src/main/java/org/apache/commons/csv/Lexer.java\nindex 20227df1..2e7d2d04 100644\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n@@ -105,6 +105,15 @@ final class Lexer implements Closeable {\n         return reader.getPosition();\n     }\n \n+    /**\n+     * Gets the number of bytes read\n+     *\n+     * @return the number of bytes read\n+     */\n+    long getBytesRead() {\n+        return reader.getBytesRead();\n+    }\n+\n     /**\n      * Returns the current line number\n      *\ndiff --git a/src/test/java/org/apache/commons/csv/CSVParserTest.java b/src/test/java/org/apache/commons/csv/CSVParserTest.java\nindex 44a9afd5..c42a3c25 100644\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n@@ -703,6 +703,76 @@ public class CSVParserTest {\n         }\r\n     }\r\n \r\n+    @Test\r\n+    public void testGetRecordThreeBytesRead() throws Exception {\r\n+        final String code = \"id,date,val5,val4\\n\" +\r\n+            \"11111111111111,'4017-09-01',ãã¡ã‚“ã¨ç¯€åˆ†è¿‘ãã«ã¯å’²ã„ã¦ã‚‹ï½,v4\\n\" +\r\n+            \"22222222222222,'4017-01-01',ãŠã¯ã‚ˆã†ç§ã®å‹äººï½,v4\\n\" +\r\n+            \"33333333333333,'4017-01-01',ãã‚‹è‡ªç„¶ã®åŠ›ã£ã¦ã™ã”ã„ãªï½,v4\\n\";\r\n+        final CSVFormat format = CSVFormat.Builder.create()\r\n+            .setDelimiter(',')\r\n+            .setQuote('\\'')\r\n+            .get();\r\n+        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setEnableByteTracking(true).get() ) {\r\n+            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n+\r\n+            assertEquals(0, parser.getRecordNumber());\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(1, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n+\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(2, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n+\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(3, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), 95);\r\n+\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(4, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), 154);\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void testGetRecordFourBytesRead() throws Exception {\r\n+        final String code = \"id,a,b,c\\n\" +\r\n+            \"1,ğŸ˜Š,ğŸ¤”,ğŸ˜‚\\n\" +\r\n+            \"2,ğŸ˜Š,ğŸ¤”,ğŸ˜‚\\n\" +\r\n+            \"3,ğŸ˜Š,ğŸ¤”,ğŸ˜‚\\n\";\r\n+        final CSVFormat format = CSVFormat.Builder.create()\r\n+            .setDelimiter(',')\r\n+            .setQuote('\\'')\r\n+            .get();\r\n+        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setEnableByteTracking(true).get()) {\r\n+            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n+\r\n+            assertEquals(0, parser.getRecordNumber());\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(1, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n+\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(2, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(3, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), 26);\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(4, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), 43);\r\n+        }\r\n+    }\r\n+\r\n     @Test\r\n     public void testGetHeaderMap() throws Exception {\r\n         try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\r\ndiff --git a/src/test/java/org/apache/commons/csv/CSVRecordTest.java b/src/test/java/org/apache/commons/csv/CSVRecordTest.java\nindex b9f9ceae..cd644b15 100644\n--- a/src/test/java/org/apache/commons/csv/CSVRecordTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVRecordTest.java\n@@ -87,7 +87,7 @@ public class CSVRecordTest {\n     @Test\n     public void testCSVRecordNULLValues() throws IOException {\n         try (CSVParser parser = CSVParser.parse(\"A,B\\r\\nONE,TWO\", CSVFormat.DEFAULT.withHeader())) {\n-            final CSVRecord csvRecord = new CSVRecord(parser, null, null, 0L, 0L);\n+            final CSVRecord csvRecord = new CSVRecord(parser, null, null, 0L, 0L, 0L);\n             assertEquals(0, csvRecord.size());\n             assertThrows(IllegalArgumentException.class, () -> csvRecord.get(\"B\"));\n         }\ndiff --git a/src/test/java/org/apache/commons/csv/JiraCsv196Test.java b/src/test/java/org/apache/commons/csv/JiraCsv196Test.java\nnew file mode 100644\nindex 00000000..ab7af819\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/csv/JiraCsv196Test.java\n@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.csv;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.junit.jupiter.api.Test;\n+\n+\n+public class JiraCsv196Test {\n+    @Test\n+    public void parseThreeBytes() throws IOException {\n+        final CSVFormat format = CSVFormat.Builder.create()\n+            .setDelimiter(',')\n+            .setQuote('\\'')\n+            .get();\n+        final CSVParser parser = new CSVParser.Builder()\n+            .setFormat(format)\n+            .setReader(getTestInput(\"org/apache/commons/csv/CSV-196/japanese.csv\"))\n+            .setCharset(StandardCharsets.UTF_8)\n+            .setEnableByteTracking(true)\n+            .get();\n+        final long[] charByteKey = {0, 89, 242, 395};\n+        int idx = 0;\n+        for (CSVRecord record : parser) {\n+            assertEquals(charByteKey[idx++], record.getBytePosition());\n+        }\n+        parser.close();\n+    }\n+\n+\n+    @Test\n+    public void parseFourBytes() throws IOException {\n+        final CSVFormat format = CSVFormat.Builder.create()\n+            .setDelimiter(',')\n+            .setQuote('\\'')\n+            .get();\n+        final CSVParser parser = new CSVParser.Builder()\n+            .setFormat(format)\n+            .setReader(getTestInput(\"org/apache/commons/csv/CSV-196/emoji.csv\"))\n+            .setCharset(StandardCharsets.UTF_8)\n+            .setEnableByteTracking(true)\n+            .get();\n+        final long[] charByteKey = {0, 84, 701, 1318, 1935};\n+        int idx = 0;\n+        for (CSVRecord record : parser) {\n+            assertEquals(charByteKey[idx++], record.getBytePosition());\n+        }\n+        parser.close();\n+    }\n+\n+    private Reader getTestInput(String path) {\n+        return new InputStreamReader(\n+            ClassLoader.getSystemClassLoader().getResourceAsStream(path));\n+    }\n+}\ndiff --git a/src/test/resources/org/apache/commons/csv/CSV-196/emoji.csv b/src/test/resources/org/apache/commons/csv/CSV-196/emoji.csv\nnew file mode 100644\nindex 00000000..0bff7a44\n--- /dev/null\n+++ b/src/test/resources/org/apache/commons/csv/CSV-196/emoji.csv\n@@ -0,0 +1,5 @@\n+id,val1,val2,val3,val4,val5,val6,val7,val8,val9,val10,val11,val12,val13,val14,val15\n+1,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„\n+2,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„\n+3,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„\n+4,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„\n\\ No newline at end of file\ndiff --git a/src/test/resources/org/apache/commons/csv/CSV-196/japanese.csv b/src/test/resources/org/apache/commons/csv/CSV-196/japanese.csv\nnew file mode 100644\nindex 00000000..b06e04bd\n--- /dev/null\n+++ b/src/test/resources/org/apache/commons/csv/CSV-196/japanese.csv\n@@ -0,0 +1,4 @@\n+id,date,val1,val2,val3,val4,val5,val6,val7,val8,val9,val10,val11,val12,val13,val14,val15\n+00000000000001,2017-01-01,ãã¡ã‚“ã¨ç¯€åˆ†è¿‘ãã«ã¯å’²ã„ã¦ã‚‹ã€‚è‡ªç„¶ã®åŠ›ã£ã¦ã™ã”ã„ãªï½,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15\n+00000000000002,2017-01-01,ãã¡ã‚“ã¨ç¯€åˆ†è¿‘ãã«ã¯å’²ã„ã¦ã‚‹ã€‚è‡ªç„¶ã®åŠ›ã£ã¦ã™ã”ã„ãªï½,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15\n+00000000000003,2017-01-01,ãã¡ã‚“ã¨ç¯€åˆ†è¿‘ãã«ã¯å’²ã„ã¦ã‚‹ã€‚è‡ªç„¶ã®åŠ›ã£ã¦ã™ã”ã„ãªï½,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15\n\\ No newline at end of file",
      "source_only_diff": "diff --git a/pom.xml b/pom.xml\nindex 8679177d..63fad988 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -245,6 +245,8 @@\n               <exclude>src/test/resources/org/apache/commons/csv/CSV-141/csv-141.csv</exclude>\n               <exclude>src/test/resources/org/apache/commons/csv/csv-167/sample1.csv</exclude>\n               <exclude>src/test/resources/org/apache/commons/csv/CSV-198/optd_por_public.csv</exclude>\n+              <exclude>src/test/resources/org/apache/commons/csv/CSV-196/emoji.csv</exclude>\n+              <exclude>src/test/resources/org/apache/commons/csv/CSV-196/japanese.csv</exclude>\n               <exclude>src/test/resources/org/apache/commons/csv/CSV-213/999751170.patch.csv</exclude>\n               <exclude>src/test/resources/org/apache/commons/csv/CSVFileParser/bom.csv</exclude>\n               <exclude>src/test/resources/org/apache/commons/csv/CSVFileParser/test.csv</exclude>\n\ndiff --git a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex d0db9e6c..d9bb01fc 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -155,6 +155,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n         private CSVFormat format;\n         private long characterOffset;\n         private long recordNumber = 1;\n+        private boolean enableByteTracking;\n \n         /**\n          * Constructs a new instance.\n@@ -166,7 +167,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n         @SuppressWarnings(\"resource\")\n         @Override\n         public CSVParser get() throws IOException {\n-            return new CSVParser(getReader(), format != null ? format : CSVFormat.DEFAULT, characterOffset, recordNumber);\n+            return new CSVParser(getReader(), format != null ? format : CSVFormat.DEFAULT, characterOffset, recordNumber, getCharset(), enableByteTracking);\n         }\n \n         /**\n@@ -202,6 +203,18 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n             return asThis();\n         }\n \n+        /**\n+         * Sets whether to enable byte tracking for the parser.\n+         *\n+         * @param enableByteTracking {@code true} to enable byte tracking; {@code false} to disable it.\n+         * @return this instance.\n+         * @since 1.13.0\n+         */\n+        public Builder setEnableByteTracking(final boolean enableByteTracking) {\n+            this.enableByteTracking = enableByteTracking;\n+            return asThis();\n+        }\n+\n     }\n \n     final class CSVRecordIterator implements Iterator<CSVRecord> {\n@@ -510,11 +523,43 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n     @Deprecated\n     @SuppressWarnings(\"resource\")\n     public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n+        throws IOException {\n+            this(reader, format, characterOffset, recordNumber, null, false);\n+        }\n+\n+    /**\n+     * Constructs a new instance using the given {@link CSVFormat}\n+     *\n+     * <p>\n+     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n+     * unless you close the {@code reader}.\n+     * </p>\n+     *\n+     * @param reader\n+     *            a Reader containing CSV-formatted input. Must not be null.\n+     * @param format\n+     *            the CSVFormat used for CSV parsing. Must not be null.\n+     * @param characterOffset\n+     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n+     * @param recordNumber\n+     *            The next record number to assign.\n+     * @param charset\n+     *            The character encoding to be used for the reader when enableByteTracking is true.\n+     * @param enableByteTracking\n+     *           {@code true} to enable byte tracking for the parser; {@code false} to disable it.\n+     * @throws IllegalArgumentException\n+     *             If the parameters of the format are inconsistent or if either the reader or format is null.\n+     * @throws IOException\n+     *             If there is a problem reading the header or skipping the first record.\n+     * @throws CSVException Thrown on invalid input.\n+     */\n+    private CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber,\n+        final Charset charset, final boolean enableByteTracking)\n         throws IOException {\n         Objects.requireNonNull(reader, \"reader\");\n         Objects.requireNonNull(format, \"format\");\n         this.format = format.copy();\n-        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n+        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader, charset, enableByteTracking));\n         this.csvRecordIterator = new CSVRecordIterator();\n         this.headers = createHeaders();\n         this.characterOffset = characterOffset;\n@@ -841,6 +886,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n         recordList.clear();\n         StringBuilder sb = null;\n         final long startCharPosition = lexer.getCharacterPosition() + characterOffset;\n+        final long startBytePosition = lexer.getBytesRead() + this.characterOffset;\n         do {\n             reusableToken.reset();\n             lexer.nextToken(reusableToken);\n@@ -878,7 +924,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n             recordNumber++;\n             final String comment = Objects.toString(sb, null);\n             result = new CSVRecord(this, recordList.toArray(Constants.EMPTY_STRING_ARRAY), comment,\n-                recordNumber, startCharPosition);\n+                recordNumber, startCharPosition, startBytePosition);\n         }\n         return result;\n     }\n\ndiff --git a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex 948edbe7..284220c3 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -50,6 +50,11 @@ public final class CSVRecord implements Serializable, Iterable<String> {\n      */\n     private final long characterPosition;\n \n+    /**\n+     * The starting position of this record in the source stream, measured in bytes.\n+     */\n+    private final long bytePosition;\n+\n     /** The accumulated comments (if any) */\n     private final String comment;\n \n@@ -62,15 +67,15 @@ public final class CSVRecord implements Serializable, Iterable<String> {\n     /** The parser that originates this record. This is not serialized. */\n     private final transient CSVParser parser;\n \n-    CSVRecord(final CSVParser parser, final String[] values, final String comment, final long recordNumber,\n-            final long characterPosition) {\n+    CSVRecord(final CSVParser parser, final String[] values,  final String comment, final long recordNumber,\n+            final long characterPosition, final long bytePosition) {\n         this.recordNumber = recordNumber;\n         this.values = values != null ? values : Constants.EMPTY_STRING_ARRAY;\n         this.parser = parser;\n         this.comment = comment;\n         this.characterPosition = characterPosition;\n+        this.bytePosition = bytePosition;\n     }\n-\n     /**\n      * Returns a value by {@link Enum}.\n      *\n@@ -146,6 +151,16 @@ public final class CSVRecord implements Serializable, Iterable<String> {\n         return characterPosition;\n     }\n \n+    /**\n+     * Returns the starting position of this record in the source stream, measured in bytes.\n+     *\n+     * @return the byte position of this record in the source stream.\n+     * @since 1.13.0\n+     */\n+    public long getBytePosition() {\n+        return bytePosition;\n+    }\n+\n     /**\n      * Returns the comment for this record, if any.\n      * Note that comments are attached to the following record.\n\ndiff --git a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\nindex e476ad8f..6043ccaf 100644\n--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n@@ -26,6 +26,10 @@ import static org.apache.commons.io.IOUtils.EOF;\n \n import java.io.IOException;\n import java.io.Reader;\n+import java.nio.CharBuffer;\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetEncoder;\n \n import org.apache.commons.io.IOUtils;\n import org.apache.commons.io.input.UnsynchronizedBufferedReader;\n@@ -51,6 +55,13 @@ final class ExtendedBufferedReader extends UnsynchronizedBufferedReader {\n     private long position;\n     private long positionMark;\n \n+    /** The number of bytes read so far. */\n+    private long bytesRead;\n+    private long bytesReadMark;\n+\n+    /** Encoder for calculating the number of bytes for each character read. */\n+    private CharsetEncoder encoder;\n+\n     /**\n      * Constructs a new instance using the default buffer size.\n      */\n@@ -58,6 +69,22 @@ final class ExtendedBufferedReader extends UnsynchronizedBufferedReader {\n         super(reader);\n     }\n \n+    /**\n+     * Constructs a new instance with the specified reader, character set,\n+     * and byte tracking option. Initializes an encoder if byte tracking is enabled\n+     * and a character set is provided.\n+     *\n+     * @param reader the reader supports a look-ahead option.\n+     * @param charset the character set for encoding, or {@code null} if not applicable.\n+     * @param enableByteTracking {@code true} to enable byte tracking; {@code false} to disable it.\n+     */\n+    ExtendedBufferedReader(final Reader reader, Charset charset, boolean enableByteTracking) {\n+        super(reader);\n+        if (charset != null && enableByteTracking) {\n+            encoder = charset.newEncoder();\n+        }\n+    }\n+\n     /**\n      * Closes the stream.\n      *\n@@ -110,6 +137,7 @@ final class ExtendedBufferedReader extends UnsynchronizedBufferedReader {\n         lineNumberMark = lineNumber;\n         lastCharMark = lastChar;\n         positionMark = position;\n+        bytesReadMark = bytesRead;\n         super.mark(readAheadLimit);\n     }\n \n@@ -120,11 +148,59 @@ final class ExtendedBufferedReader extends UnsynchronizedBufferedReader {\n             current == EOF && lastChar != CR && lastChar != LF && lastChar != EOF) {\n             lineNumber++;\n         }\n+        if (encoder != null) {\n+            this.bytesRead += getEncodedCharLength(current);\n+        }\n         lastChar = current;\n         position++;\n         return lastChar;\n     }\n \n+    /**\n+     * Gets the byte length of the given character based on the the original Unicode\n+     * specification, which defined characters as fixed-width 16-bit entities.\n+     * <p>\n+     * The Unicode characters are divided into two main ranges:\n+     * <ul>\n+     *   <li><b>U+0000 to U+FFFF (Basic Multilingual Plane, BMP):</b>\n+     *     <ul>\n+     *       <li>Represented using a single 16-bit {@code char}.</li>\n+     *       <li>Includes UTF-8 encodings of 1-byte, 2-byte, and some 3-byte characters.</li>\n+     *     </ul>\n+     *   </li>\n+     *   <li><b>U+10000 to U+10FFFF (Supplementary Characters):</b>\n+     *     <ul>\n+     *       <li>Represented as a pair of {@code char}s:</li>\n+     *       <li>The first {@code char} is from the high-surrogates range (\\uD800-\\uDBFF).</li>\n+     *       <li>The second {@code char} is from the low-surrogates range (\\uDC00-\\uDFFF).</li>\n+     *       <li>Includes UTF-8 encodings of some 3-byte characters and all 4-byte characters.</li>\n+     *     </ul>\n+     *   </li>\n+     * </ul>\n+     *\n+     * @param current the current character to process.\n+     * @return the byte length of the character.\n+     * @throws CharacterCodingException if the character cannot be encoded.\n+     */\n+    private int getEncodedCharLength(int current) throws CharacterCodingException {\n+        final char cChar = (char) current;\n+        final char lChar = (char) lastChar;\n+        if (!Character.isSurrogate(cChar)) {\n+            return encoder.encode(\n+                CharBuffer.wrap(new char[] {cChar})).limit();\n+        } else {\n+            if (Character.isHighSurrogate(cChar)) {\n+                // Move on to the next char (low surrogate)\n+                return 0;\n+            } else if (Character.isSurrogatePair(lChar, cChar)) {\n+                return encoder.encode(\n+                    CharBuffer.wrap(new char[] {lChar, cChar})).limit();\n+            } else {\n+                throw new CharacterCodingException();\n+            }\n+        }\n+    }\n+\n     @Override\n     public int read(final char[] buf, final int offset, final int length) throws IOException {\n         if (length == 0) {\n@@ -189,7 +265,17 @@ final class ExtendedBufferedReader extends UnsynchronizedBufferedReader {\n         lineNumber = lineNumberMark;\n         lastChar = lastCharMark;\n         position = positionMark;\n+        bytesRead = bytesReadMark;\n         super.reset();\n     }\n \n+    /**\n+     * Gets the number of bytes read by the reader.\n+     *\n+     * @return the number of bytes read by the read\n+     */\n+    long getBytesRead() {\n+        return this.bytesRead;\n+    }\n+\n }\n\ndiff --git a/src/main/java/org/apache/commons/csv/Lexer.java b/src/main/java/org/apache/commons/csv/Lexer.java\nindex 20227df1..2e7d2d04 100644\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n@@ -105,6 +105,15 @@ final class Lexer implements Closeable {\n         return reader.getPosition();\n     }\n \n+    /**\n+     * Gets the number of bytes read\n+     *\n+     * @return the number of bytes read\n+     */\n+    long getBytesRead() {\n+        return reader.getBytesRead();\n+    }\n+\n     /**\n      * Returns the current line number\n      *\n",
      "test_only_diff": "diff --git a/src/test/java/org/apache/commons/csv/CSVParserTest.java b/src/test/java/org/apache/commons/csv/CSVParserTest.java\nindex 44a9afd5..c42a3c25 100644\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n@@ -703,6 +703,76 @@ public class CSVParserTest {\n         }\r\n     }\r\n \r\n+    @Test\r\n+    public void testGetRecordThreeBytesRead() throws Exception {\r\n+        final String code = \"id,date,val5,val4\\n\" +\r\n+            \"11111111111111,'4017-09-01',ãã¡ã‚“ã¨ç¯€åˆ†è¿‘ãã«ã¯å’²ã„ã¦ã‚‹ï½,v4\\n\" +\r\n+            \"22222222222222,'4017-01-01',ãŠã¯ã‚ˆã†ç§ã®å‹äººï½,v4\\n\" +\r\n+            \"33333333333333,'4017-01-01',ãã‚‹è‡ªç„¶ã®åŠ›ã£ã¦ã™ã”ã„ãªï½,v4\\n\";\r\n+        final CSVFormat format = CSVFormat.Builder.create()\r\n+            .setDelimiter(',')\r\n+            .setQuote('\\'')\r\n+            .get();\r\n+        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setEnableByteTracking(true).get() ) {\r\n+            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n+\r\n+            assertEquals(0, parser.getRecordNumber());\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(1, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n+\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(2, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n+\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(3, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), 95);\r\n+\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(4, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), 154);\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void testGetRecordFourBytesRead() throws Exception {\r\n+        final String code = \"id,a,b,c\\n\" +\r\n+            \"1,ğŸ˜Š,ğŸ¤”,ğŸ˜‚\\n\" +\r\n+            \"2,ğŸ˜Š,ğŸ¤”,ğŸ˜‚\\n\" +\r\n+            \"3,ğŸ˜Š,ğŸ¤”,ğŸ˜‚\\n\";\r\n+        final CSVFormat format = CSVFormat.Builder.create()\r\n+            .setDelimiter(',')\r\n+            .setQuote('\\'')\r\n+            .get();\r\n+        try (CSVParser parser = CSVParser.builder().setReader(new StringReader(code)).setFormat(format).setCharset(UTF_8).setEnableByteTracking(true).get()) {\r\n+            CSVRecord record = new CSVRecord(parser, null, null, 1L, 0L, 0L);\r\n+\r\n+            assertEquals(0, parser.getRecordNumber());\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(1, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('i'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n+\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(2, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('1'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), record.getCharacterPosition());\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(3, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('2'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), 26);\r\n+            assertNotNull(record = parser.nextRecord());\r\n+            assertEquals(4, record.getRecordNumber());\r\n+            assertEquals(code.indexOf('3'), record.getCharacterPosition());\r\n+            assertEquals(record.getBytePosition(), 43);\r\n+        }\r\n+    }\r\n+\r\n     @Test\r\n     public void testGetHeaderMap() throws Exception {\r\n         try (CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\r\n\ndiff --git a/src/test/java/org/apache/commons/csv/CSVRecordTest.java b/src/test/java/org/apache/commons/csv/CSVRecordTest.java\nindex b9f9ceae..cd644b15 100644\n--- a/src/test/java/org/apache/commons/csv/CSVRecordTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVRecordTest.java\n@@ -87,7 +87,7 @@ public class CSVRecordTest {\n     @Test\n     public void testCSVRecordNULLValues() throws IOException {\n         try (CSVParser parser = CSVParser.parse(\"A,B\\r\\nONE,TWO\", CSVFormat.DEFAULT.withHeader())) {\n-            final CSVRecord csvRecord = new CSVRecord(parser, null, null, 0L, 0L);\n+            final CSVRecord csvRecord = new CSVRecord(parser, null, null, 0L, 0L, 0L);\n             assertEquals(0, csvRecord.size());\n             assertThrows(IllegalArgumentException.class, () -> csvRecord.get(\"B\"));\n         }\n\ndiff --git a/src/test/java/org/apache/commons/csv/JiraCsv196Test.java b/src/test/java/org/apache/commons/csv/JiraCsv196Test.java\nnew file mode 100644\nindex 00000000..ab7af819\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/csv/JiraCsv196Test.java\n@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.csv;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.junit.jupiter.api.Test;\n+\n+\n+public class JiraCsv196Test {\n+    @Test\n+    public void parseThreeBytes() throws IOException {\n+        final CSVFormat format = CSVFormat.Builder.create()\n+            .setDelimiter(',')\n+            .setQuote('\\'')\n+            .get();\n+        final CSVParser parser = new CSVParser.Builder()\n+            .setFormat(format)\n+            .setReader(getTestInput(\"org/apache/commons/csv/CSV-196/japanese.csv\"))\n+            .setCharset(StandardCharsets.UTF_8)\n+            .setEnableByteTracking(true)\n+            .get();\n+        final long[] charByteKey = {0, 89, 242, 395};\n+        int idx = 0;\n+        for (CSVRecord record : parser) {\n+            assertEquals(charByteKey[idx++], record.getBytePosition());\n+        }\n+        parser.close();\n+    }\n+\n+\n+    @Test\n+    public void parseFourBytes() throws IOException {\n+        final CSVFormat format = CSVFormat.Builder.create()\n+            .setDelimiter(',')\n+            .setQuote('\\'')\n+            .get();\n+        final CSVParser parser = new CSVParser.Builder()\n+            .setFormat(format)\n+            .setReader(getTestInput(\"org/apache/commons/csv/CSV-196/emoji.csv\"))\n+            .setCharset(StandardCharsets.UTF_8)\n+            .setEnableByteTracking(true)\n+            .get();\n+        final long[] charByteKey = {0, 84, 701, 1318, 1935};\n+        int idx = 0;\n+        for (CSVRecord record : parser) {\n+            assertEquals(charByteKey[idx++], record.getBytePosition());\n+        }\n+        parser.close();\n+    }\n+\n+    private Reader getTestInput(String path) {\n+        return new InputStreamReader(\n+            ClassLoader.getSystemClassLoader().getResourceAsStream(path));\n+    }\n+}\n\ndiff --git a/src/test/resources/org/apache/commons/csv/CSV-196/emoji.csv b/src/test/resources/org/apache/commons/csv/CSV-196/emoji.csv\nnew file mode 100644\nindex 00000000..0bff7a44\n--- /dev/null\n+++ b/src/test/resources/org/apache/commons/csv/CSV-196/emoji.csv\n@@ -0,0 +1,5 @@\n+id,val1,val2,val3,val4,val5,val6,val7,val8,val9,val10,val11,val12,val13,val14,val15\n+1,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„\n+2,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„\n+3,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„\n+4,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„,ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„\n\\ No newline at end of file\n\ndiff --git a/src/test/resources/org/apache/commons/csv/CSV-196/japanese.csv b/src/test/resources/org/apache/commons/csv/CSV-196/japanese.csv\nnew file mode 100644\nindex 00000000..b06e04bd\n--- /dev/null\n+++ b/src/test/resources/org/apache/commons/csv/CSV-196/japanese.csv\n@@ -0,0 +1,4 @@\n+id,date,val1,val2,val3,val4,val5,val6,val7,val8,val9,val10,val11,val12,val13,val14,val15\n+00000000000001,2017-01-01,ãã¡ã‚“ã¨ç¯€åˆ†è¿‘ãã«ã¯å’²ã„ã¦ã‚‹ã€‚è‡ªç„¶ã®åŠ›ã£ã¦ã™ã”ã„ãªï½,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15\n+00000000000002,2017-01-01,ãã¡ã‚“ã¨ç¯€åˆ†è¿‘ãã«ã¯å’²ã„ã¦ã‚‹ã€‚è‡ªç„¶ã®åŠ›ã£ã¦ã™ã”ã„ãªï½,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15\n+00000000000003,2017-01-01,ãã¡ã‚“ã¨ç¯€åˆ†è¿‘ãã«ã¯å’²ã„ã¦ã‚‹ã€‚è‡ªç„¶ã®åŠ›ã£ã¦ã™ã”ã„ãªï½,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15\n\\ No newline at end of file",
      "stats": {
        "source_files": 5,
        "test_files": 5,
        "filtered": true
      },
      "change_stats": {
        "full": {
          "files": [
            {
              "path": "pom.xml",
              "lines_added": 2,
              "lines_removed": 0,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
              "lines_added": 49,
              "lines_removed": 3,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
              "lines_added": 18,
              "lines_removed": 3,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
              "lines_added": 86,
              "lines_removed": 0,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/main/java/org/apache/commons/csv/Lexer.java",
              "lines_added": 9,
              "lines_removed": 0,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
              "lines_added": 70,
              "lines_removed": 0,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/test/java/org/apache/commons/csv/CSVRecordTest.java",
              "lines_added": 1,
              "lines_removed": 1,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/test/java/org/apache/commons/csv/JiraCsv196Test.java",
              "lines_added": 77,
              "lines_removed": 0,
              "is_new": true,
              "is_deleted": false
            },
            {
              "path": "src/test/resources/org/apache/commons/csv/CSV-196/emoji.csv",
              "lines_added": 5,
              "lines_removed": 0,
              "is_new": true,
              "is_deleted": false
            },
            {
              "path": "src/test/resources/org/apache/commons/csv/CSV-196/japanese.csv",
              "lines_added": 4,
              "lines_removed": 0,
              "is_new": true,
              "is_deleted": false
            }
          ],
          "total_lines_added": 321,
          "total_lines_removed": 7
        },
        "source": {
          "files": [
            {
              "path": "pom.xml",
              "lines_added": 2,
              "lines_removed": 0,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/main/java/org/apache/commons/csv/CSVParser.java",
              "lines_added": 49,
              "lines_removed": 3,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
              "lines_added": 18,
              "lines_removed": 3,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
              "lines_added": 86,
              "lines_removed": 0,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/main/java/org/apache/commons/csv/Lexer.java",
              "lines_added": 9,
              "lines_removed": 0,
              "is_new": false,
              "is_deleted": false
            }
          ],
          "total_lines_added": 164,
          "total_lines_removed": 6
        },
        "test": {
          "files": [
            {
              "path": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
              "lines_added": 70,
              "lines_removed": 0,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/test/java/org/apache/commons/csv/CSVRecordTest.java",
              "lines_added": 1,
              "lines_removed": 1,
              "is_new": false,
              "is_deleted": false
            },
            {
              "path": "src/test/java/org/apache/commons/csv/JiraCsv196Test.java",
              "lines_added": 77,
              "lines_removed": 0,
              "is_new": true,
              "is_deleted": false
            },
            {
              "path": "src/test/resources/org/apache/commons/csv/CSV-196/emoji.csv",
              "lines_added": 5,
              "lines_removed": 0,
              "is_new": true,
              "is_deleted": false
            },
            {
              "path": "src/test/resources/org/apache/commons/csv/CSV-196/japanese.csv",
              "lines_added": 4,
              "lines_removed": 0,
              "is_new": true,
              "is_deleted": false
            }
          ],
          "total_lines_added": 157,
          "total_lines_removed": 1
        }
      }
    },
    "method_change_stats": {
      "source": [
        {
          "package": "org.apache.commons.csv",
          "class": "CSVParser.Builder",
          "method": "get",
          "parameters": [],
          "file": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "added_lines": 1,
          "removed_lines": 1,
          "total_changed_lines": 2
        },
        {
          "package": "org.apache.commons.csv",
          "class": "CSVParser.Builder",
          "method": "setEnableByteTracking",
          "parameters": [
            "boolean"
          ],
          "file": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "added_lines": 4,
          "removed_lines": 0,
          "total_changed_lines": 4
        },
        {
          "package": "org.apache.commons.csv",
          "class": "CSVParser",
          "method": "nextRecord",
          "parameters": [],
          "file": "src/main/java/org/apache/commons/csv/CSVParser.java",
          "added_lines": 2,
          "removed_lines": 1,
          "total_changed_lines": 3
        },
        {
          "package": "org.apache.commons.csv",
          "class": "CSVRecord",
          "method": "getBytePosition",
          "parameters": [],
          "file": "src/main/java/org/apache/commons/csv/CSVRecord.java",
          "added_lines": 3,
          "removed_lines": 0,
          "total_changed_lines": 3
        },
        {
          "package": "org.apache.commons.csv",
          "class": "ExtendedBufferedReader",
          "method": "mark",
          "parameters": [
            "int"
          ],
          "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "added_lines": 1,
          "removed_lines": 0,
          "total_changed_lines": 1
        },
        {
          "package": "org.apache.commons.csv",
          "class": "ExtendedBufferedReader",
          "method": "read",
          "parameters": [],
          "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "added_lines": 3,
          "removed_lines": 0,
          "total_changed_lines": 3
        },
        {
          "package": "org.apache.commons.csv",
          "class": "ExtendedBufferedReader",
          "method": "getEncodedCharLength",
          "parameters": [
            "int"
          ],
          "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "added_lines": 18,
          "removed_lines": 0,
          "total_changed_lines": 18
        },
        {
          "package": "org.apache.commons.csv",
          "class": "ExtendedBufferedReader",
          "method": "reset",
          "parameters": [],
          "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "added_lines": 1,
          "removed_lines": 0,
          "total_changed_lines": 1
        },
        {
          "package": "org.apache.commons.csv",
          "class": "ExtendedBufferedReader",
          "method": "getBytesRead",
          "parameters": [],
          "file": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
          "added_lines": 3,
          "removed_lines": 0,
          "total_changed_lines": 3
        },
        {
          "package": "org.apache.commons.csv",
          "class": "Lexer",
          "method": "getBytesRead",
          "parameters": [],
          "file": "src/main/java/org/apache/commons/csv/Lexer.java",
          "added_lines": 3,
          "removed_lines": 0,
          "total_changed_lines": 3
        }
      ],
      "test": [
        {
          "package": "org.apache.commons.csv",
          "class": "CSVParserTest",
          "method": "testGetRecordThreeBytesRead",
          "parameters": [],
          "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
          "added_lines": 34,
          "removed_lines": 0,
          "total_changed_lines": 34
        },
        {
          "package": "org.apache.commons.csv",
          "class": "CSVParserTest",
          "method": "testGetRecordFourBytesRead",
          "parameters": [],
          "file": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
          "added_lines": 32,
          "removed_lines": 0,
          "total_changed_lines": 32
        },
        {
          "package": "org.apache.commons.csv",
          "class": "CSVRecordTest",
          "method": "testCSVRecordNULLValues",
          "parameters": [],
          "file": "src/test/java/org/apache/commons/csv/CSVRecordTest.java",
          "added_lines": 1,
          "removed_lines": 1,
          "total_changed_lines": 2
        },
        {
          "package": "org.apache.commons.csv",
          "class": "JiraCsv196Test",
          "method": "parseThreeBytes",
          "parameters": [],
          "file": "src/test/java/org/apache/commons/csv/JiraCsv196Test.java",
          "added_lines": 18,
          "removed_lines": 0,
          "total_changed_lines": 18
        },
        {
          "package": "org.apache.commons.csv",
          "class": "JiraCsv196Test",
          "method": "parseFourBytes",
          "parameters": [],
          "file": "src/test/java/org/apache/commons/csv/JiraCsv196Test.java",
          "added_lines": 18,
          "removed_lines": 0,
          "total_changed_lines": 18
        },
        {
          "package": "org.apache.commons.csv",
          "class": "JiraCsv196Test",
          "method": "getTestInput",
          "parameters": [
            "String"
          ],
          "file": "src/test/java/org/apache/commons/csv/JiraCsv196Test.java",
          "added_lines": 4,
          "removed_lines": 0,
          "total_changed_lines": 4
        }
      ]
    },
    "has_method_changes": true
  }
}